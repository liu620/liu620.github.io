<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Kafka源码学习(一)-构建Kafka工程和源码阅读环境</title>
    <link href="/2025/07/06/Kafka%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E6%9E%84%E5%BB%BAKafka%E5%B7%A5%E7%A8%8B%E5%92%8C%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83/"/>
    <url>/2025/07/06/Kafka%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E6%9E%84%E5%BB%BAKafka%E5%B7%A5%E7%A8%8B%E5%92%8C%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前置说明"><a href="#1-前置说明" class="headerlink" title="1. 前置说明"></a>1. 前置说明</h1><p>看技术文章 -&gt; 思考 -&gt; 输出为blog，这是一个有效的正向循环，而看代码 -&gt; 思考 -&gt; 实操也是如此。这能更加深入理解，并且比单看有趣的多。所以源码学习是必不可少的，这是是Kafka 学习的姊妹篇，<a href="https://blog.liuailin.top/2025/06/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3kafka-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E7%AF%87%E3%80%90%E5%B9%B2%E7%9A%84%E8%A6%81%E5%91%BD%E7%B3%BB%E5%88%97%E3%80%91%EF%BC%88%E4%B8%80%EF%BC%89/">深入理解kafka-核心技术与实战篇【干的要命系列】</a> 的后续源码学习篇。</p><h1 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2. 环境搭建"></a>2. 环境搭建</h1><p>在开始之前需要做一些准备工作，软件的安装，比如：Java 环境、Gradle、Scala、IDE、Git 等等。</p><ol><li>Java 版本：目前最新的需要 17 或者 23 </li><li>Gradle：使用gradlew 命令来具体安装</li><li>Scala 需要 2.13 是唯一支持的版本</li><li>IED 的话就用 IDEA、Git 的话也不用说了</li></ol><h1 id="3-构建Kafka-工程"><a href="#3-构建Kafka-工程" class="headerlink" title="3. 构建Kafka 工程"></a>3. 构建Kafka 工程</h1><p>使用命令行从 github 上拉取分支，默认Trunk：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://github.com/apache/kafka.git</span><br></code></pre></td></tr></table></figure><p>然后执行命令, MAC OS 上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./gradlew build</span><br></code></pre></td></tr></table></figure><p>下面，用张图展示下 Kafka 工程的各个目录以及文件：</p><p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/image-20250706221238766.png"></p><p>这里简单介绍一下主要的组件目录：</p><ul><li><p><strong>bin 目录</strong>：保存 Kafka 工具行脚本，我们熟知的 kafka-server-start 和 kafka-console-producer 等脚本都存放在这里。</p></li><li><p><strong>clients 目录</strong>：保存 Kafka 客户端代码，比如生产者和消费者的代码都在该目录下。</p></li><li><p><strong>config 目录</strong>：保存 Kafka 的配置文件，其中比较重要的配置文件是 server.properties。</p></li><li><p><strong>connect 目录</strong>：保存 Connect 组件的源代码。Kafka Connect 组件是用来实现 Kafka 与外部系统之间的实时数据传输的。</p></li><li><p><strong>core 目录</strong>：保存 Broker 端代码。Kafka 服务器端代码全部保存在该目录下。</p></li><li><p><strong>streams 目录</strong>：保存 Streams 组件的源代码。Kafka Streams 是实现 Kafka 实时流处理的组件。</p></li></ul><p>Kafka 可以支持单元测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./gradlew core:<span class="hljs-built_in">test</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./gradlew clients:<span class="hljs-built_in">test</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./gradlew connect:[submodule]:<span class="hljs-built_in">test</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./gradlew streams:<span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><p>我们主要聚焦Kafka Broker 端源代码，因此Kafka core 包的内容需要重点关注一下：</p><ul><li><p><strong>controller 包</strong>：保存了 Kafka 控制器（Controller）代码，而控制器组件是 Kafka 的核心组件，后面我们会针对这个包的代码进行详细分析。</p></li><li><p><strong>coordinator 包</strong>：保存了消费者端的 GroupCoordinator 代码和用于事务的 TransactionCoordinator 代码。对 coordinator 包进行分析，特别是对消费者端的 GroupCoordinator 代码进行分析，是弄明白 Broker 端协调者组件设计原理的关键。</p></li><li><p><strong>log 包</strong>：保存了 Kafka 最核心的日志结构代码，包括日志、日志段、索引文件等，后续会有详细介绍。另外，该包下还封装了 Log Compaction 的实现机制，是非常重要的源码包。</p></li><li><p><strong>network 包</strong>：封装了 Kafka 服务器端网络层的代码，特别是 SocketServer.scala 这个文件，是 Kafka 实现 Reactor 模式的具体操作类。</p></li><li><p><strong>server 包</strong>：顾名思义，它是 Kafka 的服务器端主代码，里面的类非常多，很多关键的 Kafka 组件都存放在这里，比如状态机、Purgatory 延时机制等。</p></li></ul><p>目前 kafka 是 java 和 scala 混合开发的，很多核心代码都是 Scala，需要有 Scala 的语言基础。</p><h1 id="4-Scala-基础"><a href="#4-Scala-基础" class="headerlink" title="4.Scala 基础"></a>4.Scala 基础</h1><h3 id="4-1-定义变量和函数"><a href="#4-1-定义变量和函数" class="headerlink" title="4.1 定义变量和函数"></a>4.1 定义变量和函数</h3><p>Scala 有两类变量：val 和 var。</p><p>val 等同于 Java 中的 final 变量，一旦被初始化，就不能再被重新赋值了。相反地，var 是非 final 变量，可以重复被赋值。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> msg = <span class="hljs-string">&quot;hello, world&quot;</span><br>msg: <span class="hljs-type">String</span> = hello, world<br><br>scala&gt; msg = <span class="hljs-string">&quot;another string&quot;</span><br>&lt;console&gt;:<span class="hljs-number">12</span>: error: reassignment to <span class="hljs-keyword">val</span><br>       msg = <span class="hljs-string">&quot;another string&quot;</span><br><br>scala&gt; <span class="hljs-keyword">var</span> a:<span class="hljs-type">Long</span> = <span class="hljs-number">1</span>L<br>a: <span class="hljs-type">Long</span> = <span class="hljs-number">1</span><br><br>scala&gt; a = <span class="hljs-number">2</span><br>a: <span class="hljs-type">Long</span> = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>函数定义：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">max</span></span>(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = &#123;<br>  <span class="hljs-keyword">if</span> (x &gt; y) x<br>  <span class="hljs-keyword">else</span> y<br>&#125;<br></code></pre></td></tr></table></figure><p>def 关键字表示这是一个函数。max 是函数名，括号中的 x 和 y 是函数输入参数，它们都是 Int 类型的值。结尾的“Int &#x3D;”组合表示 max 函数返回一个整数。</p><p>在 Scala 中，函数体具体代码块最后一行的值将被作为函数结果返回。</p><h3 id="4-2-定义元组（Tuple）"><a href="#4-2-定义元组（Tuple）" class="headerlink" title="4.2 定义元组（Tuple）"></a>4.2 定义元组（Tuple）</h3><p>元组是承载数据的容器，一旦被创建，就不能再被更改了。元组中的数据可以是不同数据类型的。定义和访问元组的方法很简单:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> a = (<span class="hljs-number">1</span>, <span class="hljs-number">2.3</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-type">List</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)) <span class="hljs-comment">// 定义一个由4个元素构成的元组，每个元素允许是不同的类型</span><br>a: (<span class="hljs-type">Int</span>, <span class="hljs-type">Double</span>, <span class="hljs-type">String</span>, <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>]) = (<span class="hljs-number">1</span>,<span class="hljs-number">2.3</span>,hello,<span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br><br>scala&gt; a._1 <span class="hljs-comment">// 访问元组的第一个元素</span><br>res0: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span><br><br>scala&gt; a._2 <span class="hljs-comment">// 访问元组的第二个元素</span><br>res1: <span class="hljs-type">Double</span> = <span class="hljs-number">2.3</span><br><br>scala&gt; a._3 <span class="hljs-comment">// 访问元组的第三个元素</span><br>res2: <span class="hljs-type">String</span> = hello<br><br>scala&gt; a._4 <span class="hljs-comment">// 访问元组的第四个元素</span><br>res3: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h3 id="4-3-循环写法"><a href="#4-3-循环写法" class="headerlink" title="4.3 循环写法"></a>4.3 循环写法</h3><p>我们常见的循环有两种写法：命令式编程方式和函数式编程方式。熟悉的是第一种，比如下面的 for 循环代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> list = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br>list: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br><br>scala&gt; <span class="hljs-keyword">for</span> (element &lt;- list) println(element)<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>第二种写法，会让代码写得异常简洁:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// dataPlaneAcceptors:ConcurrentHashMap&lt;Endpoint, Acceptor&gt;对象</span><br>dataPlaneAcceptors.asScala.values.foreach(_.initiateShutdown())<br></code></pre></td></tr></table></figure><p>这一行代码首先调用 asScala 方法，将 Java 的 ConcurrentHashMap 转换成 Scala 语言中的 concurrent.Map 对象；然后获取它保存的所有 Acceptor 线程，通过 foreach 循环，调用每个 Acceptor 对象的 initiateShutdown 方法。</p><h3 id="4-4-case-类"><a href="#4-4-case-类" class="headerlink" title="4.4 case 类"></a>4.4 case 类</h3><p>在 Scala 中，case 类与普通类是类似的，只是它具有一些非常重要的不同点。Case 类非常适合用来表示不可变数据。同时，它最有用的一个特点是，case 类自动地为所有类字段定义 Getter 方法，这样能省去很多样本代码</p><p>要编写一个类表示平面上的一个点，Java 代码大概长这个样子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> int x;<br>  <span class="hljs-keyword">private</span> int y;<br>  public <span class="hljs-type">Point</span>(int x, int y) &#123;<br>    <span class="hljs-keyword">this</span>.x = x;<br>    <span class="hljs-keyword">this</span>.y = y;<br>  &#125;<br>  <span class="hljs-comment">// setter methods......</span><br>  <span class="hljs-comment">// getter methods......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但如果用 Scala 的 case 类，只需要写一行代码就可以了：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>(<span class="hljs-params">x:<span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span></span>) <span class="hljs-comment">// 默认写法。不能修改x和y</span></span><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>(<span class="hljs-params">var x: <span class="hljs-type">Int</span>, var y: <span class="hljs-type">Int</span></span>) <span class="hljs-comment">// 支持修改x和y</span></span><br></code></pre></td></tr></table></figure><h3 id="4-5-模式匹配"><a href="#4-5-模式匹配" class="headerlink" title="4.5 模式匹配"></a>4.5 模式匹配</h3><p>和 Java 中 switch 仅仅只能比较数值和字符串相比，Scala 中的 match 要强大得多:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">describe</span></span>(x: <span class="hljs-type">Any</span>) = x <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span> =&gt; <span class="hljs-string">&quot;one&quot;</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-literal">false</span> =&gt; <span class="hljs-string">&quot;False&quot;</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hi&quot;</span> =&gt; <span class="hljs-string">&quot;hello, world!&quot;</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span> =&gt; <span class="hljs-string">&quot;the empty list&quot;</span><br>  <span class="hljs-keyword">case</span> e: <span class="hljs-type">IOException</span> =&gt; <span class="hljs-string">&quot;this is an IOException&quot;</span><br>  <span class="hljs-keyword">case</span> s: <span class="hljs-type">String</span> <span class="hljs-keyword">if</span> s.length &gt; <span class="hljs-number">10</span> =&gt; <span class="hljs-string">&quot;a long string&quot;</span><br>  <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-string">&quot;something else&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-6-Option-对象"><a href="#4-6-Option-对象" class="headerlink" title="4.6 Option 对象"></a>4.6 Option 对象</h3><p>Option 表示一个容器对象，里面可能装了值，也可能没有装任何值。由于是容器，因此一般都是这样的写法：Option[Any]。中括号里面的 Any 就是上面说到的 Any 类型，它能是任何类型。如果值存在的话，就可以使用 Some(x) 来获取值或给值赋值，否则就使用 None 来表示:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> keywords = <span class="hljs-type">Map</span>(<span class="hljs-string">&quot;scala&quot;</span> -&gt; <span class="hljs-string">&quot;option&quot;</span>, <span class="hljs-string">&quot;java&quot;</span> -&gt; <span class="hljs-string">&quot;optional&quot;</span>) <span class="hljs-comment">// 创建一个Map对象</span><br>keywords: scala.collection.immutable.<span class="hljs-type">Map</span>[<span class="hljs-type">String</span>,<span class="hljs-type">String</span>] = <span class="hljs-type">Map</span>(scala -&gt; option, java -&gt; optional)<br><br>scala&gt; keywords.get(<span class="hljs-string">&quot;java&quot;</span>) <span class="hljs-comment">// 获取key值为java的value值。由于值存在故返回Some(optional)</span><br>res24: <span class="hljs-type">Option</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">Some</span>(optional)<br><br>scala&gt; keywords.get(<span class="hljs-string">&quot;C&quot;</span>) <span class="hljs-comment">// 获取key值为C的value值。由于不存在故返回None</span><br>res23: <span class="hljs-type">Option</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">None</span><br></code></pre></td></tr></table></figure><p>Option 对象还经常与模式匹配语法一起使用，以实现不同情况下的处理逻辑:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">display</span></span>(game: <span class="hljs-type">Option</span>[<span class="hljs-type">String</span>]) = game <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">Some</span>(s) =&gt; s<br>  <span class="hljs-keyword">case</span> <span class="hljs-type">None</span> =&gt; <span class="hljs-string">&quot;unknown&quot;</span><br>&#125;<br><br>scala&gt; display(<span class="hljs-type">Some</span>(<span class="hljs-string">&quot;Heroes 3&quot;</span>))<br>res26: <span class="hljs-type">String</span> = <span class="hljs-type">Heroes</span> <span class="hljs-number">3</span><br><br>scala&gt; display(<span class="hljs-type">Some</span>(<span class="hljs-string">&quot;StarCraft&quot;</span>))<br>res27: <span class="hljs-type">String</span> = <span class="hljs-type">StarCraft</span><br><br>scala&gt; display(<span class="hljs-type">None</span>)<br>res28: <span class="hljs-type">String</span> = unknown<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>码农也要有新视角-项目管理的学习</title>
    <link href="/2025/06/29/%E7%A0%81%E5%86%9C%E4%B9%9F%E8%A6%81%E6%9C%89%E6%96%B0%E8%A7%86%E8%A7%92-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/06/29/%E7%A0%81%E5%86%9C%E4%B9%9F%E8%A6%81%E6%9C%89%E6%96%B0%E8%A7%86%E8%A7%92-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/Typora-2025-06-29-IVLKsHvF@2x.png"></p><h1 id="1-每个人都有必要学习项目管理"><a href="#1-每个人都有必要学习项目管理" class="headerlink" title="1. 每个人都有必要学习项目管理"></a>1. 每个人都有必要学习项目管理</h1><p>当今社会趋势是超级个体会越来越多，项目管理这项技能，不仅仅是项目经理才需要掌握的，而是每个独当一面的人必备的技能。</p><p>所谓<strong>独当一面</strong>，就是指是<strong>从一个人做好自己的事，到带领一群人从头到尾把事做成</strong>。学习项目管理的过程，就是掌握”使众人行“的协同能力。</p><p><strong>事实上，不管从事什么工作，学习好项目管理，拥有”使众人行“这项稀有技能，都可以在专业之外，获得更大的成长空间。</strong></p><h2 id="1-1-迁移的能力"><a href="#1-1-迁移的能力" class="headerlink" title="1.1 迁移的能力"></a>1.1 迁移的能力</h2><p>但是从实际情况却是，越是业务能手，越容易在项目管理上栽跟头，因为从单枪匹马到组队吃鸡，能力很难迁移。</p><p>比如一个项目的失败，完全可以去简单总结为”队友不给力“，”我早说这样了，没人听我的“等等。但是，说这些不能换来任何项目上的成长，反而增加了情绪上反作用力，让自身的更加独断或者动力减少。</p><p>但是其实最要做的是，从”坑“里爬出来，做好这些标记：</p><ol><li>队友不给力 -&gt; 如何调动干系人的积极性？</li><li>xxx 怎么现在才开始 -&gt; 如何对其一群人的行动步伐</li><li>我早说这样干了，没人听我的 -&gt; 遇见问题如何统一行动方案</li><li>这…不是我想要的 -&gt; 如何清晰我们的共同目标</li></ol><p>这些标记，说明了：<strong>从一个人做好自己，到带领一群人成事，中间还差十万八千里。</strong>而从一个新手到高手的方式，需要做的就是：<strong>不断跨越职责边界，带领一群人，从头到尾把事情做成。</strong></p><h2 id="1-2-职场进阶"><a href="#1-2-职场进阶" class="headerlink" title="1.2 职场进阶"></a>1.2 职场进阶</h2><p>通常职场进阶有两条路线：</p><ol><li>走个人路线，成为专家。</li><li>借助团队能力，成为管理者。</li></ol><p>成为管理者需要时机和坑位，可遇不可求。但是，是公司就会有项目，有项目协助就一定有项目管理的需求和机会。</p><p>所以职场人还有第三条路精进之路：</p><ol start="3"><li>做好自己的工作之余，具备项目管理的能力，拥有更多的晋升优势。</li></ol><p>这样会比别人更早的意识，就已经走到了很多人的前面。另一方面，这是种能力，可以抵御时间的通胀，同时还是思维和做事方式的沉淀。</p><p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/5c0557ce219c42317960f7bd0882fc14.png" alt="职场进阶"></p><h1 id="2-项目管理的误区"><a href="#2-项目管理的误区" class="headerlink" title="2. 项目管理的误区"></a>2. 项目管理的误区</h1><h2 id="2-1-误区一：凡是需躬亲"><a href="#2-1-误区一：凡是需躬亲" class="headerlink" title="2.1 误区一：凡是需躬亲"></a>2.1 误区一：凡是需躬亲</h2><blockquote><p>“跟A说了好几遍了，到现在还没做好，好不容易做完了，又出问题了，早知道这么费劲了，还不如我替TA做来的快”</p></blockquote><p>忍不住冲上去，替别人做好人家本该做好的事情。其实这对团队的发展，这种行为的效率是最低的。</p><p>其实应该是<strong>想办法影响他人去把事情做好</strong>，而成功影响的三个层次分别是:</p><ol><li>让别人做（Awareness）</li><li>有动力做（Desire）</li><li>有能力做（Ability）</li></ol><h2 id="2-2-误区二：追在别人屁股后边当监工"><a href="#2-2-误区二：追在别人屁股后边当监工" class="headerlink" title="2.2 误区二：追在别人屁股后边当监工"></a>2.2 误区二：追在别人屁股后边当监工</h2><blockquote><p>“好，我不亲历亲为，我把活全都分出去，但我总要督促大家把事情做好！我跑去问 A，做好没有，A 反馈说这事得找 B 和 C，于是我又跑去问 B 和 C……一天下来，我把各处都跑遍了，事情还是没有个进展，反倒讨了一身没趣</p></blockquote><p>其实项目管理最不应该做的，不是每天监督跟人、逐条事项，而是要<strong>明确目标、建立机制，并让机制运转起来，最终在项目组形成一种良好的秩序</strong>。</p><p>项目管理并非要让你成为监工，而是要始终依靠流程和规则来约束大家的行为。</p><p>成熟的秩序在团队中形成之后，从日常琐事中解放出来的项目经理，就可以集中精力到愿景驱动、激励团队等更高层面的工作，真正做到变“赶”为“引”。</p><h2 id="2-3-误区三：拿着锤子，看哪都是钉子"><a href="#2-3-误区三：拿着锤子，看哪都是钉子" class="headerlink" title="2.3 误区三：拿着锤子，看哪都是钉子"></a>2.3 误区三：拿着锤子，看哪都是钉子</h2><blockquote><p>“我们应该每天都开个站会沟通下进展，我们应该定期开个复盘会回顾下……对了，我们应该换个工具，电子看板比这个好用多了。”</p></blockquote><p>新官上任的项目经理，可能是因为终于得到施展的空间了，一上来就左突右攻，恨不得把十八般武艺全都套上去，结果激起了许多不必要的麻烦。开站会也好，电子看板也罢，本来都是好工具，但是如果引入不当或时机不对，会让团队产生抵触心理，起不到什么好的效果。</p><p>方法和工具固然重要，但是也要与项目中的重要干系人加强沟通，理清前因后果，多想想自己的项目现阶段到底最需要什么，这对项目管理方法的成功推进至关重要。比如：</p><ul><li>项目组中，时间、成本、质量、范围这几个因素，到底哪个更重要？哪些是允许有一定调整空间的？</li><li>各个角色目前的痛点在哪儿？哪些是最先需要解决的？</li><li>这些问题背后潜在的原因是什么？团队对于这个痛点的改进是否有真实需要？需求的迫切程度如何？</li><li>老板或项目发起人对于项目管理及本人的定位是怎样的？关于这些问题与可能的改进，你是否与其沟通过并达成了一致？</li><li>如果你打算引入新方法或工具，更适合用怎样的路径进行，自上而下地全面推广？自下而上一步一步优化？最有可能从哪个问题切入？</li></ul><p>应从项目和团队当前的真实痛点出发，找到真正解决问题的方法和步骤。</p><h2 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h2><p>专业人士走向项目管理，是从“左手习惯”到“右手习惯”的转变。其中，思维模式和行为习惯的转变，远比学会使用那些工具方法要有挑战得多。从管好自己的事，到管好别人的事，需要有意识地避免 3 个误区。</p><p>第 1 个误区是，凡事都要亲力亲为。遇到事情时，你不要自己直接去做，而是要想办法驱动他人去做好事情。在授权工作时，有三个层次，从让人知道要做，到有动力做，再到有能力做。你需要讲清楚为什么要做，为什么要现在做，获取理解及认同，激发团队的动力，同时为每个任务选择能力匹配的授权对象。</p><p>第 2 个误区是追着别人做监工。做项目管理，不是要你变成监工，而是要你带领团队明确目标，建立机制，并让这个机制运转起来，要始终依靠流程和规则来约束大家的行为。</p><p>第 3 个误区是拿着锤子看哪里都是钉子。每个项目的现有执行方式，都有它本身的背景和成因，你要与项目中的重要干系人加强沟通，理解前因后果，从项目和团队当前的真实痛点出发，找到真正解决问题的方法和步骤。</p><h1 id="3-项目管理的十大领域（PMI）"><a href="#3-项目管理的十大领域（PMI）" class="headerlink" title="3. 项目管理的十大领域（PMI）"></a>3. 项目管理的十大领域（PMI）</h1><p>项目管理的十大领域，将项目管理的工作内容划分为：整合管理、范围管理、时间管理、成本管理、质量管理、人力资源管理、沟通管理、干系人管理、风险管理和采购管理。</p><p>其中，<strong>进度、成本、质量、范围是 4 个核心领域</strong>，风险、沟通、采购、资源、干系人管理是 5 个辅助领域和 1 个整体领域，如下图所示：</p><p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/0fed5d63487e80ae207ef8df16fa5809.png" alt="项目管理的十大领域"></p><h1 id="4-项目管理的五大过程"><a href="#4-项目管理的五大过程" class="headerlink" title="4. 项目管理的五大过程"></a>4. 项目管理的五大过程</h1><h2 id="4-1-PDCA"><a href="#4-1-PDCA" class="headerlink" title="4.1 PDCA"></a>4.1 PDCA</h2><p>最早来自于质量管理领域，意思是做任何事情，都要经过<strong>规划（Plan）、执行（Do)、检查 (Check) 和行动 (Act)</strong> 这四个步骤，又称戴明环。</p><h2 id="4-2-五大过程"><a href="#4-2-五大过程" class="headerlink" title="4.2 五大过程"></a>4.2 五大过程</h2><p>PMI 遵循 PDCA 的法则，将所有的项目管理活动分成了五大过程组，分别是<strong>启动过程组、规划过程组、执行过程组、监控过程组和收尾过程组</strong>。如下图所示：</p><p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/23ae68d8952af590b25694c23ec743bc.png" alt="img"></p><h3 id="4-2-1-启动过程组"><a href="#4-2-1-启动过程组" class="headerlink" title="4.2.1 启动过程组"></a>4.2.1 启动过程组</h3><p>启动一个新项目或新阶段时，首先要建立项目章程，并且通过启动会去公开确认。</p><p>启动会的作用，就好比一个大型的推土机，是面对项目组全员，<strong>正式宣告一个新项目或新阶段的开始，公开确认项目章程，包括明晰各方干系人的期望和诉求，设定愿景目标和重要里程碑，确定责任分工和沟通机制等</strong>。</p><h3 id="4-2-2-规划过程组"><a href="#4-2-2-规划过程组" class="headerlink" title="4.2.2 规划过程组"></a>4.2.2 规划过程组</h3><p>规划过程组可以说是项目管理工作中最为繁重的一个环节了。如果说启动是要明确目标，那么，规划就是要把愿景目标转化为可落地的行动方案和工作路线。对规划过程组进行有效管理, 可以更容易地获取干系人的认可和参与。</p><ul><li>明确项目范围</li><li>确定项目的里程碑阶段目标</li><li>为项目的执行做好各项准备</li></ul><p>对于一个复杂项目来说，规划通常是一个渐进明晰的过程，近期的规划往往是最具体的，需要拆分到具体版本和工作项，而远期的规划则相对比较模糊。</p><p>随着收集和掌握的信息逐渐增多，规划也要进一步动态细化，不断更新</p><h3 id="4-2-3-执行过程组"><a href="#4-2-3-执行过程组" class="headerlink" title="4.2.3 执行过程组"></a>4.2.3 执行过程组</h3><p>这个阶段重在整合资源，推进项目落地，完成项目管理计划中确定的工作以实现项目目标。如果在启动和规划环节做好了，到了执行环节，项目经理反而会轻松一些。这就好比汽车在高速上跑起来之后，如果你设定了 100 码的定速巡航，汽车自己就会执行运转。</p><p>这时，工作更侧重于确保项目一直在正确的轨道上，确保各个环节按照规划进行，并且真正做到位。</p><h3 id="4-2-4-监控过程组"><a href="#4-2-4-监控过程组" class="headerlink" title="4.2.4 监控过程组"></a>4.2.4 监控过程组</h3><p>执行并不意味着在任何情况下都要一成不变。当外界环境或内部要求发生变化时，项目管理者也要审时度势，沉着应变，适时调整各方，以更好地实现目标。</p><h3 id="4-2-5-收尾过程组"><a href="#4-2-5-收尾过程组" class="headerlink" title="4.2.5 收尾过程组"></a>4.2.5 收尾过程组</h3><p>收尾过程组是五个过程中的最后一个，而头和尾都是最容易被忽略的。在这个阶段，你要交付项目成果，组织团队的回顾复盘，归档所有文档等组织过程资产，正式结束一个项目或阶段。</p><p>重要的事说三遍：“复盘！复盘！复盘！”不管项目成功与否，“趁热”复盘都是极为重要的一步。</p>]]></content>
    
    
    <categories>
      
      <category>项目管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>抓虫(bug)系列-概述</title>
    <link href="/2025/06/27/%E6%8A%93%E8%99%AB(bug)%E7%B3%BB%E5%88%97-%E6%A6%82%E8%BF%B0/"/>
    <url>/2025/06/27/%E6%8A%93%E8%99%AB(bug)%E7%B3%BB%E5%88%97-%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/v2-12bd050eac3400eb4f7fcaf38b3be3be_1440w.jpeg"></p><h1 id="写这个系列的初衷"><a href="#写这个系列的初衷" class="headerlink" title="写这个系列的初衷"></a>写这个系列的初衷</h1><p>抓虫这件事要比解决bug要难的多，并且本身也需要过硬的技术基础，以及广泛的实战分析经验。如果在第一时间生产上分析到bug，或在code review中敏觉发现问题，就能最程度的降低线上损失，并且在团队中树立很🐂的名气。说不定年终升职加薪上，老板就提名你了（你看，妥妥双赢的机会嘛，还不冲一下）。</p><p>这篇blog我计划是要写一个系列的，因为身为程序员，出现问题一定是无法避免的，我们的意图是减少常见的问题以及较为严重的问题，而这些问题是可以整理总结的。在初高中的时候，面对一些经常出错的题会出一个错题集，那么这个专题就是针对类似的做法，把常见或者非常见的问题收集整理，意在提高避免、发现、解决的经验。</p><p>当然，这个系列是长期的，相关的总结会囊括所有的我真实面临过的bug、常见的问题如何避免、相关大中厂生产事故过程阐述等。</p><p>由于篇幅长度以及分类的问题，我预计用4篇BLOG，分别是：</p><ol><li>抓虫系列-概述</li><li>抓虫系列-整体思路</li><li>抓虫系列-常见的问题</li><li>抓虫系列-案例收集</li></ol><h1 id="专栏传送门"><a href="#专栏传送门" class="headerlink" title="专栏传送门"></a>专栏传送门</h1><p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/v2-68dcfceda7d319203b8925abe42edf1f_1440w-20250628161458434.png"></p><ul><li><a href="">抓虫(bug)系列-概述</a>（本文）</li><li><a href="">抓虫(bug)系列-整体思路</a> (待更新)</li><li><a href="">抓虫(bug)系列-常见的问题</a> (待更新)</li><li><a href="">抓虫(bug)系列-案例收集</a>(待更新)</li></ul><h1 id="Bug与它的”时空“"><a href="#Bug与它的”时空“" class="headerlink" title="Bug与它的”时空“"></a>Bug与它的”时空“</h1><p>1947 年，哈佛大学的计算机哈佛二代（Harvard Mark II）突然停止了运行，程序员在电路板编号为 70 的中继器触点旁发现了一只飞蛾。然后把飞蛾贴在了计算机维护日志上，并写下了首个发现 Bug 的实际案例。程序错误从此被称作 Bug。</p><p>回想下，在编程路上你遇到得最多的 Bug 是？我的感受是，经常被测试和产品经理要求修改和返工的 Bug。这类的Bug其实属于对需求理解的偏差，我并不将其归纳为真正的技术Bug。</p><p>技术性的Bug可以分很多维度，我习惯从Bug出现的”时空”特征角度来分类，可划分如下两类：</p><ul><li>空间：环境过敏</li><li>时间：周期规律</li></ul><h2 id="空间属性（环境过敏）"><a href="#空间属性（环境过敏）" class="headerlink" title="空间属性（环境过敏）"></a>空间属性（环境过敏）</h2><p>环境，即运行程序的空间及依赖。</p><p>运行程序的环境是很复杂的，而且一般没那么可靠，总是会出现这些哪些的问题。</p><p>我曾经部署一个分布式系统，从一开始能感知个别系统的异常逐渐演变成大面积的报警和业务异常。而原因却是个别服务器的磁盘故障，导致写日志阻塞，进程挂起，然后引发调用链路上的连锁雪崩效应。</p><p>这就是当时程序编写的时候缺乏对环境问题的考虑，引发故障。人有时候换了环境，会产生一些从生理到心理的过敏反应，程序依然。运行程序发生改变，程序就出现异常的现象，就可以称之为”程序过敏反应“。</p><h3 id="过敏的对应之道"><a href="#过敏的对应之道" class="headerlink" title="过敏的对应之道"></a>过敏的对应之道</h3><p>对应环境的过敏，自然要<strong>了解环境</strong>开始。</p><p>不同的程序部署和运行的环境千差万别，有的受控有的不受控。比如，服务器运行的环境，一般都是在数据中心(IDC)机房的内网中，相对受控；而客户端运行的环境是在用户的设备上，存在不同品牌、不同操作系统、不同浏览器等等，多种多样，不可控。</p><p>环境那么复杂。我们要了解到何种程度呢？至少要关心到程序运行直接关联的那一层环境。这样理解，以后端Java程序为例：Java是运行在JVM中，那么JVM提供的运行时配置和特性就是必须关心的一层环境了。而JVM可能是运行在Linux系统或者Docker这样的虚拟化容器中，那么Linux或者Docker者一层，理论上关心程度就没太多要求了（当然现在Spring为了支持云原生，可以直接编译Java程序为机器码，那么相对就要了解Linux和Docker这一层了）</p><p>那么前文案例中的磁盘故障，已经到了硬件的层面，这个环境层次比操作系统还更低一层。虽说故障的根源是磁盘故障，但直接连接程序运行的那一层，其实是日志库依赖的 I&#x2F;O 特性，这才是我们团队应该关心、但实际却被忽略掉的部分。</p><p>同理，现今从互联网到移动互联网时代，几乎所有的程序系统都和网络有关，所以网络环境也必须是你关心的。</p><p>最后收集信息页至关重要，不仅仅局限于相关依赖环境的配置和参数，也包含用户输入的数据。真实情况下确实存在：同样的环境只针对个别用户输入才发生异常过敏反应。</p><ul><li>直接依赖的第一层环境</li><li>磁盘</li><li>网络</li><li>收集信息</li></ul><h2 id="时间属性（周期与非规律）"><a href="#时间属性（周期与非规律）" class="headerlink" title="时间属性（周期与非规律）"></a>时间属性（周期与非规律）</h2><p>下面我们在再来看Bug的<strong>时间维度</strong>特征。Bug有了时间特征，那么就会变成一个概率问题，他会出现如下特征：</p><h3 id="周期特点"><a href="#周期特点" class="headerlink" title="周期特点"></a>周期特点</h3><p>即一定频率出现Bug的特征</p><p>这类Bug因为会周期性地出现，相对还是容易捕获和解决的。此类问题典型特征是资源泄露问题。比如Java程序员不陌生的OutOfMemory错误，就是属于内存泄漏问题，而且一定会周期地出现。</p><p>好多年前，我才刚参加工作不久，就碰到一个周期性出现的Bug。但它的特殊之处在于，出现Bug的程序已经稳定运行了十多年，突然某天开始崩溃。而程序的原作者，早已经不知去处。</p><p>一开始组内经验老到的高工，认为这是一个意外事件，毕竟这个程序已经稳定的运行了十来之久，我们检查了编译后的二进制文件，拿到了生产的内存dump日志，最终像福尔摩斯一样发现了最终问题，因为程序使用Ehcache做缓存，这个框架允许传入一个对象直接缓存，它的内部类似一个线程安全的HashMap，需要重写HashCode和Equals方法，而新人使用的时候只重写了Equals方法，由于每次网络传输的对象都是新的对象，HashCode都是不一样的，这样长时间就导致Ehcahe爆满导致频繁FullGC最终程序崩溃。</p><p>周期性的 Bug，虽然乍一看很难解决的样子，但它总会重复出现，就像可以重新倒带的 “案发现场”，找到真凶也就简单了。</p><p>其实主要麻烦的是那种这次出现了，但不知道下次会在什么时候出现的 Bug。</p><h3 id="非规律性"><a href="#非规律性" class="headerlink" title="非规律性"></a>非规律性</h3><p>没有规律的Bug才是让人抓狂的。</p><p>曾经我接手过一个系统，是一个典型的生产者、消费者模型系统。系统接过来就发现一个比较明显的性能瓶颈问题，生产者的数据源来自数据库，生产者按规则提取数据，经过系统产生一系列的转换渲染后发送到多个外部系统。这里的瓶颈就在数据库上，生产能力不足，从而导致消费者饥饿。</p><p>问题比较明显，我们先优化 SQL，但效果不佳，遂改造设计实现，在数据库和系统之间增加一个内存缓冲区从而缓解了数据库的负载压力。缓冲区的效果，类似大河之上的堤坝，旱时积水，涝时泄洪。引入缓冲区后，生产者的生产能力得到了有效保障，生产能力高效且稳定。</p><p>本以为至此解决了该系统的瓶颈问题，但在生产环境运行了一段时间后，系统表现为速度时快时慢，这时真正的 Bug 才显形了。</p><p>这个系统有个特点，就是 I&#x2F;O 密集型。于是我把目光锁定在了消费者与外部系统的 I&#x2F;O 通信上。既然锁定了怀疑区域，接下来就该用证据来证明，并给出合理的解释原因了。</p><p>解决办法是增加了数据压缩功能，以牺牲 CPU 换取 I&#x2F;O。增加了压缩功能重新上线后，问题却依然存在，系统性能仍然时不时地急剧降低，而且这个时不时很没有时间规律，但关联上了一个 “嫌疑犯”：它的出现和大报文数据有关，这样复现起来就容易多了。I&#x2F;O 瓶颈的怀疑被证伪后，只好对程序执行路径增加了大量跟踪调试诊断代码，包含了每个步骤的时间度量。</p><p>在完整的程序执行路径中，每个步骤的代码块的执行时间独立求和结果仅有几十毫秒，最高也就在一百毫秒左右，但多线程执行该路径的汇总平均时间达到了 4.5 秒，这比我预期值整整高了两个量级。通过这两个时间度量的巨大差异，我意识到线程执行该代码路径的时间其实并不长，但花在等待 CPU 调度的时间似乎很长。那么是 CPU 达到了瓶颈么？通过观察服务器的 CPU 消耗，平均负载却不高。</p><p>只好再次分析代码实现机制，终于在数据转换渲染子程序中找到了一段可疑的代码实现。为了验证疑点，再次做了一下实验测试：用 150k 的线上数据报文作为该程序输入，单线程运行了下，发现耗时居然接近 50 毫秒，我意识到这可能是整个代码路径中最耗时的一个代码片段。</p><p>这个子程序来自上上代程序员的遗留代码，包含一些稀奇古怪且复杂的渲染逻辑判断和业务规则，很久没人动过了。仔细分析了其中实现，基本就是大量的文本匹配和替换，还包含一些加密、Hash 操作，这明显是一个 CPU 密集型的函数啊。</p><p>分析清楚后，通过简单优化该子程序的算法，从近 50 毫秒降低到 3、4 毫秒后，整个代码路径的线程平均执行时间下降到 100 毫秒左右。收益是明显的，该子程序函数性能得到了 10 倍的提高。</p><h4 id="称得上神出鬼没的-Bug-：海森堡-Bug（Heisenbug）"><a href="#称得上神出鬼没的-Bug-：海森堡-Bug（Heisenbug）" class="headerlink" title="称得上神出鬼没的 Bug ：海森堡 Bug（Heisenbug）"></a>称得上神出鬼没的 Bug ：海森堡 Bug（Heisenbug）</h4><p>这个 Bug 的名字来自量子物理学的 “海森堡不确定性原理”，其认为观测者观测粒子的行为会最终影响观测结果。借用这个效应来指代那些无法进行观测的 Bug，也就是在生产环境下不经意出现，费尽心力却无法重现的 Bug。</p><p>关于海森堡 Bug，一方面很少有机会碰到，另一方面随着你编程经验的增加，掌握了很多编码的优化实践方法，也会大大降低撞上海森堡 Bug 的几率。综上所述，每一个 Bug 都是具体的，每一个具体的 Bug 都有具体的解法。但所有 Bug 的解决之道只有两类：事后和事前。</p><p>事后，就是指 Bug 出现后容易捕捉现场并定位解决的，比如第一类周期特点的 Bug。但对于没有明显重现规律，甚至神出鬼没的海森堡 Bug，靠抓现场重现的事后方法就比较困难了。针对这类 Bug，更通用和有效的方法就是在事前预防与埋伏。</p><h1 id="Bug的反复横跳"><a href="#Bug的反复横跳" class="headerlink" title="Bug的反复横跳"></a>Bug的反复横跳</h1><p>其实除了上文说的Bug 除了时间和空间两种属性，还有一个特点是跟程序员直接相关的。在编程的路上，想必也曾犯过一些形态各异、但本质重复的错误，导致一些 Bug 总是以不同的形态反复出现。</p><p>其实不妨反思一下：为什么你总是有写出的Bug的程序，并且还会重复出现？</p><h2 id="1-重蹈覆辙"><a href="#1-重蹈覆辙" class="headerlink" title="1. 重蹈覆辙"></a>1. 重蹈覆辙</h2><p>重蹈覆辙的错误，老实说我曾经经历过不只一次。</p><p>也许每次的形态可能有差异，但是其本质是类似的。想要写出没有Bug的程序是不可能的，程序员会收到自身水平的局限。而我所经历的重蹈覆辙的错误，总结下来有以下三类</p><h3 id="1-1-粗心大意"><a href="#1-1-粗心大意" class="headerlink" title="1.1 粗心大意"></a>1.1 粗心大意</h3><p>人人都会粗心大意的错误，因为就是这个”人“的系统本身的固有缺陷之一。所以，作为人的程序员一定会犯一些非常低级、因为粗心大意导致的Bug。</p><p>就比如写文章、写blog都会有错别字，都是无法避免的存在。</p><p>而程序中也有类似这种错别字类型的低级错误，比如条件 <code>if</code>后面没有大括号导致的语义变化，<code>=</code> 、<code>==</code>和 <code>===</code>的数量差别，<code>++</code>和<code>--</code>的位置，甚至<code>;</code> 的有无在某些变成语言中带来的语义差别。</p><p>但当我们验证自己的文章时，我们知道想表达的东西是什么。因为我们预期这些含义都存在，所以很容易忽略掉某些感官（视觉）表达上的缺失。我们眼睛看到的，在与我们脑子里的印象交战。这，便是我们对自己的错误视而不见的原因。</p><p>写程序时，我们是在进行一项高级的复杂任务：将复杂的需求或产品逻辑翻译为程序逻辑，并且还要补充上程序固有的非业务类控制逻辑。因而，一旦我们完成了程序，再来复审写好的代码，这时我们预期的逻辑含义都预先存在于脑中，同样也就容易忽略掉某些视觉感官表达上的问题。</p><p>从进化角度看，粗心写错别字，还看不出来，不是因为我们太笨，而恰恰还是进化上的权衡优化选择。</p><h3 id="1-2-认知偏差"><a href="#1-2-认知偏差" class="headerlink" title="1.2 认知偏差"></a>1.2 认知偏差</h3><p>认知偏差，是重蹈覆辙类错误的最大来源。</p><p>曾经，我就对 Java 类库中的线程 API 产生过认知偏差，导致反复出现问题。Java 自带线程池有三个重要参数：核心线程数（core）、最大线程数（max）和队列长度（queues）。我曾想当然地以为当核心线程数（core）不够了，就会继续创建线程达到最大线程数（max），此时如果还有任务需要处理但已经没有线程了就会放进队列等待。</p><p>但实际却不是这样工作的，类库的实现是核心线程（core）满了就会进队列（queues）等待，直到队列也满了再创建新线程直至达到最大线程数（max）的限制。这类认知偏差曾带来线上系统的偶然性异常故障，然后还怎么都找不到原因。因为这进入了我的认知盲区，我以为的和真正的现象之间的差异一度让我困惑不解。</p><h3 id="1-3-熵增问题"><a href="#1-3-熵增问题" class="headerlink" title="1.3 熵增问题"></a>1.3 熵增问题</h3><p>熵增，是借用了物理热力学的比喻，表达更复杂混乱的现象；程序规模变大，复杂度变高之后，再去修改程序或添加功能就更容易引发未知的 Bug。</p><p>我们不断进行架构升级的本质，就在于随着业务和场景功能的增加，去控制住程序系统整体 “熵” 的增加。而复杂且耦合度高（熵很高）的系统，正是容易滋生 Bug 的温床。</p><h2 id="2-吸取教训"><a href="#2-吸取教训" class="headerlink" title="2. 吸取教训"></a>2. 吸取教训</h2><p>为了避免重蹈覆辙，我们有什么办法来吸取曾经犯错的教训么？</p><h3 id="2-1-优化方法"><a href="#2-1-优化方法" class="headerlink" title="2.1 优化方法"></a>2.1 优化方法</h3><p>粗心大意，可以通过开发规范、代码风格、流程约束，代码评审和工具检查等工程手段来加以避免。甚至相对写错别字，代码更进一步，通过补充单元测试在运行时做一个正确性后验，反过来去发现这类我们视而不见的低级错误。</p><p>认知偏差，一般没什么太好的自我发现机制，但可以依赖团队和技术手段来纠偏。每次掉坑里爬出来后的经验教训总结和团队内部分享，另外就是像一些静态代码扫描工具也提供了内置的优化实践，通过它们的提示来发现与你的认知产生碰撞纠偏。</p><p>熵增问题，业界不断迭代更新流行的架构模式就是在解决这个问题。比如，微服务架构相对曾经的单体应用架构模式，就是通过增加开发协作，部署测试和运维上的复杂度来换取系统开发的敏捷性。</p><p>在协作方式、部署运维等方面付出的代价都可以通过提升自动化水平来降低成本，但只有编程活动是没法自动化的，依赖程序员来完成，而每个程序员对复杂度的驾驭能力是有不同上限的。</p><p>而熵增问题若不及时重构优化，最后可能会付出巨大的代价。</p><h3 id="2-2-塑造环境"><a href="#2-2-塑造环境" class="headerlink" title="2.2 塑造环境"></a>2.2 塑造环境</h3><p>为了修正真正的错误，而不是头痛医头、脚痛医脚，我们需要更深刻地认识问题的本质，再来开出 “处方单”。</p><p>我们看过的韩国电影或电视剧中，职场上后辈对前辈、下级对上级的态度，就能感知到韩国文化相比美国所崇尚的自由精神所表现出来的权力距离是特别远的。因而造成了大韩航空未被纠正的人为小错误比例更高，最终的影响是空难率也更高，而空难就是航空界的终极系统故障，而且结果不可挽回。</p><p>那就是：需要建立和维护有利于程序员及时暴露并修正错误，挑战权威和主动改善系统的低权力距离文化氛围，这其实就是推崇扁平化管理和 “工程师文化” 的关键所在。</p><p>一旦系统出了故障非技术背景的管理者通常喜欢用流程、制度甚至价值观来应对问题，而技术背景的管理者则喜欢从技术本身的角度去解决当下的问题。我觉着两者需要结合，站在更高的维度去考虑问题：规则、流程或评价体系的制定所造成的文化氛围，对于错误是否以及何时被暴露，如何被修正有着决定性的影响。</p><p><strong>人固有缺陷，程序固有 Bug；吸取教训避免重蹈覆辙，除了不断提升方法，也要创造环境。</strong></p>]]></content>
    
    
    <categories>
      
      <category>抓虫专栏</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深入理解kafka-核心技术与实战篇【干的要命系列】（二）</title>
    <link href="/2025/06/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3kafka-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E7%AF%87%E3%80%90%E5%B9%B2%E7%9A%84%E8%A6%81%E5%91%BD%E7%B3%BB%E5%88%97%E3%80%91%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2025/06/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3kafka-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E7%AF%87%E3%80%90%E5%B9%B2%E7%9A%84%E8%A6%81%E5%91%BD%E7%B3%BB%E5%88%97%E3%80%91%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/image-20250619201202850.png"></p><p>书接上文 <a href="https://blog.liuailin.top/2025/06/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3kafka-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E7%AF%87%E3%80%90%E5%B9%B2%E7%9A%84%E8%A6%81%E5%91%BD%E7%B3%BB%E5%88%97%E3%80%91%EF%BC%88%E4%B8%80%EF%BC%89/">深入理解kafka-核心技术与实战篇【干的要命系列】（一）</a>，虽迟但到😏</p><p>学习路线及大纲：</p><p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/image-20250619191803946.png"></p><h1 id="5-深入Kafka原理"><a href="#5-深入Kafka原理" class="headerlink" title="5. 深入Kafka原理"></a>5. 深入Kafka原理</h1><h2 id="5-1-Kafka的副本机制"><a href="#5-1-Kafka的副本机制" class="headerlink" title="5.1 Kafka的副本机制"></a>5.1 Kafka的副本机制</h2><p>所谓的副本机制，可以称之为备份机制，他有以下各种好处：</p><ol><li>提供数据的冗余。即使系统的部分失效，系统仍然可以运转。</li><li>提供高伸缩性。支持横向扩展，能通过增加机器的方式提升读性能，进而太高读操作的吞吐量。</li><li>改善数据局限性。将数据放入与用户地理位置相近的地方，从而降低系统延迟</li></ol><h3 id="5-1-1-副本定义"><a href="#5-1-1-副本定义" class="headerlink" title="5.1.1 副本定义"></a>5.1.1 副本定义</h3><p>所谓副本(replica)，本质就是一个只能追加写消息的提交日志。从而能够应对部分Broker宕机带来的数据不可用。</p><p>在实际生产环境中，每台Broker都可能保存各个主题下不同分区的不同副本，因此单个Broker上存在成百上千的副本很正常。</p><p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/image-20250621102743962.png" alt="image-20250621102743962"></p><h3 id="5-1-2-副本角色"><a href="#5-1-2-副本角色" class="headerlink" title="5.1.2 副本角色"></a>5.1.2 副本角色</h3><p>分区下有多个副本，这些副本内容要如何保持一致呢？Kafka采用**基于领导者(Leader-base)**的副本机制，副本分为Leader和Follower两种角色，他们是这样分工的：领导者可以读写，但是追随者不提供服务。</p><p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/381eda4b56991d52727934be7c7e6ec2.jpg" alt="img"></p><h3 id="5-1-3-In-sync-Replicas-ISR"><a href="#5-1-3-In-sync-Replicas-ISR" class="headerlink" title="5.1.3 In-sync Replicas(ISR)"></a>5.1.3 In-sync Replicas(ISR)</h3><p>Kafka 引入了 In-sync Replicas，也就是所谓的 ISR 副本集合。ISR 中的副本都是与 Leader 同步的副本，相反，不在 ISR 中的追随者副本就被认为是与 Leader 不同步的。</p><p>追随者定时异步拉取领导者的数据，会有不能实时同步的风险，Kafka对同步有自己的定义标准， Broker 端参数 replica.lag.time.max.ms 参数值，这个参数的含义是 Follower 副本能够落后 Leader 副本的最长时间间隔，当前默认值是 10 秒。这就是说，只要一个 Follower 副本落后 Leader 副本的时间不连续超过 10 秒，那么 Kafka 就认为该 Follower 副本与 Leader 是同步的，即使此时 Follower 副本中保存的消息明显少于 Leader 副本中的消息。</p><h3 id="5-1-4-Unclean-领导者选举"><a href="#5-1-4-Unclean-领导者选举" class="headerlink" title="5.1.4 Unclean 领导者选举"></a>5.1.4 Unclean 领导者选举</h3><p>Kafka 把所有不在 ISR 中的存活副本都称为非同步副本。通常来说，非同步副本落后 Leader 太多，因此，如果选择这些副本作为新 Leader，就可能出现数据的丢失。毕竟，这些副本中保存的消息远远落后于老 Leader 中的消息。在 Kafka 中，选举这种副本的过程称为 Unclean 领导者选举。Broker 端参数 unclean.leader.election.enable 控制是否允许 Unclean 领导者选举。</p><p>其实这种方式是提高了系统的可用性，但是降低数据的一致性，CAP理论的又一个案例！</p><h2 id="5-2-处理请求"><a href="#5-2-处理请求" class="headerlink" title="5.2 处理请求"></a>5.2 处理请求</h2><p>之前说过Kafka的所有请求都是TCP网络以Socket的方式进行通讯的。</p><h4 id="处理请求的两种常见方式："><a href="#处理请求的两种常见方式：" class="headerlink" title="处理请求的两种常见方式："></a>处理请求的两种常见方式：</h4><ol><li>顺序处理请求。写对应的伪代码，大概是这个样子的：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> accept(connection);<br>    handle(request);<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式比较简单，但是有个致命的缺点就是，吞吐量太差。只能顺序处理每个请求，每个请求都是one-by-one。</p><ol start="2"><li>每个请求使用单独线程处理</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    Request = request = accept(connection);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>      handle(request);<br>    );<br>    thread.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式完全就是异步的，但是缺陷也很明显，每次都是创建线程，在某些场景下会压垮整个服务。</p><h3 id="那么Kafka是怎么处理请求的呢？"><a href="#那么Kafka是怎么处理请求的呢？" class="headerlink" title="那么Kafka是怎么处理请求的呢？"></a>那么Kafka是怎么处理请求的呢？</h3><p>答案是使用Reactor模式，Reactor模式是事件驱动模式架构的一种实现方式，特变适合应用于处理多个客户端并发向服务器端发送请求的场景。</p><p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/5bf8e3e8d35d1ac62yydb092700b683c.jpg"></p><p>kafka类似画一张图的话：</p><p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/b3yy7c6ca1c6244f3f9d2268209a9081.jpg"></p><p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/41e0a69ed649f9c5yyea390edcd79a95.jpg"></p><p>当网络线程拿到请求后，不是自己处理，而是将请求放到一个共享队列中。Broker端还有一个IO线程池，负责从该队列中取出请求，执行真正的处理。如果是produce生产消息，则将消息写入底层磁盘日志，如果是fetch请求，则从磁盘或者页缓存中读取消息。</p><p>图中有一个叫 Purgatory 的组件，这是 Kafka 中著名的“炼狱”组件。它是用来缓存延时请求（Delayed Request）的。所谓延时请求，就是那些一时未满足条件不能立刻处理的请求。比如设置了 acks&#x3D;all 的 PRODUCE 请求，一旦设置了 acks&#x3D;all，那么该请求就必须等待 ISR 中所有副本都接收了消息后才能返回，此时处理该请求的 IO 线程就必须等待其他 Broker 的写入结果。当请求不能立刻处理时，它就会暂存在 Purgatory 中。稍后一旦满足了完成条件，IO 线程会继续处理该请求，并将 Response 放入对应网络线程的响应队列中。</p><h2 id="5-3-消费者重平衡流程解析"><a href="#5-3-消费者重平衡流程解析" class="headerlink" title="5.3 消费者重平衡流程解析"></a>5.3 消费者重平衡流程解析</h2><p>重平衡要用到KafkaBroker端的Coordinator组件，在Coordinator的帮助下完成整个消费组的分区重分配。</p><h3 id="触发和通知"><a href="#触发和通知" class="headerlink" title="触发和通知"></a>触发和通知</h3><p>三个触发条件：</p><ol><li>组成员数量发生了改变</li><li>订阅主题数量发生了改变</li><li>订阅主题分区数发生了改变</li></ol><p>在实际生成总，因为1条件发生的重平衡是最常见的。也就是说，每次消费组启动的时候，必然会导致重平衡。</p><p>那么重平衡是如何通知到其他消费实例的呢？答案是：考消费者端的心跳线程（HeartBeat Thread）。</p><h3 id="消费者组状态机"><a href="#消费者组状态机" class="headerlink" title="消费者组状态机"></a>消费者组状态机</h3><p>重平衡一旦开启，Broker端的协同者组件就要开始工作，主要是控制消费者组的状态流转。Kafka设计了一套消费者状态机，来帮助协调者完成整个重平衡流程。</p><p>目前定义了5种状态，他们分别是：Empty、Dead、PreparingBalance、CompletingRebalance和Stable。</p><table><thead><tr><th>状态</th><th>含义</th></tr></thead><tbody><tr><td>Empty</td><td>组内没有任何成员，但是消费者组可能存在已提交的位移数据，而且这些位移尚未过期</td></tr><tr><td>Dead</td><td>同样是组内没有任何成员，但组的元数据信息已经在协调者端被移除。协调者组件保存着当前向它注册过的所有组信息，所谓元数据信息就类似于这个注册信息</td></tr><tr><td>PreparingRebalance</td><td>消费者准备开启重平衡。此时所有成员都要重新请求加入消费者组。</td></tr><tr><td>CompletingRebalance</td><td>消费者组下所有成员已经加入，各个成员正在等待分配方案。该状态在老一点的版本中被称为AwaitingSync，它和CompletingRebalance是等价的。</td></tr><tr><td>Stable</td><td>消费者组的稳定状态。该状态表明重平衡已经完成，组内各成员能工正常消费数据了。</td></tr></tbody></table><p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/image-20250624235803098.png"></p><h3 id="消费者端重平衡流程"><a href="#消费者端重平衡流程" class="headerlink" title="消费者端重平衡流程"></a>消费者端重平衡流程</h3><p>在消费者端，重平衡分为两个步骤：分别是加入组和等待领导者消费者（Leader Consumer）分配方案。这两个步骤分别对应两类特定的请求：JoinGroup 请求和 SyncGroup 请求。</p><p>当组内成员加入组时，它会向协调者发送 JoinGroup 请求。在该请求中，每个成员都要将自己订阅的主题上报，这样协调者就能收集到所有成员的订阅信息。一旦收集了全部成员的 JoinGroup 请求后，协调者会从这些成员中选择一个担任这个消费者组的领导者。<img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/image-20250625000321967.png" alt="JoinGroup流程"></p><p>JoinGroup 请求的主要作用是将组成员订阅信息发送给领导者消费者，待领导者制定好分配方案后，重平衡流程进入到 SyncGroup 请求阶段。</p><p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/image-20250625000424444.png" alt="SyncGroup流程"></p><p>SyncGroup 请求的主要目的，就是让协调者把领导者制定的分配方案下发给各个组内成员。当所有成员都成功接收到分配方案后，消费者组进入到 Stable 状态，即开始正常的消费工作。</p><h3 id="Broker端重平衡场景解析"><a href="#Broker端重平衡场景解析" class="headerlink" title="Broker端重平衡场景解析"></a>Broker端重平衡场景解析</h3><p>分以下几个场景。分别是新成员加入组、组成员离开组、组成员提交位移。</p><h4 id="场景一：新成员入组"><a href="#场景一：新成员入组" class="headerlink" title="场景一：新成员入组"></a>场景一：新成员入组</h4><p>新成员入组是指在组状态为Stable状态后，有新的成员加入。如果是全新启动一个消费者组，Kafka是有一些自己的小优化的，流程上会有些不同。</p><p>当协调者JoinGroup请求后，他会通过心跳请求响应的方式通知组内现有成员，强制开一一轮重平衡。</p><h4 id="场景二：组成员主动离组"><a href="#场景二：组成员主动离组" class="headerlink" title="场景二：组成员主动离组"></a>场景二：组成员主动离组</h4><p>在消费者实例所在的线程或者进程调用close方法主动通知协调者它要退出或者调用close()方法主动通知协调者它退出，</p><h4 id="场景三：组成员崩溃离组"><a href="#场景三：组成员崩溃离组" class="headerlink" title="场景三：组成员崩溃离组"></a>场景三：组成员崩溃离组</h4><p>崩溃离组是指消费者实例出现严重故障，突然宕机导致的离组。它和主动离组是有区别的，因为后者是主动发起的离组，协调者能马上感知并处理。但崩溃离组是被动的，协调者通常需要等待一段时间才能感知到，这段时间一般是由消费者端参数 session.timeout.ms 控制的。</p><h4 id="场景四：重平衡时协调者对组内成员提交位移的处理"><a href="#场景四：重平衡时协调者对组内成员提交位移的处理" class="headerlink" title="场景四：重平衡时协调者对组内成员提交位移的处理"></a>场景四：重平衡时协调者对组内成员提交位移的处理</h4><p>当重平衡开启时，协调者会给予成员一段缓冲时间，要求每个成员必须在这段时间内快速地上报自己的位移信息，然后再开启正常的 JoinGroup&#x2F;SyncGroup 请求发送</p><h2 id="5-4-Kafka的控制器组件"><a href="#5-4-Kafka的控制器组件" class="headerlink" title="5.4 Kafka的控制器组件"></a>5.4 Kafka的控制器组件</h2><p>控制器组件是Kafka的核心组件。它的作用是在Zookeeper的帮助下管理和协调整个Kafka集群。</p><p>集群中的任意一台Broker都能充当控制器的角色。但是，在实际运行中，只能有一个Broker称为控制器，行使其管理和协调的职责。</p><h3 id="控制器是做什么的？"><a href="#控制器是做什么的？" class="headerlink" title="控制器是做什么的？"></a>控制器是做什么的？</h3><ol><li><p>主题管理</p></li><li><p>分区重分配</p></li><li><p>PreFerred领导者选举</p></li><li><p>集群成员管理（新增Broker、Broker主动关闭、Broker宕机）</p></li></ol><h4 id="控制器保存数据"><a href="#控制器保存数据" class="headerlink" title="控制器保存数据"></a>控制器保存数据</h4><p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/image-20250625181312064.png"></p><h2 id="5-5-高水平和Leader-Epoch"><a href="#5-5-高水平和Leader-Epoch" class="headerlink" title="5.5 高水平和Leader Epoch"></a>5.5 高水平和Leader Epoch</h2><p>Kafka的世界中，水位不是时间戳，更与时间无关。它是和位置绑定的，具体来说，他是用消息位移来表征的。</p><h3 id="高水位线的作用"><a href="#高水位线的作用" class="headerlink" title="高水位线的作用"></a>高水位线的作用</h3><p>主要的作用有两个：</p><ol><li>定义消息的可见性，即用来标识分区下的哪些消息是可以被消费的</li><li>帮助Kafka完成副本同步</li></ol><p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/image-20250625181858803.png"></p><p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/image-20250625185114542.png"></p><p>Broker 0 上保存了某分区的 Leader 副本和所有 Follower 副本的 LEO 值，而 Broker 1 上仅仅保存了该分区的某个 Follower 副本。Kafka 把 Broker 0 上保存的这些 Follower 副本又称为远程副本（Remote Replica）。Kafka 副本机制在运行过程中，会更新 Broker 1 上 Follower 副本的高水位和 LEO 值，同时也会更新 Broker 0 上 Leader 副本的高水位和 LEO 以及所有远程副本的 LEO。</p><h3 id="Leader-Epoch-登场"><a href="#Leader-Epoch-登场" class="headerlink" title="Leader Epoch 登场"></a>Leader Epoch 登场</h3><p>Leader 副本高水位更新和 Follower 副本高水位更新在时间上是存在错配的。这种错配是很多“数据丢失”或“数据不一致”问题的根源。基于此，社区在 0.11 版本正式引入了 Leader Epoch 概念，来规避因高水位更新错配导致的各种不一致问题。</p><p>所谓 Leader Epoch，我们大致可以认为是 Leader 版本。它由两部分数据组成。</p><ol><li>Epoch。一个单调增加的版本号。每当副本领导权发生变更时，都会增加该版本号。小版本号的 Leader 被认为是过期 Leader，不能再行使 Leader 权力。</li><li>起始位移（Start Offset）。Leader 副本在该 Epoch 值上写入的首条消息的位移。</li></ol><p>我们来看一个实际的例子，它展示的是 Leader Epoch 是如何防止数据丢失的：</p><p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/image-20250625190934160.png"></p><p>Leader Epoch 机制来规避这种数据丢失：</p><p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/image-20250625191152737.png"></p><p>副本 A 宕机了，B 成为 Leader。同样地，当 A 重启回来后，执行与 B 相同的逻辑判断，发现也不用执行日志截断，至此位移值为 1 的那条消息在两个副本中均得到保留。后面当生产者程序向 B 写入新消息时，副本 B 所在的 Broker 缓存中，会生成新的 Leader Epoch 条目：[Epoch&#x3D;1, Offset&#x3D;2]。之后，副本 B 会使用这个条目帮助判断后续是否执行日志截断操作。这样，通过 Leader Epoch 机制，Kafka 完美地规避了这种数据丢失场景。</p><h1 id="6-Kafka-管理与监控"><a href="#6-Kafka-管理与监控" class="headerlink" title="6. Kafka 管理与监控"></a>6. Kafka 管理与监控</h1><p>TODO: 暂时不用，后续补充</p><h1 id="7-高级Kafka应用之流式处理"><a href="#7-高级Kafka应用之流式处理" class="headerlink" title="7. 高级Kafka应用之流式处理"></a>7. 高级Kafka应用之流式处理</h1><h2 id="6-1-Kafka-Streams-是什么？"><a href="#6-1-Kafka-Streams-是什么？" class="headerlink" title="6.1 Kafka Streams 是什么？"></a>6.1 Kafka Streams 是什么？</h2><p>Kafka Streams 是一个 <strong>Java 库</strong>（也支持 Scala），用于构建 <strong>分布式、容错、可扩展的流式应用</strong>，你只需要在你的 Java 应用中引入依赖，就可以：</p><ul><li>消费 Kafka 的消息（支持高吞吐量）</li><li>做窗口计算、聚合、join、分组、过滤等操作</li><li>处理完后再写回 Kafka（或其它 sink）</li></ul><p>在 Kafka Streams 中，流处理逻辑是用拓扑来表征的。一个拓扑结构本质上是一个有向无环图（DAG），它由多个处理节点（Node）和连接节点的多条边组成，如下图所示：</p><p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/image-20250625193158995.png"></p><p>图上的节点也称之为处理单元或Processor，它封装了具体的事件处理逻辑。Processor在其他平台也被称为操作算子。常见的操作算子包括转化(map)、过滤(filter)、链接(join)和聚合(aggregation)等。</p><p>大体上，Kafka Streams 开放了两大类 API 供你定义 Processor 逻辑。</p><p>第 1 类就是 DSL，它是声明式的函数式 API，使用起来感觉和 SQL 类似，你不用操心它的底层是怎么实现的，你只需要调用特定的 API 告诉 Kafka Streams 你要做什么即可。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">movies.filter((title, movie) -&gt; movie.getGenre().equals(<span class="hljs-string">&quot;动作片&quot;</span>)).xxx()...<br></code></pre></td></tr></table></figure><p>第 2 类则是命令式的低阶 API，称为 Processor API。比起 DSL，这组 API 提供的实现方式更加灵活。你可以编写自定义的算子来实现一些 DSL 天然没有提供的处理逻辑。事实上，DSL 底层也是用 Processor API 实现的。</p><p>不论是用哪组 API 实现，所有流处理应用本质上都可以分为两类：有状态的（Stateful）应用和无状态的（Stateless）应用。</p><p>有状态的应用指的是应用中使用了类似于连接、聚合或时间窗口（Window）的 API。</p><p>无状态的应用是指在这类应用中，某条消息的处理结果不会影响或依赖其他消息的处理。常见的无状态操作包括事件转换以及刚刚那个例子中的过滤等。</p><h3 id="流表二元性"><a href="#流表二元性" class="headerlink" title="流表二元性"></a>流表二元性</h3><p>流就是一个永不停止（至少理论上是这样的）的事件序列，而表和关系型数据库中的概念类似，是一组行记录。</p><p>在流处理领域，两者是有机统一的：流在时间维度上聚合之后形成表，表在时间维度上不断更新形成流，这就是所谓的流表二元性（Duality of Streams and Tables）</p><p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/image-20250625194557761.png"></p><p>流和表的概念在流处理领域非常关键。在 Kafka Streams DSL 中，流用 KStream 表示，而表用 KTable 表示。</p><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><p>在流处理领域内，精确定义事件时间是非常关键的：一方面，它是决定流处理应用能否实现正确性的前提；另一方面，流处理中时间窗口等操作依赖于时间概念才能正常工作。</p><p>常见的时间概念有两类：事件发生时间（Event Time）和事件处理时间（Processing Time）。理想情况下，我们希望这两个时间相等，即事件一旦发生就马上被处理，但在实际场景中，这是不可能的，Processing Time 永远滞后于 Event Time</p><p>如果流处理应用要实现结果的正确性，就必须要使用基于 Event Time 的时间窗口，而不能使用基于 Processing Time 的时间窗口。</p><h3 id="时间窗口"><a href="#时间窗口" class="headerlink" title="时间窗口"></a>时间窗口</h3><p>所谓的时间窗口机制，就是将流数据沿着时间线切分的过程。常见的时间窗口包括：</p><ul><li>固定时间窗口（Fixed Windows）</li><li>滑动时间窗口（Sliding Windows）</li><li>会话窗口（Session Windows）</li></ul><h3 id="eg运行一个WordCont实例"><a href="#eg运行一个WordCont实例" class="headerlink" title="eg运行一个WordCont实例"></a>eg运行一个WordCont实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> kafkalearn.demo.wordcount;<br><br><br><span class="hljs-keyword">import</span> org.apache.kafka.clients.consumer.ConsumerConfig;<br><span class="hljs-keyword">import</span> org.apache.kafka.common.serialization.Serdes;<br><span class="hljs-keyword">import</span> org.apache.kafka.streams.KafkaStreams;<br><span class="hljs-keyword">import</span> org.apache.kafka.streams.StreamsBuilder;<br><span class="hljs-keyword">import</span> org.apache.kafka.streams.StreamsConfig;<br><span class="hljs-keyword">import</span> org.apache.kafka.streams.kstream.KStream;<br><span class="hljs-keyword">import</span> org.apache.kafka.streams.kstream.KTable;<br><span class="hljs-keyword">import</span> org.apache.kafka.streams.kstream.Produced;<br><br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Locale;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WordCountDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Properties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        props.put(StreamsConfig.APPLICATION_ID_CONFIG, <span class="hljs-string">&quot;wordcount-stream-demo&quot;</span>);<br>        props.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="hljs-string">&quot;localhost:9092&quot;</span>);<br>        props.put(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, Serdes.String().getClass().getName());<br>        props.put(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG, Serdes.String().getClass().getName());<br>        props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, <span class="hljs-string">&quot;earliest&quot;</span>);<br><br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">StreamsBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StreamsBuilder</span>();<br><br><br>        <span class="hljs-keyword">final</span> KStream&lt;String, String&gt; source = builder.stream(<span class="hljs-string">&quot;wordcount-input-topic&quot;</span>);<br><br><br>        <span class="hljs-keyword">final</span> KTable&lt;String, Long&gt; counts = source<br>            .flatMapValues(value -&gt; Arrays.asList(value.toLowerCase(Locale.getDefault()).split(<span class="hljs-string">&quot; &quot;</span>)))<br>            .groupBy((key, value) -&gt; value)<br>            .count();<br><br><br>        counts.toStream().to(<span class="hljs-string">&quot;wordcount-output-topic&quot;</span>, Produced.with(Serdes.String(), Serdes.Long()));<br><br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">KafkaStreams</span> <span class="hljs-variable">streams</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaStreams</span>(builder.build(), props);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br><br><br>        Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;wordcount-stream-demo-jvm-hook&quot;</span>) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                streams.close();<br>                latch.countDown();<br>            &#125;<br>        &#125;);<br><br><br>        <span class="hljs-keyword">try</span> &#123;<br>            streams.start();<br>            latch.await();<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Throwable e) &#123;<br>            System.exit(<span class="hljs-number">1</span>);<br>        &#125;<br>        System.exit(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h2 id="6-2-Kafka-Streams在金融领域的应用"><a href="#6-2-Kafka-Streams在金融领域的应用" class="headerlink" title="6.2 Kafka Streams在金融领域的应用"></a>6.2 Kafka Streams在金融领域的应用</h2><p>简单的例子。假设有一个金融理财用户张三，他首先在苹果手机上访问了某理财产品，然后在安卓手机上注册了该理财产品的账号，最后在电脑上登录该账号，并购买了该理财产品。ID Mapping 就是要将这些不同端或设备上的用户信息聚合起来，然后找出并打通用户所关联的所有 ID 信息。</p><p>何使用 Kafka Streams 来实现一个特定场景下的实时 ID Mapping。为了方便理解，我们假设 ID Mapping 只关心身份证号、手机号以及设备 ID。下面是用 Avro 写成的 Schema 格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>  <span class="hljs-string">&quot;namespace&quot;</span>: <span class="hljs-string">&quot;kafkalearn.userprofile.idmapping&quot;</span>,<br>  <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;record&quot;</span>,<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;IDMapping&quot;</span>,<br>  <span class="hljs-string">&quot;fields&quot;</span>: [<br>    &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;deviceId&quot;</span>, <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;string&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;idCard&quot;</span>, <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;string&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;phone&quot;</span>, <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;string&quot;</span>&#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> kafkalearn.userprofile.idmapping;<br><br><span class="hljs-comment">// omit imports……</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IDMappingStreams</span> &#123;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-keyword">if</span> (args.length &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Must specify the path for a configuration file.&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-type">IDMappingStreams</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IDMappingStreams</span>();<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">envProps</span> <span class="hljs-operator">=</span> instance.loadProperties(args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">streamProps</span> <span class="hljs-operator">=</span> instance.buildStreamsProperties(envProps);<br>        <span class="hljs-type">Topology</span> <span class="hljs-variable">topology</span> <span class="hljs-operator">=</span> instance.buildTopology(envProps);<br><br>        instance.createTopics(envProps);<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">KafkaStreams</span> <span class="hljs-variable">streams</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaStreams</span>(topology, streamProps);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// Attach shutdown handler to catch Control-C.</span><br>        Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;streams-shutdown-hook&quot;</span>) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                streams.close();<br>                latch.countDown();<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            streams.start();<br>            latch.await();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            System.exit(<span class="hljs-number">1</span>);<br>        &#125;<br>        System.exit(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Properties <span class="hljs-title function_">loadProperties</span><span class="hljs-params">(String propertyFilePath)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">envProps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(propertyFilePath)) &#123;<br>            envProps.load(input);<br>            <span class="hljs-keyword">return</span> envProps;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Properties <span class="hljs-title function_">buildStreamsProperties</span><span class="hljs-params">(Properties envProps)</span> &#123;<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        props.put(StreamsConfig.APPLICATION_ID_CONFIG, envProps.getProperty(<span class="hljs-string">&quot;application.id&quot;</span>));<br>        props.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, envProps.getProperty(<span class="hljs-string">&quot;bootstrap.servers&quot;</span>));<br>        props.put(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, Serdes.String().getClass());<br>        props.put(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG, Serdes.String().getClass());<br>        <span class="hljs-keyword">return</span> props;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createTopics</span><span class="hljs-params">(Properties envProps)</span> &#123;<br>        Map&lt;String, Object&gt; config = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        config.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, envProps.getProperty(<span class="hljs-string">&quot;bootstrap.servers&quot;</span>));<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">AdminClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> AdminClient.create(config)) &#123;<br>            List&lt;NewTopic&gt; topics = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            topics.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NewTopic</span>(<br>                    envProps.getProperty(<span class="hljs-string">&quot;stream.topic.name&quot;</span>),<br>                    Integer.parseInt(envProps.getProperty(<span class="hljs-string">&quot;stream.topic.partitions&quot;</span>)),<br>                    Short.parseShort(envProps.getProperty(<span class="hljs-string">&quot;stream.topic.replication.factor&quot;</span>))));<br><br>            topics.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NewTopic</span>(<br>                    envProps.getProperty(<span class="hljs-string">&quot;table.topic.name&quot;</span>),<br>                    Integer.parseInt(envProps.getProperty(<span class="hljs-string">&quot;table.topic.partitions&quot;</span>)),<br>                    Short.parseShort(envProps.getProperty(<span class="hljs-string">&quot;table.topic.replication.factor&quot;</span>))));<br><br>            client.createTopics(topics);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Topology <span class="hljs-title function_">buildTopology</span><span class="hljs-params">(Properties envProps)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">StreamsBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StreamsBuilder</span>();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">streamTopic</span> <span class="hljs-operator">=</span> envProps.getProperty(<span class="hljs-string">&quot;stream.topic.name&quot;</span>);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">rekeyedTopic</span> <span class="hljs-operator">=</span> envProps.getProperty(<span class="hljs-string">&quot;rekeyed.topic.name&quot;</span>);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">tableTopic</span> <span class="hljs-operator">=</span> envProps.getProperty(<span class="hljs-string">&quot;table.topic.name&quot;</span>);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">outputTopic</span> <span class="hljs-operator">=</span> envProps.getProperty(<span class="hljs-string">&quot;output.topic.name&quot;</span>);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Gson</span> <span class="hljs-variable">gson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>();<br><br>        <span class="hljs-comment">// 1. 构造表</span><br>        KStream&lt;String, IDMapping&gt; rekeyed = builder.&lt;String, String&gt;stream(tableTopic)<br>                .mapValues(json -&gt; gson.fromJson(json, IDMapping.class))<br>                .filter((noKey, idMapping) -&gt; !Objects.isNull(idMapping.getPhone()))<br>                .map((noKey, idMapping) -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">KeyValue</span>&lt;&gt;(idMapping.getPhone(), idMapping));<br>        rekeyed.to(rekeyedTopic);<br>        KTable&lt;String, IDMapping&gt; table = builder.table(rekeyedTopic);<br><br>        <span class="hljs-comment">// 2. 流-表连接</span><br>        KStream&lt;String, String&gt; joinedStream = builder.&lt;String, String&gt;stream(streamTopic)<br>                .mapValues(json -&gt; gson.fromJson(json, IDMapping.class))<br>                .map((noKey, idMapping) -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">KeyValue</span>&lt;&gt;(idMapping.getPhone(), idMapping))<br>                .leftJoin(table, (value1, value2) -&gt; IDMapping.newBuilder()<br>                        .setPhone(value2.getPhone() == <span class="hljs-literal">null</span> ? value1.getPhone() : value2.getPhone())<br>                        .setDeviceId(value2.getDeviceId() == <span class="hljs-literal">null</span> ? value1.getDeviceId() : value2.getDeviceId())<br>                        .setIdCard(value2.getIdCard() == <span class="hljs-literal">null</span> ? value1.getIdCard() : value2.getIdCard())<br>                        .build())<br>                .mapValues(v -&gt; gson.toJson(v));<br><br>        joinedStream.to(outputTopic);<br><br>        <span class="hljs-keyword">return</span> builder.build();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深入理解kafka-核心技术与实战篇【干的要命系列】（一）</title>
    <link href="/2025/06/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3kafka-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E7%AF%87%E3%80%90%E5%B9%B2%E7%9A%84%E8%A6%81%E5%91%BD%E7%B3%BB%E5%88%97%E3%80%91%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2025/06/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3kafka-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E7%AF%87%E3%80%90%E5%B9%B2%E7%9A%84%E8%A6%81%E5%91%BD%E7%B3%BB%E5%88%97%E3%80%91%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/image-20250619201202850.png"></p><h1 id="1-开篇"><a href="#1-开篇" class="headerlink" title="1. 开篇"></a>1. 开篇</h1><h2 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1 前言"></a>1.1 前言</h2><p>看8股文学习kafka，对其的理解都是别人的一些总结，都是些嚼碎的散状知识（主要之前面试一问这里深点，就跟个菜鸡😅）。为了让有个立体全面的深入学习，so计划写两篇关于kafka的博客，第一篇是聚焦kafka核心的技术与实战，第二篇是通过源码来加深学习kafka，此为第一篇，这篇更加偏向技术实战，此篇预计分两个篇幅完成（内容比较干）。</p><h2 id="1-2-为什么要学习kafka？"><a href="#1-2-为什么要学习kafka？" class="headerlink" title="1.2 为什么要学习kafka？"></a>1.2 为什么要学习kafka？</h2><p>作为工程师或者架构师，在实际的工作中难免遇见大数据业务的建设，由于这些系统都是为公司业务服务的，所以他们仅仅只是执行一些常规的业务逻辑，因此他们不能算是计算密集型，相反更多是数据密集型。对于数据密集型应用来说，如何对应数据的激增、数据的复杂度以及数据高速的变化，是对工程师架构师最有效的证明。就拿数据激增来说，Kafka能有效的隔离上下游业务，将上游的流量激增平滑的传递到子系统中。如果是一名大数据从业人员，熟练掌握Kafka是非常有必要的技能。</p><p>同时Kafka有着广阔的应用场景。目前Apache Kafka被认为是消息引擎领域的引导者，技术学习角度而言，Kafka有很多亮点，我们只需要学习一套框架就能在实际业务系统中实现消息引擎、应用程序集成、分布式存储构建、甚至是流处理应用的开发与部署，简直物超所值。</p><h2 id="1-3-如何学习"><a href="#1-3-如何学习" class="headerlink" title="1.3 如何学习"></a>1.3 如何学习</h2><p>第一步先弄清楚客户端，目前有两大客户端：<strong>Java客户端和libkafka客户端</strong>，然后去官网学习一下代码演示，如何正常的编译和运行这些样例。</p><p>第二步修改对应的样例，理解使用其他API，对这些修改进行观测，做一个小项目来验证学习成果。这个阶段就可以熟读一遍Kafka官方文档，重点理解各种参数。</p><p>最后学习Kafka的高级功能，比如流处理，还能执行高级的流式处理操作，比如时间窗口聚合、流处理链接等。</p><p>如果是相关运维，相应的学习目标应该是学习搭建及管理 Kafka 线上环境，如何进行监控数据等。</p><p>这里用脑图来总结一下学习线路：</p><p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/image-20250619191803946.png"></p><h1 id="2-Kafka入门"><a href="#2-Kafka入门" class="headerlink" title="2. Kafka入门"></a>2. Kafka入门</h1><h2 id="2-1-常见术语"><a href="#2-1-常见术语" class="headerlink" title="2.1 常见术语"></a>2.1 常见术语</h2><ul><li>消息：Record。Kafka 是消息引擎嘛，这里的消息就是指 Kafka 处理的主要对象。</li><li>主题：Topic。主题是承载消息的逻辑容器，在实际使用中多用来区分具体的业务。</li><li>分区：Partition。一个有序不变的消息序列。每个主题下可以有多个分区。</li><li>消息位移：Offset。表示分区中每条消息的位置信息，是一个单调递增且不变的值。</li><li>副本：Replica。Kafka 中同一条消息能够被拷贝到多个地方以提供数据冗余，这些地方就是所谓的副本。副本还分为领导者副本和追随者副本，各自有不同的角色划分。副本是在分区层级下的，即每个分区可配置多个副本实现高可用。</li><li>生产者：Producer。向主题发布新消息的应用程序。</li><li>消费者：Consumer。从主题订阅新消息的应用程序。</li><li>消费者位移：Consumer Offset。表征消费者消费进度，每个消费者都有自己的消费者位移。</li><li>消费者组：Consumer Group。多个消费者实例共同组成的一个组，同时消费多个分区以实现高吞吐。</li><li>重平衡：Rebalance。消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。Rebalance 是 Kafka 消费者端实现高可用的重要手段。</li></ul><p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/image-20250619192426954.png"></p><h2 id="2-2-Kafka的种类"><a href="#2-2-Kafka的种类" class="headerlink" title="2.2 Kafka的种类"></a>2.2 Kafka的种类</h2><ul><li>Apache Kafka: 最正宗的Kafka，他是后续所有发行版的基础。</li><li>Confluent Kafka: 主要为商业开发工具，拥有原本没有的高级特性，比如跨数据中心备份、Schema注册中心以及集群监控工具等。</li><li>Cloudera&#x2F;Hortonworks Kafka: CDH和Hortonworks提供HDP是非常著名的大数据平台，里边集成了目前主流的大数据框架，能够帮助用户实现分布式存储、集群调度、流处理到机器学习、实时数据库等全方面的数据处理。</li></ul><h1 id="3-Kafka基本使用"><a href="#3-Kafka基本使用" class="headerlink" title="3. Kafka基本使用"></a>3. Kafka基本使用</h1><h2 id="3-1-Kafka线上集群部署方式"><a href="#3-1-Kafka线上集群部署方式" class="headerlink" title="3.1 Kafka线上集群部署方式"></a>3.1 Kafka线上集群部署方式</h2><p>下面从几个方面：操作系统、磁盘、磁盘容量、带宽来讨论</p><h3 id="3-1-2-操作系统"><a href="#3-1-2-操作系统" class="headerlink" title="3.1.2 操作系统"></a>3.1.2 操作系统</h3><p>目前常见的操作系统有 3 种：Linux、Windows 和 macOS。部署在 Linux 上的生产环境是最多的，一般从下面三个方面考虑</p><ul><li>I&#x2F;O 模型的使用</li><li>数据网络的传输效率</li><li>社区支持度</li></ul><p>主流的 I&#x2F;O 模型通常有 5 种类型：阻塞式 I&#x2F;O、非阻塞式 I&#x2F;O、I&#x2F;O 多路复用、信号驱动 I&#x2F;O 和异步 I&#x2F;O。每种 I&#x2F;O 模型都有各自典型的使用场景，比如 Java 中 Socket 对象的阻塞模式和非阻塞模式就对应于前两种模型；而 Linux 中的系统调用 select 函数就属于 I&#x2F;O 多路复用模型；大名鼎鼎的 epoll 系统调用则介于第三种和第四种模型之间；至于第五种模型，其实很少有 Linux 系统支持，反而是 Windows 系统提供了一个叫 IOCP 线程模型属于这一种。</p><p>熟悉 Linux肯定听过零拷贝（Zero Copy）技术，就是当数据在磁盘和网络进行传输时避免昂贵的内核态数据拷贝从而实现快速的数据传输。Linux 平台实现了这样的零拷贝机制。</p><h3 id="3-1-3-磁盘及容量"><a href="#3-1-3-磁盘及容量" class="headerlink" title="3.1.3 磁盘及容量"></a>3.1.3 磁盘及容量</h3><ul><li><p>追求性价比可以不搭建 RAID，使用普通磁盘组成存储空间即可。</p></li><li><p>使用机械磁盘完全能够胜任 Kafka 线上环境。</p></li></ul><p>那么容量相关的，是需要计算规划的，比如每天一亿条1KB大小消息，保存两份且存两周，那么总共就需要200GB的内存。Kafka还需要索引数据大概10%，保存两周那么就是200GB * 1.1 * 14 那就大概需要3TB大小。Kafka还支持数据压缩，压缩比是0.75，那么这就是最后在2.25-3TB之间。</p><p>总之在规划磁盘容量时你需要考虑下面这几个元素：</p><ul><li>新增消息数</li><li>消息留存时间</li><li>平均消息大小</li><li>备份数</li><li>是否启用压缩</li></ul><h3 id="3-1-4-带宽"><a href="#3-1-4-带宽" class="headerlink" title="3.1.4 带宽"></a>3.1.4 带宽</h3><p>带宽需要根据Kafka服务器的数量、业务量处理目标来定，比如需要在一个小时处理1TB的数据，同时需要3台机器，根据实际经验kafka用到70%以上的带宽就会丢包，那么单台的使用带宽就是 700Mb &#x2F; 3 约等于 240Mbps。</p><h2 id="3-2-kafka的配置重要参数"><a href="#3-2-kafka的配置重要参数" class="headerlink" title="3.2 kafka的配置重要参数"></a>3.2 kafka的配置重要参数</h2><p>静态参数，是指你必须在 Kafka 的配置文件 server.properties 中进行设置的参数，不管你是新增、修改还是删除。同时，你必须重启 Broker 进程才能令它们生效。而主题级别参数的设置则有所不同，Kafka 提供了专门的 kafka-configs 命令来修改它们。至于 JVM 和操作系统级别参数，它们的设置方法比较通用化，我介绍的也都是标准的配置参数，因此，你应该很容易就能够对它们进行设置</p><h3 id="Boker的重要参数-静态参数"><a href="#Boker的重要参数-静态参数" class="headerlink" title="Boker的重要参数(静态参数):"></a>Boker的重要参数(静态参数):</h3><ul><li>log.dirs : 指定Broker使用的文件目录路径</li><li>log.dir :  补充log.dirs的单个路径</li><li>zookeeper.connect : ZooKeeper相关设置,保存Kafka集群的元数据信息</li><li>与Broker连接相关的设置<ul><li>listeners:学名叫监听器，告诉外部连接者要通过什么协议访问指定主机名和端口开放的 Kafka 服务</li><li>advertised.listeners:这组监听器是 Broker 用于对外发布的</li><li>host.name&#x2F;port:域名和端口</li></ul></li><li>Topic管理参数<ul><li>auto.create.topics.enable: 是否允许自动创建 Topic</li><li>unclean.leader.election.enable:是否允许 Unclean Leader 选举</li><li>auto.leader.rebalance.enable:是否允许定期进行 Leader 选举</li></ul></li><li>数据留存参数<ul><li>log.retention.{hours|minutes|ms}: 都是控制一条消息数据被保存多长时间</li><li>log.retention.bytes:这是指定 Broker 为消息保存的总磁盘容量大小</li><li>message.max.bytes:控制 Broker 能够接收的最大消息大小</li></ul></li></ul><h3 id="Topic的重要参数："><a href="#Topic的重要参数：" class="headerlink" title="Topic的重要参数："></a>Topic的重要参数：</h3><ul><li>Topic级别参数<ul><li>retention.ms: 规定了该 Topic 消息被保存的时长。默认是 7 天</li><li>retention.bytes: 规定了要为该 Topic 预留多大的磁盘空间</li><li>max.message.bytes: 决定了 Kafka Broker 能够正常接收该 Topic 的最大消息大小</li></ul></li></ul><h3 id="JVM参数："><a href="#JVM参数：" class="headerlink" title="JVM参数："></a>JVM参数：</h3><ul><li>JAVA版本</li><li>堆大小</li><li>垃圾回收器选择</li><li>设置方法：KAFKA_HEAP_OPS 、KAFKA_JVM_PERFORMANCE_OPTS</li></ul><h4 id="操作系统参数"><a href="#操作系统参数" class="headerlink" title="操作系统参数"></a>操作系统参数</h4><ul><li>文件描述符限制</li><li>文件系统类型</li><li>Swappiness</li><li>提交时间</li></ul><h1 id="4-客户端实践及原理剖析"><a href="#4-客户端实践及原理剖析" class="headerlink" title="4. 客户端实践及原理剖析"></a>4. 客户端实践及原理剖析</h1><h2 id="4-1-生产者分区概念"><a href="#4-1-生产者分区概念" class="headerlink" title="4.1 生产者分区概念"></a>4.1 生产者分区概念</h2><h3 id="4-1-1-何为分区？"><a href="#4-1-1-何为分区？" class="headerlink" title="4.1.1 何为分区？"></a>4.1.1 何为分区？</h3><p>A：Kafka的结构是：主题 - 分区 - 消息，主题下的每条消息都会在某一个分区里，如下图</p><p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/image-20250619204602741.png"></p><p>其实分区的作用是提供负载均衡的能力，为了实现系统的高伸缩性（Scalability）。这样就可以把读写都在各自的分区里完成，提高系统的吞吐量。不同的分布式系统对分区的叫法也不尽相同。比如在 Kafka 中叫分区，在 MongoDB 和 Elasticsearch 中就叫分片 Shard，而在 HBase 中则叫 Region。但是换汤不换药，整体思想是不变的。</p><h3 id="4-1-2-分区策略"><a href="#4-1-2-分区策略" class="headerlink" title="4.1.2 分区策略"></a>4.1.2 分区策略</h3><p>Kafka 为我们提供了默认的分区策略，同时它也支持你自定义分区策略。如果要自定义分区策略，你需要显式地配置生产者端的参数partitioner.class。在编写生产者程序时，你可以编写一个具体的类实现org.apache.kafka.clients.producer.Partitioner接口。这个接口也很简单，只定义了两个方法：partition()和close()，通常你只需要实现最重要的 partition 方法。我们来看看这个方法的方法签名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(String topic, Object key, <span class="hljs-type">byte</span>[] keyBytes, Object value, <span class="hljs-type">byte</span>[] valueBytes, Cluster cluster)</span>;<br></code></pre></td></tr></table></figure><p>分区策略有以下几种：</p><ul><li>轮训</li><li>随机</li><li>按照消息key保序</li></ul><h2 id="4-2-Kafka的生产者压缩及算法"><a href="#4-2-Kafka的生产者压缩及算法" class="headerlink" title="4.2 Kafka的生产者压缩及算法"></a>4.2 Kafka的生产者压缩及算法</h2><p>在 Kafka 中，压缩可能发生在两个地方：生产者端和 Broker 端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Properties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>props.put(<span class="hljs-string">&quot;bootstrap.servers&quot;</span>, <span class="hljs-string">&quot;localhost:9092&quot;</span>);<br>props.put(<span class="hljs-string">&quot;acks&quot;</span>, <span class="hljs-string">&quot;all&quot;</span>);<br>props.put(<span class="hljs-string">&quot;key.serializer&quot;</span>, <span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);<br>props.put(<span class="hljs-string">&quot;value.serializer&quot;</span>, <span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);<br><span class="hljs-comment">// 开启GZIP压缩</span><br>props.put(<span class="hljs-string">&quot;compression.type&quot;</span>, <span class="hljs-string">&quot;gzip&quot;</span>);<br><br>Producer&lt;String, String&gt; producer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaProducer</span>&lt;&gt;(props);<br></code></pre></td></tr></table></figure><p>其实大部分情况下 Broker 从 Producer 端接收到消息后仅仅是原封不动地保存而不会对其进行任何修改，但这里的“大部分情况”也是要满足一定条件的。有两种例外情况就可能让 Broker 重新压缩消息。</p><p>情况一：Broker 端指定了和 Producer 端不同的压缩算法。</p><p>情况二：Broker 端发生了消息格式转换。</p><p>最好的方式是：Producer 端压缩、Broker 端保持、Consumer 端解压缩。</p><p>不论哪个版本，Kafka的消息层次分为两次：消息集合(message set)，消息（message）。一个消息集合包含若干日志项，日志项才是真正封装消息的地方。Kafka不会直接操作一条条的消息，而是在消息集合这个层面进行写入操作。</p><p>Kafka 支持 3 种压缩算法：GZIP、Snappy 和 LZ4。从 2.1.0 开始，Kafka 正式支持 Zstandard 算法（简写为 zstd），下边是各个压缩算法的优劣。</p><p> <img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/image-20250620105405660.png"></p><p>在实际使用中，GZIP、Snappy、LZ4 甚至是 zstd 的表现各有千秋。但对于 Kafka 而言，它们的性能测试结果却出奇得一致，即在吞吐量方面：LZ4 &gt; Snappy &gt; zstd 和 GZIP；而在压缩比方面，zstd &gt; LZ4 &gt; GZIP &gt; Snappy。具体到物理资源，使用 Snappy 算法占用的网络带宽最多，zstd 最少，这是合理的，毕竟 zstd 就是要提供超高的压缩比；在 CPU 使用率方面，各个算法表现得差不多，只是在压缩时 Snappy 算法使用的 CPU 较多一些，而在解压缩时 GZIP 算法则可能使用更多的 CPU。</p><h2 id="4-3-怎么保证Kafka消息不丢失"><a href="#4-3-怎么保证Kafka消息不丢失" class="headerlink" title="4.3 怎么保证Kafka消息不丢失"></a>4.3 怎么保证Kafka消息不丢失</h2><ol><li>不要使用 producer.send(msg)，而要使用 producer.send(msg, callback)。记住，一定要使用带有回调通知的 send 方法。</li><li>设置 acks &#x3D; all。acks 是 Producer 的一个参数，代表了你对“已提交”消息的定义。如果设置成 all，则表明所有副本 Broker 都要接收到消息，该消息才算是“已提交”。这是最高等级的“已提交”定义。</li><li>设置 retries 为一个较大的值。这里的 retries 同样是 Producer 的参数，对应前面提到的 Producer 自动重试。当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了 retries &gt; 0 的 Producer 能够自动重试消息发送，避免消息丢失。</li><li>设置 unclean.leader.election.enable &#x3D; false。这是 Broker 端的参数，它控制的是哪些 Broker 有资格竞选分区的 Leader。如果一个 Broker 落后原先的 Leader 太多，那么它一旦成为新的 Leader，必然会造成消息的丢失。故一般都要将该参数设置成 false，即不允许这种情况的发生。</li><li>设置 replication.factor &gt;&#x3D; 3。这也是 Broker 端的参数。其实这里想表述的是，最好将消息多保存几份，毕竟目前防止消息丢失的主要机制就是冗余。设置 min.insync.replicas &gt; 1。这依然是 Broker 端参数，控制的是消息至少要被写入到多少个副本才算是“已提交”。设置成大于 1 可以提升消息持久性。在实际环境中千万不要使用默认值 1。</li><li>确保 replication.factor &gt; min.insync.replicas。如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了。我们不仅要改善消息的持久性，防止数据丢失，还要在不降低可用性的基础上完成。推荐设置成 replication.factor &#x3D; min.insync.replicas + 1。确保消息消费完成再提交。</li><li>Consumer 端有个参数 enable.auto.commit，最好把它设置成 false，并采用手动提交位移的方式。就像前面说的，这对于单 Consumer 多线程处理的场景而言是至关重要的。</li></ol><h2 id="4-4-高级功能"><a href="#4-4-高级功能" class="headerlink" title="4.4 高级功能"></a>4.4 高级功能</h2><p>Kafka可以自定义拦截器，支持为生产者和消费者，支持链式拦截，设置方法通过参数进行完成。在一些客户端监控，端到端系统性能检测、以及审计日志上都有典型的应用场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Properties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>List&lt;String&gt; interceptors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>interceptors.add(<span class="hljs-string">&quot;com.yourcompany.kafkaproject.interceptors.AddTimestampInterceptor&quot;</span>); <span class="hljs-comment">// 拦截器1</span><br>interceptors.add(<span class="hljs-string">&quot;com.yourcompany.kafkaproject.interceptors.UpdateCounterInterceptor&quot;</span>); <span class="hljs-comment">// 拦截器2</span><br>props.put(ProducerConfig.INTERCEPTOR_CLASSES_CONFIG, interceptors);<br>……<br></code></pre></td></tr></table></figure><h2 id="4-5-生产者如何管理TCP链接的"><a href="#4-5-生产者如何管理TCP链接的" class="headerlink" title="4.5 生产者如何管理TCP链接的"></a>4.5 生产者如何管理TCP链接的</h2><p>Apache Kafka 所有的通讯都是基于TCP的，在创建 KafkaProducer 实例时，生产者应用会在后台创建并启动一个名为 Sender 的线程，该 Sender 线程开始运行时首先会创建与 Broker 的连接，TCP 连接还可能在两个地方被创建：一个是在更新元数据后，另一个是在消息发送时。Producer 端关闭 TCP 连接的方式有两种：一种是用户主动关闭；一种是 Kafka 自动关闭。</p><h2 id="4-6-幂等生产者和事务生产者"><a href="#4-6-幂等生产者和事务生产者" class="headerlink" title="4.6 幂等生产者和事务生产者"></a>4.6 幂等生产者和事务生产者</h2><p>Kafka的消息交付可靠性保障的三种承诺：最多一次、至少一次和精确一次。</p><p>Kafka 是怎么做到精确一次的呢？简单来说，这是通过两种机制：幂等性（Idempotence）和事务（Transaction）</p><h3 id="4-6-1-幂等性-Producer"><a href="#4-6-1-幂等性-Producer" class="headerlink" title="4.6.1 幂等性 Producer"></a>4.6.1 幂等性 Producer</h3><p>在 0.11 之后，指定 Producer 幂等性的方法很简单，仅需要设置一个参数即可，即 props.put(“enable.idempotence”, ture)，或 props.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG， true)</p><h3 id="4-6-2-事务"><a href="#4-6-2-事务" class="headerlink" title="4.6.2 事务"></a>4.6.2 事务</h3><p>事务型 Producer 能够保证将消息原子性地写入到多个分区中。这批消息要么全部写入成功，要么全部失败。</p><p>设置事务型 Producer 的方法也很简单，满足两个要求即可：</p><ul><li>和幂等性 Producer 一样，开启 enable.idempotence &#x3D; true。</li><li>设置 Producer 端参数 transactional. id。最好为其设置一个有意义的名字。</li></ul><p>相关Producer代码中做一些调整：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">producer.initTransactions();<br><span class="hljs-keyword">try</span> &#123;<br>  producer.beginTransaction();<br>  producer.send(record1);<br>  producer.send(record2);<br>  producer.commitTransaction();<br>&#125; <span class="hljs-keyword">catch</span> (KafkaException e) &#123;<br>  producer.abortTransaction();<br>&#125;<br></code></pre></td></tr></table></figure><p>和普通 Producer 代码相比，事务型 Producer 的显著特点是调用了一些事务 API，如 initTransaction、beginTransaction、commitTransaction 和 abortTransaction，它们分别对应事务的初始化、事务开始、事务提交以及事务终止。</p><h2 id="4-7-Kafka的消费者组"><a href="#4-7-Kafka的消费者组" class="headerlink" title="4.7 Kafka的消费者组"></a>4.7 Kafka的消费者组</h2><p>Consumer Group是Kafka提供的可扩展且具有容错性的消费者机制。既然是组，必然可以有多个消费者或者消费者实例，他们共享一个公共组ID。组内的所有消费者协调在一起来消费订阅主题的所有分区</p><ol><li>Consumer Group 下可以有一个或多个 Consumer 实例。</li><li>Group ID 是一个字符串，在一个 Kafka 集群中，它标识唯一的一个 Consumer Group。</li><li>Consumer Group 下所有实例订阅的主题的单个分区，只能分配给组内的某个 Consumer 实例消费。这个分区当然也可以被其他的 Group 消费。</li></ol><p>Kafka 仅仅使用 Consumer Group 这一种机制，却同时实现了传统消息引擎系统的两大模型：如果所有实例都属于同一个 Group，那么它实现的就是消息队列模型；如果所有实例分别属于不同的 Group，那么它实现的就是发布 &#x2F; 订阅模型。</p><p>Consumer Group 端大名鼎鼎的重平衡，也就是所谓的 Rebalance 过程，Rebalance 本质上是一种协议，规定了一个 Consumer Group 下的所有 Consumer 如何达成一致，来分配订阅 Topic 的每个分区。比如某个 Group 下有 20 个 Consumer 实例，它订阅了一个具有 100 个分区的 Topic。正常情况下，Kafka 平均会为每个 Consumer 分配 5 个分区。这个分配的过程就叫 Rebalance。</p><p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/image-20250620145352772.png"></p><h2 id="4-8-位移主题（-consumer-offsets）"><a href="#4-8-位移主题（-consumer-offsets）" class="headerlink" title="4.8 位移主题（__consumer_offsets）"></a>4.8 位移主题（__consumer_offsets）</h2><p>位移消息都放在位移主题(__consumer_offset topic)中，已经取代zk。 一共有三种消息类型： </p><p>1、__consumer_offset 记录消费组下某个消费者在某个topic的partition的位移信息（是一种key value的一种格式，key由三部分组成 groupid+topic+pattition）。</p><p> 2、consumer group信息（在新建group会创建该消息）。</p><p> 3、tombstone（墓碑消息），移除group consumer所有的信息。 【注意】：第三种消息会在group下的所有consumer下线 且 group偏移信息全部移除才会发出墓碑消息。</p><p>Kafka 使用 Compact 策略来删除位移主题中的过期消息，避免该主题无限期膨胀</p><p> <img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/image-20250620154105495.png" alt="image-20250620154105495"></p><h2 id="4-9-Rebalance"><a href="#4-9-Rebalance" class="headerlink" title="4.9 Rebalance"></a>4.9 Rebalance</h2><p>Rebalance 就是让一个 Consumer Group 下所有的 Consumer 实例就如何消费订阅主题的所有分区达成共识的过程。在 Rebalance 过程中，所有 Consumer 实例共同参与，在协调者组件的帮助下，完成订阅主题分区的分配。但是，在整个过程中，所有实例都不能消费任何消息，因此它对 Consumer 的 TPS 影响很大。</p><h2 id="4-10-位移提交"><a href="#4-10-位移提交" class="headerlink" title="4.10 位移提交"></a>4.10 位移提交</h2><p>位移提交分自动提交和手动提交</p><p>开启自动提交的方法很简单。Consumer端有个参数enable.auto.commit,把它设置成true或者默认就是自动提交。还有一个参数：auto.commit.interval.ms，表示Kafka多少秒后为你自动提交。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Properties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>     props.put(<span class="hljs-string">&quot;bootstrap.servers&quot;</span>, <span class="hljs-string">&quot;localhost:9092&quot;</span>);<br>     props.put(<span class="hljs-string">&quot;group.id&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>);<br>     props.put(<span class="hljs-string">&quot;enable.auto.commit&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);<br>     props.put(<span class="hljs-string">&quot;auto.commit.interval.ms&quot;</span>, <span class="hljs-string">&quot;2000&quot;</span>);<br>     props.put(<span class="hljs-string">&quot;key.deserializer&quot;</span>, <span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);<br>     props.put(<span class="hljs-string">&quot;value.deserializer&quot;</span>, <span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);<br>     KafkaConsumer&lt;String, String&gt; consumer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaConsumer</span>&lt;&gt;(props);<br>     consumer.subscribe(Arrays.asList(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>));<br>     <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>         ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="hljs-number">100</span>);<br>         <span class="hljs-keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)<br>             System.out.printf(<span class="hljs-string">&quot;offset = %d, key = %s, value = %s%n&quot;</span>, record.offset(), record.key(), record.value());<br>     &#125;<br></code></pre></td></tr></table></figure><p>手动提交要调用对应的API手动提交，最简单的是KafkaConsumer#commitSync()，该方法会提交 KafkaConsumer#poll() 返回的最新位移。从名字上来看，它是一个同步操作，即该方法会一直等待，直到位移被成功提交才会返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>      ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofSeconds(<span class="hljs-number">1</span>));<br>      process(records); <span class="hljs-comment">// 处理消息</span><br>      <span class="hljs-keyword">try</span> &#123;<br>        consumer.commitSync();<br>      &#125; <span class="hljs-keyword">catch</span> (CommitFailedException e) &#123;<br>        handle(e); <span class="hljs-comment">// 处理提交失败异常</span><br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一旦设置了 enable.auto.commit 为 true，Kafka 会保证在开始调用 poll 方法时，提交上次 poll 返回的所有消息。从顺序上来说，poll 方法的逻辑是先提交上一批消息的位移，再处理下一批消息，因此它能保证不出现消费丢失的情况。但自动提交位移的一个问题在于，它可能会出现重复消费。</p><p>刚才说的API是同步操作，会导致客户端的阻塞，鉴于这个问题可以使用异步API：KafkaConsumer#commitAsync()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofSeconds(<span class="hljs-number">1</span>));<br>    process(records); <span class="hljs-comment">// 处理消息</span><br>    consumer.commitAsync((offsets, exception) -&gt; &#123;<br>    <span class="hljs-keyword">if</span> (exception != <span class="hljs-literal">null</span>)<br>    handle(exception);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>一般会结合同步异步一起来完成位移提交的处理。</p><p>批处理的解决方式：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">private</span> <span class="hljs-built_in">Map</span>&lt;TopicPartition, OffsetAndMetadata&gt; offsets = <span class="hljs-literal">new</span> HashMap&lt;&gt;();<br>int count = <span class="hljs-number">0</span>;<br>……<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    ConsumerRecords&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt; <span class="hljs-keyword">records</span> = consumer.poll(<span class="hljs-built_in">Duration</span>.ofSeconds(<span class="hljs-number">1</span>));<br>    for (ConsumerRecord&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt; record: <span class="hljs-keyword">records</span>) &#123;<br>        process(record);  <span class="hljs-comment">// 处理消息</span><br>        offsets.put(<span class="hljs-literal">new</span> TopicPartition(record.topic(), record.partition()),<br>                   <span class="hljs-literal">new</span> OffsetAndMetadata(record.offset() + <span class="hljs-number">1</span>)；<br>       <span class="hljs-keyword">if</span>（count % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>）<br>                    consumer.commitAsync(offsets, <span class="hljs-built_in">null</span>); <span class="hljs-comment">// 回调处理逻辑是null</span><br>        count++;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-11-CommitFailedException"><a href="#4-11-CommitFailedException" class="headerlink" title="4.11 CommitFailedException"></a>4.11 CommitFailedException</h2><p>Kafka Consumer端的CommitFailedException异常处理方法 Kafka Consumer端的CommitFailedException异常是指在提交位移时出现错误或异常，通常由于消费者实例连续两次调用poll方法的时间间隔超过了预设值而导致。</p><p>异常的处理方法包括优化消息处理逻辑、调整参数值，或者使用多线程加速消费。具体建议包括缩短单条消息处理时间、增加允许下游系统消费一批消息的最大时长、减少一次性消费的消息总数以及使用多线程来加速消费。</p><p>需要注意消费者组和独立消费者在使用前都要指定group.id。如果出现设置相同group.id值的消费者组程序和独立消费者程序，可能会导致Kafka抛出CommitFailedException异常。</p><h2 id="4-12-多线程开发消费"><a href="#4-12-多线程开发消费" class="headerlink" title="4.12 多线程开发消费"></a>4.12 多线程开发消费</h2><p>谈到 Java Consumer API，最重要的当属它的入口类 KafkaConsumer 了。我们说 KafkaConsumer 是单线程的设计，严格来说这是不准确的。因为，从 Kafka 0.10.1.0 版本开始，KafkaConsumer 就变为了双线程的设计，即用户主线程和心跳线程。</p><h3 id="4-12-1-方案"><a href="#4-12-1-方案" class="headerlink" title="4.12.1 方案"></a>4.12.1 方案</h3><p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/image-20250620165240195.png"></p><p><strong>a. 方案一：</strong>对线程 + 多KafkaConsumer实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KafkaConsumerRunner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicBoolean</span> <span class="hljs-variable">closed</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>(<span class="hljs-literal">false</span>);<br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> KafkaConsumer consumer;<br><br><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-keyword">try</span> &#123;<br>             consumer.subscribe(Arrays.asList(<span class="hljs-string">&quot;topic&quot;</span>));<br>             <span class="hljs-keyword">while</span> (!closed.get()) &#123;<br>                  <span class="hljs-type">ConsumerRecords</span> <span class="hljs-variable">records</span> <span class="hljs-operator">=</span> consumer.poll(Duration.ofMillis(<span class="hljs-number">10000</span>));<br>                 <span class="hljs-comment">//  执行消息处理逻辑</span><br>             &#125;<br>         &#125; <span class="hljs-keyword">catch</span> (WakeupException e) &#123;<br>             <span class="hljs-comment">// Ignore exception if closing</span><br>             <span class="hljs-keyword">if</span> (!closed.get()) <span class="hljs-keyword">throw</span> e;<br>         &#125; <span class="hljs-keyword">finally</span> &#123;<br>             consumer.close();<br>         &#125;<br>     &#125;<br><br><br>     <span class="hljs-comment">// Shutdown hook which can be called from a separate thread</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> &#123;<br>         closed.set(<span class="hljs-literal">true</span>);<br>         consumer.wakeup();<br>     &#125;<br></code></pre></td></tr></table></figure><p><strong>b.方案二：</strong>单线程+单KafkaCOnsumenr+消息处理WOrker线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> KafkaConsumer&lt;String, String&gt; consumer;<br><span class="hljs-keyword">private</span> ExecutorService executors;<br>...<br><br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">workerNum</span> <span class="hljs-operator">=</span> ...;<br>executors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>  workerNum, workerNum, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1000</span>), <br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());<br><br><br>...<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)  &#123;<br>  ConsumerRecords&lt;String, String&gt; records = <br>    consumer.poll(Duration.ofSeconds(<span class="hljs-number">1</span>));<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> ConsumerRecord record : records) &#123;<br>    executors.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(record));<br>  &#125;<br>&#125;<br>..<br></code></pre></td></tr></table></figure><h2 id="4-13-Java-消费者是如何管理TCP连接"><a href="#4-13-Java-消费者是如何管理TCP连接" class="headerlink" title="4.13 Java 消费者是如何管理TCP连接"></a>4.13 Java 消费者是如何管理TCP连接</h2><p>TCP 连接是在调用 KafkaConsumer.poll 方法时被创建的。再细粒度地说，在 poll 方法内部有 3 个时机可以创建 TCP 连接。</p><ol><li><p>发起 FindCoordinator 请求时。</p></li><li><p>连接协调者时。</p></li><li><p>消费数据时。</p></li></ol><p>消费者程序会创建 3 类 TCP 连接：</p><ol><li>确定协调者和获取集群元数据。</li><li>连接协调者，令其执行组成员管理操作。</li><li>执行实际的消息获取。</li></ol><h2 id="4-14-消费者组消费进度监控"><a href="#4-14-消费者组消费进度监控" class="headerlink" title="4.14 消费者组消费进度监控"></a>4.14 消费者组消费进度监控</h2><p>对于Kafka消费来说，最重要的事情就是监控他们的消费进度，或者说是监控他们消费的滞后程度。这个滞后程度有个专门的名称：消费Lag或者Consumner Lag。如果滞后太多，数据可能就不在系统的页缓存中，从磁盘中获取数据会导致性能差，更加加大了滞后性（类似于马太效应）。</p><p>消费者进度如此重要，那么我们应该怎么监控呢？</p><ol><li>使用 Kafka 自带的命令行工具 kafka-consumer-groups 脚本。</li><li>使用 Kafka Java Consumer API 编程。</li><li>使用 Kafka 自带的 JMX 监控指标。</li></ol><p>未完待续……</p>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>有关于技术人的成长我想说一下</title>
    <link href="/2025/06/14/%E6%9C%89%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%9A%84%E6%88%90%E9%95%BF%E6%88%91%E6%83%B3%E8%AF%B4%E4%B8%80%E4%B8%8B/"/>
    <url>/2025/06/14/%E6%9C%89%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%9A%84%E6%88%90%E9%95%BF%E6%88%91%E6%83%B3%E8%AF%B4%E4%B8%80%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/image-20250614175522862.png"></p><h1 id="一、技术人面临的什么"><a href="#一、技术人面临的什么" class="headerlink" title="一、技术人面临的什么"></a>一、技术人面临的什么</h1><h2 id="大环境越来越差"><a href="#大环境越来越差" class="headerlink" title="# 大环境越来越差"></a># 大环境越来越差</h2><p>从软件行业的供不应求到断崖下跌，再到后来的供过于求。有很多人唱衰IT行业已经是垃圾行业，现在入IT行业就是49年入国民党。</p><p>本人从16年毕业到现在，还是认为自己有资格说一下，因为上述的经历自己切身的体验，确实现在企业的招聘要求越来越高，在我那个时候刚毕业，只要会用点前后端框架(JSP + SSH)就可以找到一份月入过W的工作，而且市场上抢着要，而现在只是单纯的会用框架，在挑选简历的时候就会被pass掉，甚至要求你十八般武艺样样精通，巴不得你前后端运维测试都一起干了。</p><p>为什么会导致现在越来越卷呢？我想说可能有下面几个原因：</p><ul><li>技术本身是生命周期，很多技术在未来的几年将会被淘汰</li><li>技术的获取渠道更加的廉价</li><li>当下的经济日渐低落的体现，企业招聘的HC越来越少</li><li>AI的双利剑，让优秀的人更优秀，极化的人才导致同级别的竞争激烈</li></ul><h2 id="方向迷失"><a href="#方向迷失" class="headerlink" title="# 方向迷失"></a># 方向迷失</h2><ul><li><p>一种迷失方向，是知而不能行。我相信很多干了多年的程序员，越发的决定自己的路是不是走错了。我和很多人聊过，我问他们你还想干当下的事么？得到反馈基本都是，我觉得我应该干XXX(比如干前端的想做后端，做后端的想做前端)、我可能要去做XXX（我不应该打工，我要求创业）。但是很可惜的是，99%的人都不会真正的改变，只是在原有的路上（那条他认为是错误的路）上一直走下去。被迫让他们继续走下去的，一定是一些客观的、无法改变的事情，比如房贷、车贷等等。</p></li><li><p>第二种迷失方向，是不知者。这些人对自己没有清晰的认知，对未来缺少明确的规划，属于走到哪算哪。一天到晚就是浑浑噩噩，为的就是公司给的卑微工资。这样的人一般都是傻乐型或者麻木型。但也许没有方向才是他们自己的方向。</p></li></ul><p>知行合一是很难的事情，而成功的人总是不断地学习并且付出实践，通过不断地试错最终达到正确的方向。</p><h2 id="无法成长"><a href="#无法成长" class="headerlink" title="# 无法成长"></a># 无法成长</h2><p>重复性的工作会导致个人会在一个圈，固定的思维方式同时也会导致无法成长。重复的CRUD、无效的沟通和扯皮等等。我一直觉得，如果你不认为3个月之前的自己像个傻n，那就是自己还是没有成长。</p><blockquote><p>上述说的三点，其中大环境我们无法改变，方向的问题因人而异，但是如何成长却可以是教科书，是有章法可循，同时也是技术人最容易做到的，因此我此文将技术成长的三个阶段、五个维度、犯错、技术之外，一一陈述。</p></blockquote><h1 id="二、技术成长的三个阶段"><a href="#二、技术成长的三个阶段" class="headerlink" title="二、技术成长的三个阶段"></a>二、技术成长的三个阶段</h1><h2 id="1-初级阶段：生存及掌握"><a href="#1-初级阶段：生存及掌握" class="headerlink" title="1. 初级阶段：生存及掌握"></a>1. 初级阶段：生存及掌握</h2><ul><li>目标：能写代码、解决问题</li><li>行为特征：堆技能点、学习框架、刷题、写需求</li><li>易犯错误：只顾眼前</li></ul><h2 id="2-中级阶段：体系和抽象"><a href="#2-中级阶段：体系和抽象" class="headerlink" title="2. 中级阶段：体系和抽象"></a>2. 中级阶段：体系和抽象</h2><ul><li>目标：设计能力、架构能力、对业务的建模能力</li><li>关键性的成长：重构、封装、性能优化、主导项目</li><li>思维转变：由能写代码到-&gt;写的优雅且可维护</li></ul><h2 id="3-高级阶段：认知和选择"><a href="#3-高级阶段：认知和选择" class="headerlink" title="3. 高级阶段：认知和选择"></a>3. 高级阶段：认知和选择</h2><ul><li>目标：判断力、技术方向感、推动力</li><li>学会做减法：不是什么都会，而是知道什么是重要</li><li>理解转化：技术不是目的，而是实现目标的手段</li></ul><h1 id="三、技术成长的五个维度"><a href="#三、技术成长的五个维度" class="headerlink" title="三、技术成长的五个维度"></a>三、技术成长的五个维度</h1><h2 id="1-宽度：业务视野要广"><a href="#1-宽度：业务视野要广" class="headerlink" title="1. 宽度：业务视野要广"></a>1. 宽度：业务视野要广</h2><ul><li>不只是Java，也得理解前端、DevOps、数据库、AI等等</li><li>系统视角 &gt; 局部细节</li></ul><h2 id="2-深度：技术能力要扎实"><a href="#2-深度：技术能力要扎实" class="headerlink" title="2. 深度：技术能力要扎实"></a>2. 深度：技术能力要扎实</h2><ul><li>了解原理：TCP底层原理、JVM底层原理、操作系统、分布式系统等</li><li>定期选择一个深入理解任务：比如固定周期，制定一个”深挖点”(如7天吃透RocketMQ底层源码)</li></ul><h2 id="3-实战：项目沉淀和总结"><a href="#3-实战：项目沉淀和总结" class="headerlink" title="3. 实战：项目沉淀和总结"></a>3. 实战：项目沉淀和总结</h2><ul><li>主导核心项目，多动手而不是说说，踩坑、抗故障等都是具体实施</li><li>遵循：编程&#x3D;沟通+建模+迭代+总结</li></ul><h2 id="4-表达：输出是技术的延伸"><a href="#4-表达：输出是技术的延伸" class="headerlink" title="4. 表达：输出是技术的延伸"></a>4. 表达：输出是技术的延伸</h2><ul><li>写技术文档、博客、内部分享、带新人</li><li>分享是学习的放大器</li></ul><h2 id="5-判断：对技术趋势的感知力"><a href="#5-判断：对技术趋势的感知力" class="headerlink" title="5. 判断：对技术趋势的感知力"></a>5. 判断：对技术趋势的感知力</h2><ul><li>拒绝技术盲点，只是片面的理解，多看多对比</li><li>看清楚趋势而不是跟风（最简单的方式就是看大厂的是否有标杆的落地的应用）</li></ul><h1 id="四、那些年犯过的错"><a href="#四、那些年犯过的错" class="headerlink" title="四、那些年犯过的错"></a>四、那些年犯过的错</h1><ul><li>学习浮躁，啥都是学习皮毛</li><li>迷信“大厂技术”，脱离业务场景、现实资源</li><li>代码洁癖重构原有稳定的功能</li><li>过度设计最终导致到处是废物代码</li><li>技术与业务割裂，做的东西没有人用</li><li>一味地追求技术复杂度，忽略了团队协助</li></ul><h1 id="五、技术之外：不可忽视的软技能"><a href="#五、技术之外：不可忽视的软技能" class="headerlink" title="五、技术之外：不可忽视的软技能"></a>五、技术之外：不可忽视的软技能</h1><ul><li><p>沟通协作能力</p></li><li><p>时间管理与持续学习能力</p></li><li><p>如何影响他人、带团队</p></li><li><p>对职业发展的规划（技术专家 vs 技术管理）</p></li></ul><blockquote><p>本人是一个普普通通的程序员，只是希望看到我博客的同学，可以少走一些弯路，同时相信自己的初心和努力，你是最棒的，与你共勉。🍷</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>思考</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基于索引增强(RAG)下的开发理论及总结</title>
    <link href="/2025/06/09/%E5%9F%BA%E4%BA%8E%E7%B4%A2%E5%BC%95%E5%A2%9E%E5%BC%BA%E4%B8%8B%E7%9A%84RAG%E5%BC%80%E5%8F%91%E7%90%86%E8%AE%BA%E6%80%BB%E7%BB%93/"/>
    <url>/2025/06/09/%E5%9F%BA%E4%BA%8E%E7%B4%A2%E5%BC%95%E5%A2%9E%E5%BC%BA%E4%B8%8B%E7%9A%84RAG%E5%BC%80%E5%8F%91%E7%90%86%E8%AE%BA%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/image-20250609183310661.png" alt="image-20250609183310661"></p><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>目前RAG还形成不了传统意义上的开发范式，它是类似一个应用的框架或者开发思维，是一种结合<strong>外部知识检索（Indexing&#x2F;Retrieval）</strong>和<strong>语言生成模型（LLM）</strong>的方法，用于提高生成回答的实时性和上下文相关性，是解决大语言幻觉的工具。</p><h1 id="2-大语言幻觉"><a href="#2-大语言幻觉" class="headerlink" title="2. 大语言幻觉"></a>2. 大语言幻觉</h1><blockquote><p>大语言会出现幻觉，存在事实性幻觉和忠实性幻觉，表现为对事实的捏造、事实不一致、偏离用户指令、上下文不一致、逻辑不一致等</p></blockquote><h2 id="2-1-产生的原因"><a href="#2-1-产生的原因" class="headerlink" title="2.1 产生的原因"></a>2.1 产生的原因</h2><p>产生幻觉的原因可以分为以下三大来源：<code>数据源</code>——&gt;<code>训练过程</code>——&gt;<code>推理</code></p><ul><li><strong>数据</strong>是大模型的粮食，错误信息和偏见的输入，大模型本身存在的知识边界，一些过时的事实知识</li><li>在<strong>模型的预训练阶段</strong>：前一个token预测下一个token，随着token的增长导致注意力被稀释，错误的token也会导致发生联级错误</li><li>在<strong>模型的对齐阶段</strong>：标注的数据超出了大语言本身的能力，会被训练会为超过边界的知识内容，从而放大了幻觉。二是模型的倾向迎合人类的偏好，从而牺牲了信息的真实性</li><li><strong>推理</strong>导致的幻觉：由于推理是概率生成，上下文关注不足，例如softmax瓶颈都会导致生成偏差</li></ul><p>⭐️<u>从涌现&#x2F;创新的角度，大语言产生的<strong>幻觉不会彻底被解决</strong>，如果失去了幻觉，那么大语言模型就无法成长，成为一个只能读取老旧数据的仓储</u></p><h2 id="2-2-幻觉的缓解"><a href="#2-2-幻觉的缓解" class="headerlink" title="2.2 幻觉的缓解"></a>2.2 幻觉的缓解</h2><p>缓解幻觉的方案有很多比如：涵盖调整模型参数、外挂知识、多智能体互动、加入诚实样本</p><p>其实最好的方式就是直接使用收集高质量的事实数据，并消除数据的偏见，并且在训练、对齐、推理阶段做模型本身的调整，但是一般这样的方式成本很高</p><p>所以这里就引入了RAG(索引增强生成)，没错RAG是比较低级（低成本）的一种解决方案，但是它对开发出预期的应用很有效。</p><h1 id="3-RAG简述"><a href="#3-RAG简述" class="headerlink" title="3. RAG简述"></a>3. RAG简述</h1><h3 id="3-1-什么是RAG"><a href="#3-1-什么是RAG" class="headerlink" title="3.1 什么是RAG"></a>3.1 什么是RAG</h3><p>索引增强生成（RAG）是在大模型生成响应之前，引用训练数据之外的权威知识库，对原有训练数据的扩展，所以不用重新训练模型的情况下，可以保持回答的相关性、准确性和实用性。</p><p>简单理解就是：在发起提问之前，先从外部检索对应的知识，和用户的提问一起构成Prompt，再让LLM生成内容。</p><blockquote><p>其实到目前为止，主流的大模型已经可以直接或者间接，通过爬取网页的数据、Function Call、MCP来增强自己，详见ChatGPT 工具-&gt;搜索网页</p></blockquote><h3 id="3-1-RAG的类型"><a href="#3-1-RAG的类型" class="headerlink" title="3.1 RAG的类型"></a>3.1 RAG的类型</h3><p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/image-20250609175909753.png" alt="RAG的三种类型"></p><p>a) 一次性检索，b) 迭代索引，c) 事后索引</p><p>现在主流的方式是使用一次性检索</p><h1 id="4-原理流程图"><a href="#4-原理流程图" class="headerlink" title="4. 原理流程图"></a>4. 原理流程图</h1><p>如下:</p><p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/%E8%AE%BE%E8%AE%A1.drawio.png" alt="实现原理流程图"></p><p>实际在代码中，无论多么复杂的 RAG、无论如何进行 RAG 优化，**本质上都是执行外部检索，然后将外部检索的内容和用户原始提问合并成最终 Prompt，再向大语言模型发起提问，最终得到对应的内容 **。</p><h1 id="5-RAG开发优化策略"><a href="#5-RAG开发优化策略" class="headerlink" title="5. RAG开发优化策略"></a>5. RAG开发优化策略</h1><p>在RAG开发的6个阶段中，不同的阶段拥有不同的优化策略，需要针对不同的应用进行特定性的优化，</p><p>目前市面上常见的优化方案有：<code>问题转换</code>、<code>多路召回</code>、<code>混合检索</code>、<code>搜索重排</code>、<code>动态路由</code>、图查询、<code>问题重建</code>、<code>自检索</code>等数十种优化策略，每种策略所在的阶段并不一致，效果也有差异，并且相互影响。</p><p>并且RAG优化和LangChain并没有关系，无论使用任何框架、任何编程语言，进行RAG开发时，掌握优化的思路才是最重要的！</p><p>将对应的优化策略整理到RAG运行流程中，优化策略与开发阶段对应图如下：</p><p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/image-20250609183051464.png" alt="RAG开发优化策略"></p><h1 id="6-专业词汇"><a href="#6-专业词汇" class="headerlink" title="6. 专业词汇"></a>6. 专业词汇</h1><ul><li><p>DocumentLoader: 文档加载、转化器</p></li><li><p>词分割器、语义分割器</p></li><li><p>Embedding：嵌入转化向量</p></li><li><p>vectorStore 向量数据库</p></li><li><p>Retriever检索又名召回</p></li><li><p>prompt提示词</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>AI学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>redis 8.0新版本发布</title>
    <link href="/2025/06/08/redis%208.0%E6%96%B0%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/"/>
    <url>/2025/06/08/redis%208.0%E6%96%B0%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</url>
    
    <content type="html"><![CDATA[<p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/%E9%A2%84%E8%A7%88-2025-06-08-jL3b7QXt@2x.png" alt="预览-2025-06-08-jL3b7QXt@2x"></p><p>传送门: <a href="https://github.com/redis/redis/tree/8.0.0">https://github.com/redis/redis/tree/8.0.0</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>redis在5月2号发布了最新版本8.0.0，这个新的版本带来完全开源的消息。之前的一个版本还是7.4.2，突然升级一下大版本，肯定是做了巨大的改变，也事实如此。下边我们一起看一下，具体有哪些新特性.</p><h1 id="相比上个7-4-2的改变"><a href="#相比上个7-4-2的改变" class="headerlink" title="相比上个7.4.2的改变"></a>相比上个7.4.2的改变</h1><ul><li><p>redis社区版本目前修改名字为redis开源</p></li><li><p>开源许可发生改变</p><ul><li>(a) Redis源代码可用许可协议2.0（RSALv2）</li><li>(b) 服务器端公共许可证v1（SSPLv1）</li><li>(c) GNU通用公共许可证（AGPLv3）</li></ul></li><li><p>新的redis查询引擎和8种数据结构的引入</p><ul><li>（1）redis查询引擎，现在支持查询高阶向量</li><li>（2）可查询的JSON文档（类似JsonPath操作）</li><li>（3）时间序列</li><li>（4-8）<strong>五种概率数据结构</strong>：布隆过滤器、布谷鸟过滤器、计数-最小草图、Tok-k和 t-digest</li><li>（9）**向量集(Vector set)[beta]**，支持向量的相似查询和智能排序</li><li>以上这9种组件全部在发新版本二进制文件中</li><li>可以参考README.md文件构建编译上述的9个组件</li><li>新的配置文件：redis-full.conf。用于配置所有的组件</li><li>由于新加了组件，ACL也同时新增了：<code>@search</code>, <code>@json</code>, <code>@timeseries</code>, <code>@bloom</code>, <code>@cuckoo</code>, <code>@cms</code>, <code>@topk</code>, <code>@tdigest</code> (安全问题的处理)、@READ、@Write</li><li>30+性能和资源利用率提升<img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/%E9%A2%84%E8%A7%88-2025-06-08-DmXiNXVM@2x.png" alt="预览-2025-06-08-DmXiNXVM@2x"><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/%E9%A2%84%E8%A7%88-2025-06-08-7DqeSqQE@2x.png" alt="预览-2025-06-08-7DqeSqQE@2x"></li></ul></li><li><p>引入新的I&#x2F;O线程模型，可在多核环境中的链接性能，提升吞吐量</p></li><li><p>引入更加高效和健壮性的副本复制机制</p></li><li><p>新的Hash命令：HGETDEL,HGETEX,HSETEX （Hash键的过期特性）</p></li></ul><h1 id="Redis-8-的版本出现的意义"><a href="#Redis-8-的版本出现的意义" class="headerlink" title="Redis 8 的版本出现的意义"></a>Redis 8 的版本出现的意义</h1><p>redis 8 的发布重新定义了游戏规则，回归开源来换得开源社区的支持，redis在市场上一直不讨好，市场上的肉都被云服务商吃掉了，redis本身的设计并不复杂，云服务商的开发成本很低，原有的开源+闭源模式完全打不过云服务商，开源是redis唯一的道路，此次开源相信会对redis社区发展壮大做出积极的意义。</p>]]></content>
    
    
    <categories>
      
      <category>新闻</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LangChain框架初探-基础及实践篇</title>
    <link href="/2025/05/22/LangChain%E6%A1%86%E6%9E%B6%E5%88%9D%E6%8E%A2-%E5%9F%BA%E7%A1%80%E7%AF%87%E5%AE%9E%E8%B7%B5%E7%AF%87/"/>
    <url>/2025/05/22/LangChain%E6%A1%86%E6%9E%B6%E5%88%9D%E6%8E%A2-%E5%9F%BA%E7%A1%80%E7%AF%87%E5%AE%9E%E8%B7%B5%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>LangChain</code>是大语言模型应用快速搭建的框架，目前官网提出了Python和JS版本（<a href="https://github.com/langchain4j/langchain4j?tab=readme-ov-file">Java版本</a> 在github上有翻版，对比官方还是差点，后续会单独聊），目前对LangChain的技术博客不算很多，这里通过自己的思考+接合官方文档做一个输出，也是对自己思考的留痕方便后续查漏补缺。</p><h2 id="什么是LangChain？"><a href="#什么是LangChain？" class="headerlink" title="什么是LangChain？"></a>什么是<code>LangChain</code>？</h2><p>在 <a href="https://www.langchain.com/">官网</a>上对它用途介绍是:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">LangChain simplifies <span class="hljs-keyword">every</span> stage <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> LLM <span class="hljs-built_in">application</span> lifecycle<br></code></pre></td></tr></table></figure><p>翻译过来就是说LangChain简化了LLM应用生命周期的每个阶段</p><p>对开发大模型的段官网定义有三个，分别是：开发、产品化、部署。这里简单画图帮助理解：</p><img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/langchain_stack_062024.svg" style="display: block; margin-left: 0;" /><ul><li><p>紫色部分是<code>LangChain</code>官方平台:  </p><ul><li><code>LangGraph Platfrom</code>并且提供了基础设施，可用于快速部署Agent应用</li><li><code>LangSmith</code>更好的跟踪<code>LangChain</code>应用, 提供可观察性、评估及提示工程</li></ul></li><li><p>黑色和墨绿色部分:</p><ul><li><code>LangChain</code>模块是核心模块，是所有开发的基石，是所有开发LLM开发的基本抽象，并且支持链式调用</li><li><code>LangGraph</code>是一个中底级别的编排框架，在LangChain基础上用于构造、管理、部署长时间有状态的代理应用</li><li><code>Integrations</code>LangChain对业务的价值都体现在这，可以快速接入所有主流的大模型以及基础设施层的实现</li></ul></li></ul><h2 id="为什么要学习并使用LangChain？"><a href="#为什么要学习并使用LangChain？" class="headerlink" title="为什么要学习并使用LangChain？"></a>为什么要学习并使用LangChain？</h2><p>主要是有几个方面: <code>认可度</code>、<code>持续维度度</code>、<code>易用性</code>、<code>可扩展性</code>、<code>稳定版本</code>、<code>可观性</code></p><ul><li><p>首先虽然目前的大模型开发一般都有官方提供的SKD，但是接入没有一个标准，开发起来很混乱，会一直不断的重复造轮子。LangChain的出现解决了这个问题，它大而全的接纳了所有大语言开发，做到了真正意思上的统一，通过几行代码就能实现复杂的AI相关的开发。</p></li><li><p>其次从自身的角度看，再牛X的程序员也要拥抱变化，AI是大势所趋，学习主流的技术才会永远不被淘汰，紧赶世界的步伐才能不断的成长。</p></li><li><p>也有人唱衰LangChain，说技术变化如此之快的年代，用 LangChain 来构建一切根本行不通，但是我觉得只要一个框架：</p><ol><li>是开源的(star高)</li><li>不断有人维护</li><li>顺应现在主流</li></ol><p>如果有任意两个特点就可以学习，然而明显LangChain三个都满足，所以不用担心是否过时过快。</p></li></ul><h2 id="应用场景列举"><a href="#应用场景列举" class="headerlink" title="应用场景列举"></a>应用场景列举</h2><ul><li>智能回答系统(RAG)：基于文档&#x2F;数据库&#x2F;网页的智能回答</li><li>多轮对话roboot：实现AI的长期记忆、保持用户上下文</li><li>智能代理(Agent)：自主完成任务分析和工具调用（人类、AI，主、副驾驶舱模式）</li><li>AI智能编辑助手：提供代码TAB,  代码解释等</li><li>多模态应用：图文对话、图文生成</li></ul><h1 id="二、LangChain核心概念"><a href="#二、LangChain核心概念" class="headerlink" title="二、LangChain核心概念"></a>二、LangChain核心概念</h1><p>这里更加聚焦于产品的视角，诠释LangChain的核心概念</p><p> <img src="https://liual-image.oss-cn-chengdu.aliyuncs.com/uPic/image-20250523141838108.png" alt="image-20250523141838108"></p><h4 id="Models（模型）："><a href="#Models（模型）：" class="headerlink" title="Models（模型）："></a><strong>Models（模型）</strong>：</h4><p>提供了与各种语言模型（如 OpenAI 的 GPT-3、GPT-4, Hugging Face 的模型等）交互的接口。它支持模型的加载、配置和使用，使得开发者可以轻松地将这些模型集成到自己的应用中。</p><h4 id="Chains（链）："><a href="#Chains（链）：" class="headerlink" title="Chains（链）："></a><strong>Chains（链）</strong>：</h4><p>Chains 模块允许开发者构建一系列步骤，这些步骤可以串联起来处理数据。例如，你可以创建一个链，其中包含数据预处理、模型预测、结果解释等步骤。有助于将复杂的任务分解为更小、更易管理的部分</p><h4 id="Prompts（提示词）："><a href="#Prompts（提示词）：" class="headerlink" title="Prompts（提示词）："></a><strong>Prompts（提示词）</strong>：</h4><p>这个模块提供了创建和管理提示（prompts）的工具。提示词是输入到语言模型中的预设文本，通过此模块能快速生成提示词用于初始化聊天上下文。</p><h4 id="Memory（记忆）："><a href="#Memory（记忆）：" class="headerlink" title="Memory（记忆）："></a><strong>Memory（记忆）</strong>：</h4><p>记忆模块用于在多个请求或对话之间保持上下文。这对于需要持续对话的场景特别有用，例如聊天机器人或虚拟助手。它可以帮助模型记住之前的对话内容，从而提供更加连贯和个性化的响应</p><h4 id="Indexes（索引模块）："><a href="#Indexes（索引模块）：" class="headerlink" title="Indexes（索引模块）："></a><strong>Indexes（索引模块）</strong>：</h4><p>Indexes 模块允许开发者将外部数据源（如文档、数据库、知识库等）与 LLM 集成。这通过创建索引来实现，使得 LLM 可以访问并利用这些外部数据源中的信息来生成回答或完成任务</p><h4 id="Agents（代理模块）："><a href="#Agents（代理模块）：" class="headerlink" title="Agents（代理模块）："></a><strong>Agents（代理模块）</strong>：</h4><p>Agents 模块允许创建智能体，这些智能体可以自主地与外部世界交互，并根据需要选择合适的工具或模型来执行任务。智能体可以执行复杂的任务，例如搜索信息、调用外部 API、执行复杂的逻辑决策等。</p><h1 id="三、LangChain模块"><a href="#三、LangChain模块" class="headerlink" title="三、LangChain模块"></a>三、LangChain模块</h1><h4 id="langchain-core"><a href="#langchain-core" class="headerlink" title="langchain-core"></a><code>langchain-core</code></h4><p>该包包含不同组件的基本抽象以及将它们组合在一起的方法。 核心组件的接口，如大型语言模型、向量存储、检索器等在此定义。 此处未定义任何第三方集成。 依赖项故意保持非常轻量级。</p><h4 id="langchain"><a href="#langchain" class="headerlink" title="langchain"></a><code>langchain</code></h4><p>主要的 <code>langchain</code> 包含链、代理和检索策略，这些构成了应用程序的认知架构。 这些不是第三方集成。 这里的所有链、代理和检索策略并不特定于任何一个集成，而是适用于所有集成的通用策略。</p><h4 id="langchain-community"><a href="#langchain-community" class="headerlink" title="langchain-community"></a><code>langchain-community</code></h4><p>此包包含由 <code>LangChain</code> 社区维护的第三方集成。 关键的合作伙伴包， 这包含了各种组件（大型语言模型、向量存储、检索器）的所有集成。 此包中的所有依赖项都是可选的，以保持包尽可能轻量。</p><h1 id="四、组件使用及技巧"><a href="#四、组件使用及技巧" class="headerlink" title="四、组件使用及技巧"></a>四、组件使用及技巧</h1><h4 id="1）Prompt组件及使用技巧"><a href="#1）Prompt组件及使用技巧" class="headerlink" title="1）Prompt组件及使用技巧"></a>1）Prompt组件及使用技巧</h4><p>使用langchain_core.prompts下的工具包，可以根据模板生成一个提示词，通过管理模板进行复用提示词</p><ul><li><h5 id="Prompt组件基础用法"><a href="#Prompt组件基础用法" class="headerlink" title="Prompt组件基础用法"></a>Prompt组件基础用法</h5></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Time   : 2025/5/18 12:50</span><br><span class="hljs-string">@Author : liual</span><br><span class="hljs-string">@File   : 1.Prompt组件基础用法.py</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br><span class="hljs-keyword">from</span> langchain_core.messages <span class="hljs-keyword">import</span> AIMessage<br><span class="hljs-keyword">from</span> langchain_core.prompts <span class="hljs-keyword">import</span> (<br>    PromptTemplate,<br>    ChatPromptTemplate,<br>    HumanMessagePromptTemplate, MessagesPlaceholder)<br><br>prompt = PromptTemplate.from_template(<span class="hljs-string">&quot;请将一个关于&#123;subject&#125;的冷笑话&quot;</span>)<br><span class="hljs-built_in">print</span>(prompt.<span class="hljs-built_in">format</span>(subject=<span class="hljs-string">&quot;程序员&quot;</span>))<br>prompt_value = prompt.invoke(&#123;<span class="hljs-string">&quot;subject&quot;</span>: <span class="hljs-string">&quot;程序员&quot;</span>&#125;)<br><span class="hljs-built_in">print</span>(prompt_value.to_string())<br><span class="hljs-built_in">print</span>(prompt_value.to_messages())<br>chat_prompt = ChatPromptTemplate.from_messages([<br>    (<span class="hljs-string">&quot;system&quot;</span>, <span class="hljs-string">&quot;你是DeepSeek开发的聊天机器人，请根据用户的提问进行回复，当前时间为：&#123;now&#125;&quot;</span>),<br>    MessagesPlaceholder(<span class="hljs-string">&quot;chat_history&quot;</span>),<br>    HumanMessagePromptTemplate.from_template(<span class="hljs-string">&quot;请讲一个关于&#123;subject&#125;的冷笑话&quot;</span>)<br>]).partial(now=datetime.now())<br>chat_prompt_value = chat_prompt.invoke(&#123;<br>    <span class="hljs-string">&quot;chat_history&quot;</span>: [<br>        (<span class="hljs-string">&quot;human&quot;</span>, <span class="hljs-string">&quot;我叫刘小帅&quot;</span>),<br>        AIMessage(<span class="hljs-string">&quot;你好，我是DeepSeek，有什么可以帮助你&quot;</span>)<br>    ],<br>    <span class="hljs-string">&quot;subject&quot;</span>: <span class="hljs-string">&quot;程序员&quot;</span><br>&#125;)<br><span class="hljs-built_in">print</span>(chat_prompt_value)<br><span class="hljs-built_in">print</span>(chat_prompt_value.to_string())<br></code></pre></td></tr></table></figure><ul><li><h5 id="消息提示词模板拼接"><a href="#消息提示词模板拼接" class="headerlink" title="消息提示词模板拼接"></a>消息提示词模板拼接</h5></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Time   : 2025/5/18 13:29</span><br><span class="hljs-string">@Author : liual</span><br><span class="hljs-string">@File   : 3. 消息提示词模板拼接.py</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> langchain_core.prompts <span class="hljs-keyword">import</span> ChatPromptTemplate<br><br>system_chat_prompt = ChatPromptTemplate.from_messages([<br>    (<span class="hljs-string">&quot;system&quot;</span>, <span class="hljs-string">&quot;你是深度求索开发的聊天机器人，请根据用户的提问进行回复，我叫&#123;username&#125;&quot;</span>)<br>])<br><br>human_chat_prompt = ChatPromptTemplate.from_messages(<br>    (<span class="hljs-string">&quot;human&quot;</span>, <span class="hljs-string">&quot;&#123;query&#125;&quot;</span>)<br>)<br><br>chat_prompt = system_chat_prompt + human_chat_prompt<br><br><span class="hljs-built_in">print</span>(chat_prompt.invoke(&#123;<br>    <span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;DeepSeek&quot;</span>,<br>    <span class="hljs-string">&quot;query&quot;</span>: <span class="hljs-string">&quot;hello, its me&quot;</span><br>&#125;))<br></code></pre></td></tr></table></figure><h4 id="2）Model组件及使用技巧"><a href="#2）Model组件及使用技巧" class="headerlink" title="2）Model组件及使用技巧"></a>2）Model组件及使用技巧</h4><ul><li><h5 id="Model流式输出"><a href="#Model流式输出" class="headerlink" title="Model流式输出"></a>Model流式输出</h5></li></ul><p>其实可以接入基本上当前市场上的所有主流大模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Time   : 2025/5/18 14:41</span><br><span class="hljs-string">@Author : liual</span><br><span class="hljs-string">@File   : 3. Model流式输出.py</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br><span class="hljs-keyword">import</span> dotenv<br><span class="hljs-keyword">from</span> langchain_core.prompts <span class="hljs-keyword">import</span> ChatPromptTemplate<br><span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> ChatOpenAI<br><br>dotenv.load_dotenv()<br>chat_prompt = ChatPromptTemplate.from_messages([<br>    (<span class="hljs-string">&quot;system&quot;</span>, <span class="hljs-string">&quot;你是深度求索开发的聊天机器人，请回答用户的问题，现在的时间是&#123;now&#125;&quot;</span>),<br>    (<span class="hljs-string">&quot;human&quot;</span>, <span class="hljs-string">&quot;&#123;query&#125;&quot;</span>),<br>]).partial(now=datetime.now)<br><br>llm = ChatOpenAI(base_url=os.getenv(<span class="hljs-string">&quot;OPENAI_URL&quot;</span>), model=<span class="hljs-string">&quot;deepseek-reasoner&quot;</span>)<br><br>response = llm.stream(chat_prompt.invoke(&#123;<span class="hljs-string">&quot;query&quot;</span>: <span class="hljs-string">&quot;你能简单介绍一下LLM和LLMOps么&quot;</span>&#125;))<br><br><span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> response:<br>    <span class="hljs-built_in">print</span>(chunk.content, flush=<span class="hljs-literal">True</span>, end=<span class="hljs-string">&quot;&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="3）OutPutParser使用技巧"><a href="#3）OutPutParser使用技巧" class="headerlink" title="3）OutPutParser使用技巧"></a>3）OutPutParser使用技巧</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Time   : 2025/5/18 15:46</span><br><span class="hljs-string">@Author : liual</span><br><span class="hljs-string">@File   : 2.JsonOutPutParser使用技巧.py</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">import</span> dotenv<br><span class="hljs-keyword">from</span> langchain_core.output_parsers <span class="hljs-keyword">import</span> JsonOutputParser<br><span class="hljs-keyword">from</span> langchain_core.prompts <span class="hljs-keyword">import</span> ChatPromptTemplate<br><span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> ChatOpenAI<br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel, Field<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Joke</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    joke: <span class="hljs-built_in">str</span> = Field(description=<span class="hljs-string">&quot;回答用户的冷笑话&quot;</span>)<br>    punchline: <span class="hljs-built_in">str</span> = Field(description=<span class="hljs-string">&quot;这个笑话的笑点&quot;</span>)<br><br><br>dotenv.load_dotenv()<br>parser = JsonOutputParser(pydantic_object=Joke)<br><br>prompt = ChatPromptTemplate.from_template(<span class="hljs-string">&quot;&quot;&quot;请根据用户提问的请求进行回答</span><br><span class="hljs-string">&#123;format_instructions&#125;</span><br><span class="hljs-string">&#123;query&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span>).partial(format_instructions=parser.get_format_instructions())<br><br><span class="hljs-comment"># print(prompt.format(query=&quot;请讲一个程序员的冷笑话&quot;))</span><br><br>llm = ChatOpenAI(base_url=os.getenv(<span class="hljs-string">&quot;OPENAI_URL&quot;</span>), model=<span class="hljs-string">&quot;deepseek-reasoner&quot;</span>)<br>joke = parser.invoke(llm.invoke(prompt.invoke(&#123;<span class="hljs-string">&quot;query&quot;</span>: <span class="hljs-string">&quot;请讲一个程序员的冷笑话&quot;</span>&#125;)))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(joke))<br><span class="hljs-built_in">print</span>(joke.get(<span class="hljs-string">&quot;punchline&quot;</span>))<br><span class="hljs-built_in">print</span>(joke)<br></code></pre></td></tr></table></figure><h4 id="4）LCEL表达式与Runnable可运行协议"><a href="#4）LCEL表达式与Runnable可运行协议" class="headerlink" title="4）LCEL表达式与Runnable可运行协议"></a>4）LCEL表达式与Runnable可运行协议</h4><p>LangChain中引入<code>RunnableSerializable</code>来支持LCEL表达式调用，方便开发，通过chain &#x3D; prompt | llm | parser 直接调用，解决类回调地狱的问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Time   : 2025/5/18 17:12</span><br><span class="hljs-string">@Author : liual</span><br><span class="hljs-string">@File   : 2.LCEL表达式简化版本.py</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">import</span> dotenv<br><span class="hljs-keyword">from</span> langchain_core.output_parsers <span class="hljs-keyword">import</span> StrOutputParser<br><span class="hljs-keyword">from</span> langchain_core.prompts <span class="hljs-keyword">import</span> ChatPromptTemplate<br><span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> ChatOpenAI<br><br>dotenv.load_dotenv()<br><br>prompt = ChatPromptTemplate.from_template(<span class="hljs-string">&quot;&#123;query&#125;&quot;</span>)<br>llm = ChatOpenAI(base_url=os.getenv(<span class="hljs-string">&quot;OPENAI_URL&quot;</span>), model=<span class="hljs-string">&quot;deepseek-reasoner&quot;</span>)<br>parser = StrOutputParser()<br><br>chain = prompt | llm | parser<br><br>ai_message = chain.invoke(&#123;<span class="hljs-string">&quot;query&quot;</span>: <span class="hljs-string">&quot;请讲一个程序员的冷笑话&quot;</span>&#125;)<br><br><span class="hljs-keyword">for</span> output <span class="hljs-keyword">in</span> ai_message:<br>    <span class="hljs-built_in">print</span>(output, flush=<span class="hljs-literal">True</span>, end=<span class="hljs-string">&quot;&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="5）利用回调功能调试链应用-让过程更加透明"><a href="#5）利用回调功能调试链应用-让过程更加透明" class="headerlink" title="5）利用回调功能调试链应用-让过程更加透明"></a>5）利用回调功能调试链应用-让过程更加透明</h4><p>LangChain的BaseCallbackHandler提供组件调用生命周期的钩子，方便使用者在特定的实际编制入自己的逻辑，比如日志跟踪、事件处理等等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Time   : 2025/5/18 19:52</span><br><span class="hljs-string">@Author : liual</span><br><span class="hljs-string">@File   : 1.回调功能使用技巧.py</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Any</span>, <span class="hljs-type">Optional</span>, <span class="hljs-type">Union</span><br><span class="hljs-keyword">from</span> uuid <span class="hljs-keyword">import</span> UUID<br><br><span class="hljs-keyword">import</span> dotenv<br><span class="hljs-keyword">from</span> langchain <span class="hljs-keyword">import</span> ChatOpenAI<br><span class="hljs-keyword">from</span> langchain_core.callbacks <span class="hljs-keyword">import</span> StdOutCallbackHandler, BaseCallbackHandler<br><span class="hljs-keyword">from</span> langchain_core.messages <span class="hljs-keyword">import</span> BaseMessage<br><span class="hljs-keyword">from</span> langchain_core.output_parsers <span class="hljs-keyword">import</span> StrOutputParser<br><span class="hljs-keyword">from</span> langchain_core.outputs <span class="hljs-keyword">import</span> GenerationChunk, ChatGenerationChunk, LLMResult<br><span class="hljs-keyword">from</span> langchain_core.prompts <span class="hljs-keyword">import</span> ChatPromptTemplate<br><span class="hljs-keyword">from</span> langchain_core.runnables <span class="hljs-keyword">import</span> RunnablePassthrough<br><br>dotenv.load_dotenv()<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LLMOpsCallbackHandler</span>(<span class="hljs-title class_ inherited__">BaseCallbackHandler</span>):<br>    start_at: <span class="hljs-built_in">float</span> = <span class="hljs-number">0</span><br>    end_at: <span class="hljs-built_in">float</span> = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_chat_model_start</span>(<span class="hljs-params"></span><br><span class="hljs-params">            self,</span><br><span class="hljs-params">            serialized: <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>],</span><br><span class="hljs-params">            messages: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">list</span>[BaseMessage]],</span><br><span class="hljs-params">            *,</span><br><span class="hljs-params">            run_id: UUID,</span><br><span class="hljs-params">            parent_run_id: <span class="hljs-type">Optional</span>[UUID] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">            tags: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">list</span>[<span class="hljs-built_in">str</span>]] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">            metadata: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>]] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">            **kwargs: <span class="hljs-type">Any</span>,</span><br><span class="hljs-params">    </span>) -&gt; <span class="hljs-type">Any</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;聊天模型开始执行了&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;serialized: &quot;</span>, serialized)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;messages: &quot;</span>, messages)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_llm_new_token</span>(<span class="hljs-params"></span><br><span class="hljs-params">            self,</span><br><span class="hljs-params">            token: <span class="hljs-built_in">str</span>,</span><br><span class="hljs-params">            *,</span><br><span class="hljs-params">            chunk: <span class="hljs-type">Optional</span>[<span class="hljs-type">Union</span>[GenerationChunk, ChatGenerationChunk]] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">            run_id: UUID,</span><br><span class="hljs-params">            parent_run_id: <span class="hljs-type">Optional</span>[UUID] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">            **kwargs: <span class="hljs-type">Any</span>,</span><br><span class="hljs-params">    </span>) -&gt; <span class="hljs-type">Any</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;token 生成了&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;token: &quot;</span>, token)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_llm_start</span>(<span class="hljs-params"></span><br><span class="hljs-params">            self,</span><br><span class="hljs-params">            serialized: <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>],</span><br><span class="hljs-params">            prompts: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">str</span>],</span><br><span class="hljs-params">            *,</span><br><span class="hljs-params">            run_id: UUID,</span><br><span class="hljs-params">            parent_run_id: <span class="hljs-type">Optional</span>[UUID] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">            tags: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">list</span>[<span class="hljs-built_in">str</span>]] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">            metadata: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>]] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">            **kwargs: <span class="hljs-type">Any</span>,</span><br><span class="hljs-params">    </span>) -&gt; <span class="hljs-type">Any</span>:<br>        <span class="hljs-variable language_">self</span>.start_at = time.time()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_llm_end</span>(<span class="hljs-params"></span><br><span class="hljs-params">            self,</span><br><span class="hljs-params">            response: LLMResult,</span><br><span class="hljs-params">            *,</span><br><span class="hljs-params">            run_id: UUID,</span><br><span class="hljs-params">            parent_run_id: <span class="hljs-type">Optional</span>[UUID] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">            **kwargs: <span class="hljs-type">Any</span>,</span><br><span class="hljs-params">    </span>) -&gt; <span class="hljs-type">Any</span>:<br>        <span class="hljs-variable language_">self</span>.end_at = time.time()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;llm返回了，共记：<span class="hljs-subst">&#123;self.end_at - self.start_at&#125;</span>&quot;</span>)<br><br><br>prompt = ChatPromptTemplate.from_template(<span class="hljs-string">&quot;&#123;query&#125;&quot;</span>)<br>llm = ChatOpenAI(base_url=os.getenv(<span class="hljs-string">&quot;OPENAI_URL&quot;</span>), model=<span class="hljs-string">&quot;deepseek-chat&quot;</span>)<br>parser = StrOutputParser()<br><br>chain = &#123;<br>            <span class="hljs-string">&quot;query&quot;</span>: RunnablePassthrough()<br>        &#125; | prompt | llm | parser<br><br>ai_message = chain.invoke(<span class="hljs-string">&quot;你好，你是谁?&quot;</span>, config=&#123;<span class="hljs-string">&quot;callbacks&quot;</span>: [StdOutCallbackHandler(), LLMOpsCallbackHandler()]&#125;)<br><br><span class="hljs-built_in">print</span>(ai_message)<br></code></pre></td></tr></table></figure><h4 id="6）通过缓冲摘要窗孔记忆"><a href="#6）通过缓冲摘要窗孔记忆" class="headerlink" title="6）通过缓冲摘要窗孔记忆"></a>6）通过缓冲摘要窗孔记忆</h4><p>因为大模型每次都是新生成会话，所以如果要连贯的跟大模型对话，要带上历史消息，现在最好的实践就是窗口记忆+丢失消息进行摘要</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Time   : 2025/5/22 17:30</span><br><span class="hljs-string">@Author : liual</span><br><span class="hljs-string">@File   : 1.缓冲窗孔记忆示例.py</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> itemgetter<br><br><span class="hljs-keyword">import</span> dotenv<br><span class="hljs-keyword">from</span> langchain.memory <span class="hljs-keyword">import</span> ConversationBufferWindowMemory<br><span class="hljs-keyword">from</span> langchain_core.output_parsers <span class="hljs-keyword">import</span> StrOutputParser<br><span class="hljs-keyword">from</span> langchain_core.prompts <span class="hljs-keyword">import</span> ChatPromptTemplate, MessagesPlaceholder<br><span class="hljs-keyword">from</span> langchain_core.runnables <span class="hljs-keyword">import</span> RunnablePassthrough, RunnableLambda<br><span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> ChatOpenAI<br><br>dotenv.load_dotenv()<br>llm = ChatOpenAI(base_url=os.getenv(<span class="hljs-string">&quot;OPENAI_URL&quot;</span>), model=<span class="hljs-string">&quot;deepseek-chat&quot;</span>)<br><br>prompt = ChatPromptTemplate.from_messages([<br>    (<span class="hljs-string">&quot;system&quot;</span>, <span class="hljs-string">&quot;你是deepseek开发的聊天机器人，请根据对应的上下文回复用户问题&quot;</span>),<br>    MessagesPlaceholder(<span class="hljs-string">&quot;history&quot;</span>),<br>    (<span class="hljs-string">&quot;human&quot;</span>, <span class="hljs-string">&quot;&#123;query&#125;&quot;</span>)<br>])<br><br>memory = ConversationBufferWindowMemory(<br>    k=<span class="hljs-number">2</span>,<br>    return_messages=<span class="hljs-literal">True</span>,<br>    input_key=<span class="hljs-string">&quot;query&quot;</span>,<br>)<br><br>chain = RunnablePassthrough.assign(<br>    history=RunnableLambda(memory.load_memory_variables) | itemgetter(<span class="hljs-string">&quot;history&quot;</span>),<br>) | prompt | llm | StrOutputParser()<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    query = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;Human:&quot;</span>)<br><br>    <span class="hljs-keyword">if</span> query == <span class="hljs-string">&quot;q&quot;</span>:<br>        exit(<span class="hljs-number">0</span>)<br><br>    chain_input = &#123;<span class="hljs-string">&quot;query&quot;</span>: query, <span class="hljs-string">&quot;history&quot;</span>: []&#125;<br>    response = chain.stream(chain_input)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;AI:&quot;</span>, flush=<span class="hljs-literal">True</span>, end=<span class="hljs-string">&quot;&quot;</span>)<br>    out_put = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> response:<br>        out_put += chunk<br>        <span class="hljs-built_in">print</span>(chunk, flush=<span class="hljs-literal">True</span>, end=<span class="hljs-string">&quot;&quot;</span>)<br>    memory.save_context(chain_input, &#123;<span class="hljs-string">&quot;output&quot;</span>: out_put&#125;)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;history: &quot;</span>, memory.load_memory_variables(&#123;&#125;))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>AI学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>高斯数据库使用手册</title>
    <link href="/2024/07/21/%E9%AB%98%E6%96%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    <url>/2024/07/21/%E9%AB%98%E6%96%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="高斯数据库使用手册"><a href="#高斯数据库使用手册" class="headerlink" title="高斯数据库使用手册"></a>高斯数据库使用手册</h1><h2 id="1-简述"><a href="#1-简述" class="headerlink" title="1. 简述"></a>1. 简述</h2><p>openGauss是一款极致性能、安全、可靠的关系型（OLTP）开源数据库</p><h2 id="2-官方文档"><a href="#2-官方文档" class="headerlink" title="2. 官方文档"></a>2. 官方文档</h2><p>​<a href="https://opengauss.org/zh/">https://opengauss.org/zh/</a> 安装及对应工具都在，按需查找</p><h2 id="3-DBeaver使用Gauss"><a href="#3-DBeaver使用Gauss" class="headerlink" title="3. DBeaver使用Gauss"></a>3. DBeaver使用Gauss</h2><p>​使用DBeaver管理Gauss数据库</p><h4 id="1-选择工具栏新建数据库连接"><a href="#1-选择工具栏新建数据库连接" class="headerlink" title="1. 选择工具栏新建数据库连接"></a>1. 选择工具栏<code>新建数据库连接</code></h4><p><img src="https://logflies.oss-cn-chengdu.aliyuncs.com/uPic/CleanShot%202024-06-26%20at%2021.53.25@2x.png" alt="CleanShot 2024-06-26 at 21.53.25@2x"></p><h4 id="2-创建数据库驱动，jdbc使用postgresql"><a href="#2-创建数据库驱动，jdbc使用postgresql" class="headerlink" title="2. 创建数据库驱动，jdbc使用postgresql"></a>2. 创建数据库驱动，jdbc使用postgresql</h4><p><img src="https://logflies.oss-cn-chengdu.aliyuncs.com/uPic/CleanShot%202024-06-26%20at%2021.54.11@2x.png" alt="CleanShot 2024-06-26 at 21.54.11@2x"></p><h4 id="3-下一步输入数据库ip地址，端口号，用户名及密码"><a href="#3-下一步输入数据库ip地址，端口号，用户名及密码" class="headerlink" title="3. 下一步输入数据库ip地址，端口号，用户名及密码"></a>3. 下一步输入数据库ip地址，端口号，用户名及密码</h4><p><img src="https://logflies.oss-cn-chengdu.aliyuncs.com/uPic/CleanShot%202024-06-26%20at%2021.55.34@2x.png" alt="CleanShot 2024-06-26 at 21.55.34@2x"></p><h4 id="4-登录成功后"><a href="#4-登录成功后" class="headerlink" title="4. 登录成功后"></a>4. 登录成功后</h4><p><img src="https://logflies.oss-cn-chengdu.aliyuncs.com/uPic/CleanShot%202024-06-26%20at%2022.00.19@2x.png" alt="CleanShot 2024-06-26 at 22.00.19@2x">、</p><h4 id="5-新建sql执行，创建新的用户和数据库，并赋予权限"><a href="#5-新建sql执行，创建新的用户和数据库，并赋予权限" class="headerlink" title="5. 新建sql执行，创建新的用户和数据库，并赋予权限"></a>5. 新建sql执行，创建新的用户和数据库，并赋予权限</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建数据库</span><br><span class="hljs-keyword">CREATE</span> DATABASE your_database;<br><br><span class="hljs-comment">-- 创建用户req</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> req <span class="hljs-keyword">WITH</span> PASSWORD <span class="hljs-string">&#x27;password&#x27;</span>;<br><br><span class="hljs-comment">-- 授予用户对数据库的所有权限</span><br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILEGES <span class="hljs-keyword">ON</span> DATABASE your_database <span class="hljs-keyword">TO</span> req;<br><br><span class="hljs-comment">-- 切换到新创建的数据库</span><br>\c your_database<br><br><span class="hljs-comment">-- 授予用户对数据库中所有 schema 和对象的所有权限</span><br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILEGES <span class="hljs-keyword">ON</span> SCHEMA public <span class="hljs-keyword">TO</span> req;  <span class="hljs-comment">-- 重复这行语句以适用于多个 schema</span><br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILEGES <span class="hljs-keyword">ON</span> <span class="hljs-keyword">ALL</span> TABLES <span class="hljs-keyword">IN</span> SCHEMA public <span class="hljs-keyword">TO</span> req;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILEGES <span class="hljs-keyword">ON</span> <span class="hljs-keyword">ALL</span> SEQUENCES <span class="hljs-keyword">IN</span> SCHEMA public <span class="hljs-keyword">TO</span> req;<br><br><span class="hljs-comment">-- 确保未来创建的对象也授予用户权限</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">DEFAULT</span> PRIVILEGES <span class="hljs-keyword">IN</span> SCHEMA public <span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILEGES <span class="hljs-keyword">ON</span> TABLES <span class="hljs-keyword">TO</span> req;<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">DEFAULT</span> PRIVILEGES <span class="hljs-keyword">IN</span> SCHEMA public <span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILEGES <span class="hljs-keyword">ON</span> SEQUENCES <span class="hljs-keyword">TO</span> req;<br><br></code></pre></td></tr></table></figure><h2 id="4-代码中使用Guass数据库连接"><a href="#4-代码中使用Guass数据库连接" class="headerlink" title="4. 代码中使用Guass数据库连接"></a>4. 代码中使用Guass数据库连接</h2><p>由于 GaussDB 基于 PostgreSQL所以引入对应依赖即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.postgresql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>postgresql<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>42.2.20<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <span class="hljs-comment">&lt;!-- 请确认版本号是否为最新 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置datasource</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc:postgresql://&lt;host&gt;:&lt;port&gt;/&lt;database&gt;</span><br><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">your_username</span><br><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">your_password</span><br><span class="hljs-attr">spring.datasource.driver-class-name</span>=<span class="hljs-string">org.postgresql.Driver</span><br><br><span class="hljs-attr">spring.jpa.properties.hibernate.dialect</span>=<span class="hljs-string">org.hibernate.dialect.PostgreSQLDialect</span><br><span class="hljs-attr">spring.jpa.hibernate.ddl-auto</span>=<span class="hljs-string">update</span><br><br></code></pre></td></tr></table></figure><h2 id="5-常用的权限"><a href="#5-常用的权限" class="headerlink" title="5. 常用的权限"></a>5. 常用的权限</h2><p>赋予权限使用<code>GRANT</code>，撤销权限用<code>REVOKE</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 1. 授权表的权限</span><br><span class="hljs-comment">-- SELECT：查询数据</span><br><span class="hljs-comment">-- INSERT：插入数据</span><br><span class="hljs-comment">-- UPDATE：更新数据</span><br><span class="hljs-comment">-- DELETE：删除数据</span><br><span class="hljs-comment">-- TRUNCATE：清空数据</span><br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span>, <span class="hljs-keyword">INSERT</span>, <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">ON</span> schema.table <span class="hljs-keyword">TO</span> username;<br><span class="hljs-comment">-- 2. 授予视图权限</span><br><span class="hljs-comment">-- SELECT：查询视图数据</span><br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ON</span> schema.view <span class="hljs-keyword">FROM</span> username;<br><span class="hljs-comment">-- 3. 授予存储过程或函数执行权限</span><br><span class="hljs-comment">-- EXECUTE：执行存储过程或函数</span><br><span class="hljs-comment">-- GRANT EXECUTE ON PROCEDURE procedure_name TO username;</span><br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">EXECUTE</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">FUNCTION</span> function_name <span class="hljs-keyword">TO</span> username;<br><span class="hljs-comment">-- 4. 授予数据库权限</span><br><span class="hljs-comment">-- CREATE：在数据库中创建对象</span><br><span class="hljs-comment">-- DROP：删除对象</span><br><span class="hljs-comment">-- ALTER：修改对象</span><br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">CREATE</span>, <span class="hljs-keyword">DROP</span>, <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">ON</span> DATABASE database_name <span class="hljs-keyword">TO</span> username;<br><span class="hljs-comment">-- 5. 授予模式（Schema）权限</span><br><span class="hljs-comment">-- USAGE：使用模式中的对象</span><br><span class="hljs-comment">-- CREATE：在模式中创建新对象</span><br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">CREATE</span>, <span class="hljs-keyword">DROP</span>, <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">ON</span> DATABASE database_name <span class="hljs-keyword">TO</span> username;<br><span class="hljs-comment">-- 6. 授予序列权限</span><br><span class="hljs-comment">-- USAGE：使用序列生成值</span><br><span class="hljs-comment">-- SELECT：查询序列的当前值</span><br><span class="hljs-keyword">GRANT</span> USAGE, <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ON</span> SEQUENCE schema.sequence_name <span class="hljs-keyword">TO</span> username;<br><span class="hljs-comment">-- 7. 授予角色权限(说明：role的概念为一组权限，以上的赋权都可以替换TO userName为TO rolename，然后将角色的权限赋予用户)</span><br><span class="hljs-keyword">GRANT</span> role_name <span class="hljs-keyword">TO</span> username;<br><br><span class="hljs-comment">-- 权限查看：</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> pg_roles;  <span class="hljs-comment">-- 查看角色信息</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> pg_user;   <span class="hljs-comment">-- 查看用户权限信息</span><br></code></pre></td></tr></table></figure><h2 id="6-高斯出厂用户"><a href="#6-高斯出厂用户" class="headerlink" title="6. 高斯出厂用户"></a>6. 高斯出厂用户</h2><ul><li><p><code>PUBLIC</code> : <code>PUBLIC</code>是所有数据库用户的默认角色。任何数据库用户，都会拥有<code>PUBLIC</code>角色的权限，这些权限会应用于所有用户。</p><p>一般用于特定用户的公共授权</p></li><li><p><code>db_owners</code> : <code>db_owner</code> 是具有完整权限的角色，通常是数据库管理员角色（DBA）。此角色通常被分配给数据库管理员，允许他们执行所有数据库操作，包括创建、修改、删除数据库对象等</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>终于从甲流的魔爪中逃了出来</title>
    <link href="/2024/03/02/%E7%BB%88%E4%BA%8E%E4%BB%8E%E7%94%B2%E6%B5%81%E7%9A%84%E9%AD%94%E7%88%AA%E4%B8%AD%E9%80%83%E4%BA%86%E5%87%BA%E6%9D%A5/"/>
    <url>/2024/03/02/%E7%BB%88%E4%BA%8E%E4%BB%8E%E7%94%B2%E6%B5%81%E7%9A%84%E9%AD%94%E7%88%AA%E4%B8%AD%E9%80%83%E4%BA%86%E5%87%BA%E6%9D%A5/</url>
    
    <content type="html"><![CDATA[<p>过年期间一直在忙，过年之后又得了一场大病，现在终于能坐下来写写博客了。。。</p><h1 id="1、我经历了些什么"><a href="#1、我经历了些什么" class="headerlink" title="1、我经历了些什么"></a>1、我经历了些什么</h1><p>2月23号，也就是开春打工的刚好一周，清早起来就发现身体出现问题，一直在咳嗽，状态很不好，敲代码的时候力不从心，当时就已经察觉到感冒了，但是没有意识到将要面临的是这样一个危险的情况。熬到下班，我回到广汉女友家里，当时已经出现了畏寒的症状，用温度计测量体温发现烧到38.5度，吃了退烧药，迷迷糊糊就睡了。</p><p>第二天起来，感觉还是没有好转，由于要去女友的弟弟家去贺搬迁之喜，吃中午饭的时候完全没食欲。下午实在难受去了医院，查血一看，甲流… 医生开了泰诺和奥司他韦。</p><p>第三天，下不了床，浑身无力，刀片嗓也出现了，头晕噬睡，一会低烧一会高烧</p><p>第四天，还是下不了床，根第三天差不多，但是情况要更加糟糕，总结相当于第三天的痛苦x2</p><p>第五天，出现了转折，烧退了，流鼻涕水泥封鼻</p><h1 id="2、对自己的影响"><a href="#2、对自己的影响" class="headerlink" title="2、对自己的影响"></a>2、对自己的影响</h1><p>这次生病首先对我的影响就是身体上的，这次得病之后身体素质更低了，其次是生活让我一周都吃不了稀饭之外的好吃的，类似海鲜、辛辣根本不能沾，而且目前而言嗓子还是没有好，还得持续一周以上，再者就是学习相关了，期间根本没有精力去学习，博客也停更了2周多。</p><h1 id="3、后续预防手段"><a href="#3、后续预防手段" class="headerlink" title="3、后续预防手段"></a>3、后续预防手段</h1><ul><li>加强锻炼，准备坚持每天跑步</li><li>换季预防针</li><li>多吃水果</li></ul><blockquote><p>感谢曾女士在生病期间对我的细心照料，没有她估计病情不会这么好的快</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Alfred Workflow教程</title>
    <link href="/2024/02/07/Alfred%20Workflow%E6%95%99%E7%A8%8B/"/>
    <url>/2024/02/07/Alfred%20Workflow%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>Ask: 为啥要做这样一篇文章？</strong></p><blockquote><p>网上很少有这方面的教程，一方面是现在Alfred Workflow有自己的应用市场，比如Alfred Gallery中已经很全面，令一方面中文文献比较少，会的人都是专注自己的场景，且学习成本比较高，需要编程基础。因此自己研究了一下，做个笔记。后续持续更新解锁高级玩法…</p></blockquote><p><img src="https://5b0988e595225.cdn.sohucs.com/images/20171121/9bc2349ef8ac49ad8a01c48eace4766a.jpeg"></p><h1 id="1、Alfred-Workflow是个什么？"><a href="#1、Alfred-Workflow是个什么？" class="headerlink" title="1、Alfred Workflow是个什么？"></a>1、Alfred Workflow是个什么？</h1><p>最为macOs上最佳效率软件Alfred，在2.0版本推出了Workerflow特性；允许个性化定义，复杂的工作使用脚本语言，例如：bash、zsh、php，python、ruby、perl、appleScript、JavaScript等封装起来，以Alferd最为唯一的入口和呈现来使用，大大提高效率。</p><h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><p>输入atop，展示系统各种信息</p><p><img src="https://logflies.oss-cn-chengdu.aliyuncs.com/uPic/image-20240207221018310.png"></p><p>输入ip，展示系统ip地址</p><p><img src="https://logflies.oss-cn-chengdu.aliyuncs.com/uPic/image-20240207221148531.png"></p><p>输入&gt; 可以执行终端命令</p><p><img src="https://logflies.oss-cn-chengdu.aliyuncs.com/uPic/image-20240207221218188.png"></p><h1 id="2、Workflow的一些概念"><a href="#2、Workflow的一些概念" class="headerlink" title="2、Workflow的一些概念"></a>2、Workflow的一些概念</h1><h2 id="2-1-引入"><a href="#2-1-引入" class="headerlink" title="2.1 引入"></a>2.1 引入</h2><p>其实我们知道任何一个工作都可以拆成多个步骤，这些步骤顺序相连，依次进行，最终输出成果，有些步骤可以形成分支，并且输出多个成果。这些步骤依次执行，并且向后传递阶段性信息的流，这就是工作流。现实中的工作流可能更为复杂。</p><h2 id="2-2-框架"><a href="#2-2-框架" class="headerlink" title="2.2 框架"></a>2.2 框架</h2><p>Alfred Workflow的整体框架，类似于Windows中的Direct Show，首先由一个Input开始，中间经过一堆filter，然后到一个Output结束，中间用Pin来连接，上一个Output pin作为输入转递给下一个Input Pin，从而形成一个完整的图，最终的输出展示内容必须符合这样一个形式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">items</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">valid</span>=<span class="hljs-string">&quot;yes&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>10.0.2.11<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">subtitle</span>&gt;</span>45.76.65.119 美国新泽西州皮斯卡特维 choopa.com<span class="hljs-tag">&lt;/<span class="hljs-name">subtitle</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">icon</span>&gt;</span>Info.icns<span class="hljs-tag">&lt;/<span class="hljs-name">icon</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">items</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Alfred上每一行都对以一个item，如果显示多行，就在items中添加多个。</p><p>注意：</p><ul><li>valid表现为可不可选，点击，再次传递</li><li>title主标题</li><li>subtitle副标题</li><li>icon 图标</li></ul><h1 id="3、打开维基百科panda简介的demo"><a href="#3、打开维基百科panda简介的demo" class="headerlink" title="3、打开维基百科panda简介的demo"></a>3、打开维基百科panda简介的demo</h1><ol><li>新建立一个空的Workflow，输入panda-demo，进行创建</li></ol><p><img src="https://logflies.oss-cn-chengdu.aliyuncs.com/uPic/image-20240207230555093.png"></p><ol start="2"><li>在右侧工具栏中，选择组件进行拖拽，我们选择Inputs-&gt;KeyWord，在输入框输入panda，选项No Argument。</li></ol><p><img src="https://logflies.oss-cn-chengdu.aliyuncs.com/uPic/image-20240207232152188.png"></p><ol start="3"><li>继续在右侧工具栏，选择Actions-&gt;Open URL，输入打开URL地址：<a href="https://en.wikipedia.org/wiki/Giant_panda">https://en.wikipedia.org/wiki/Giant_panda</a></li></ol><p><img src="https://logflies.oss-cn-chengdu.aliyuncs.com/uPic/image-20240207232535043.png"></p><ol start="4"><li>两个组件拖拽连接即可</li></ol><p><img src="https://logflies.oss-cn-chengdu.aliyuncs.com/uPic/image-20240207232801373.png"></p><p>输入panda回车，打开默认浏览器跳转到对应熊猫页面</p><p><img src="https://logflies.oss-cn-chengdu.aliyuncs.com/uPic/image-20240207233022566.png"></p><p><img src="https://logflies.oss-cn-chengdu.aliyuncs.com/uPic/image-20240207233119631.png"></p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>那些年我们打过的工（一）</title>
    <link href="/2024/02/04/%E8%BF%99%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E6%89%93%E8%BF%87%E7%9A%84%E5%B7%A5/"/>
    <url>/2024/02/04/%E8%BF%99%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E6%89%93%E8%BF%87%E7%9A%84%E5%B7%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="BO1毕业前"><a href="#BO1毕业前" class="headerlink" title="BO1毕业前"></a>BO1毕业前</h1><p>靠着一点小聪明，跌跌撞撞在12年考上了大学，到了大学我终于体验到了自由的感觉，觉得这是备考高考的奖励，开始了懒散、毫无无目标，觉得自己做的一切事情都是自己应得，实打实混了3年的大学。</p><p>这三年我前前后后挂了5、6门课，基本每学期都会挂科，我们宿舍有个大哥叫陈X科，也是每学期挂科，后来周围的宿舍的同学戏谑我们，一个叫陈挂科，一个叫刘爱挂。</p><p><img src="https://logflies.oss-cn-chengdu.aliyuncs.com/uPic/v2-6cff403089d8f92ccf147af39899ca56_1440w.jpg" alt="NO，挂科！"></p><p>其实能回到过去，我想对那个漫无目标的少年好好谈谈，告诉他其实比他聪明的人多的是，教他人生要有自己的规划，知识是学给自己的，它将在未来成为你的武器和资产，每个阶段要做好你该做的，你迟早会为你的浑浑噩噩买单。</p><hr><p>直到大四的时候，我们院系安排了去外省实习培训，当时是签订的一家培训机构在上海，进行了为期短短的几周，其实说实在就是学校和培训机构一起合作的，你过来当试听，然后推荐你报他们的辅导课。当时听到费用是一万多的时候，我完全没有想法，因为我知道我们家里的情况，拿不出来这笔钱。</p><p>于是在那个10月，看着周围的同学报班的报班，考研的考研，实习的实习。让我自己有一个人生规划，那就是我要去大城市实习，我要挣钱！我买了绿皮火车票，来到了成都（很大的原因是因为有亲戚在这），第一次自己一个人做地铁，当时成都还只有1号线，我还记得当时地铁路过孵化园的时候，我还天真的以为这是孵化小鸡的。</p><p><img src="https://logflies.oss-cn-chengdu.aliyuncs.com/uPic/2560px-Platform_of_Line_1_in_Incubation_Park_Station01.jpg" alt="孵化园"></p><hr><p>我去了面试现场，当时还没有啥线上面试这样高端的玩意，去的就是感觉跟个菜市场，招聘公司全部在一起，一个摊子一个摊子的摆来摆去，面试要求上的各种奇奇怪怪的单词，要求这个要求那个，我犹豫了好久不敢去问，直到鼓起勇气问了一个和蔼的胖大叔，他问我简历有么，我居然没有简历，忙解释自己是大四上学期，还没有毕业过来找实习的，他估计看我可怜给了我面试机会，也是面试将彻底改变我。</p><p><img src="https://logflies.oss-cn-chengdu.aliyuncs.com/uPic/168240519685420_840_560.jpg" alt="劳动力市场"></p><p>他问我会些什么编程语言，我说我会点java、C++，知道OOP（面向对象编程，大学有教一些为数不多我记得比较深刻），然后他问了我，那你知道AOP么？我摇了摇头，然后又问了一、两个问题我记不太清楚了。最后他冷冰冰的一个一个字的说出了那句话：你、不、符、合、我、们、招、聘、的、标、准。最后还拍了拍我的肩膀。</p><p>…</p><p>这个失落感，怎么说呢，平生第一次有这种感觉，就像掉到了无底深渊。想哭但是哭不出来，感觉心口感觉被石头压住。这是我第一次感觉到原来，自己是这么渺小，这么的无助。当然由于啥也没准备，这次成都找实习以失败告终。回去的路上，小姨和小姨夫安慰我：不要急慢慢来，就当过来旅游了。但是我真的不甘心，一直憋着在回去的绿皮车上哭了出来。</p><hr><p>我狠下心终于决定要去培训，跟辅导员说我要去，辅导员联系了培训机构，地点是在北京，我又马不停蹄的去了北京，还好我哥在北京还有个人做依靠，可悲的是由于我哥是新搬的家又比较远，所以我只能自己租房。当时住的是20多号人一起青年旅社（相当买了一个床位），冬天没有热水澡，地板随处跑蟑螂。从早上学到晚上，每天都会把知识点记在笔记上，然后复习一遍又一遍的噼里叭啦敲代码。</p><p><img src="https://logflies.oss-cn-chengdu.aliyuncs.com/uPic/371707057243_.pic.jpg" alt="泛黄的笔记1"></p><p><img src="https://logflies.oss-cn-chengdu.aliyuncs.com/uPic/381707057243_.pic.jpg" alt="泛黄的笔记2">其实当时我挺羡慕我哥的，自己组装了一台电脑，有自己的投影器，可以住在自己干净舒服的房间（也是第一感觉自如的房子好干净啊)，觉得这应该是自己奋斗的目标。所以我往后租房第一想法就是租自如的房子，可能跟这个有关吧。</p><p><img src="https://logflies.oss-cn-chengdu.aliyuncs.com/uPic/15624646072234968.jpg" alt="自如"></p><p>16年的春节，为了省点钱，也为了立下志向，我没有回家，过年吃的是肯德基全家筒（我哥给我买的)，那时候的我真的没啥好怕的，一个人听着礼花炮竹过年，一起都是靠自己，孤独、敢打敢拼。</p><p>后续待更新…</p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>字符编码笔记</title>
    <link href="/2024/02/03/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/02/03/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><img src="https://logflies.oss-cn-chengdu.aliyuncs.com/uPic/4c05afb781104475bea3ef5a6cc212a1.webp" alt="这是个啥，啥？啥！"></p><p>其实在刚刚接触编程的时候，我就知道有Unicode和UTF-8，知识只是停留在表面，遇到的问题也是：哎呀，页面展示出现乱码啦，需要修改一下字符编码集或者为啥解析不对，一直都是一知半解（大学计算机数据结构和算法没学好 - -!)，直到看了阮一峰老师的笔记，才完全理解底层逻辑。在这标明一下原作者的博客地址，此文是在阅读原作者之后，进行输出的理解和总结。 </p><blockquote><p><a href="https://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">字符编码笔记：ASCII，Unicode 和 UTF-8</a></p></blockquote><h1 id="1、计算机表示字符的起源"><a href="#1、计算机表示字符的起源" class="headerlink" title="1、计算机表示字符的起源"></a>1、计算机表示字符的起源</h1><p>计算机内部所有的信息都是二进制，每个二进制（bit）有<code>0</code> 、<code>1</code>两种状态，人为规定了八个二进制为一个字节（byte）。那么一个字节就可以表示256种不同的状态，即<code>00000000</code>到<code>11111111</code>。</p><p>上个世纪60年代，美国先规定了一套字符编码，所谓字符编码其实就是他们母语（英语）与字节的关系，这个被称之为ASCII码，一直被沿用至今。</p><p>ASCII码：规定了128个字符的编码，比如空格<code>SPACE</code>是32，大写的<code>A</code>是65等等。这128个符号（包括32个不饿能答应的控制符号），最多占用一个字节的7位，前面的统一补<code>0</code>。</p><p>非ASCII编码：英文128个字符就够了，但是其他语言呢？往往是不够的，这就不能通过ASCII来表示了。于是，每个国家都制定了自己编码，但是又出现一个问题，那就是很多国家没有英语这么简单（字符意义上），使用的字符很多，比如汉字多达10万多，一个字节肯定不够的，就需要多个字节来表达一个符号。</p><h1 id="2、Unicode"><a href="#2、Unicode" class="headerlink" title="2、Unicode"></a>2、Unicode</h1><p>上一节说到，世界存在很多编码方式。同一个二进制可能被解释成不同的符号。所以在打开文件的时候就要知道他的编码方式，如果使用错误的编码方式就会导致乱码。</p><p>所以人们发明了一种通用的编码格式，将世界上的所有符号纳入其中。每个符号都给予独一无二的编码，这样乱码的问题就会消失。这就是unicode编码。</p><p>Unicode是一个很大的集合，现在的规模能容纳100多万个符号。每股符号的编码都不一样。具体的符号对应表，可以查询<a href="http://www.unicode.org/">unicode.org</a>，或者专门的<a href="http://www.chi2ko.com/tool/CJK.htm">汉字对应表</a>。</p><p>现在有一个问题就是如何区分你是Unicode还是ASII呢？计算机怎么知道三个字节是一个符号，而不是表示三个符号呢？如果我们用三个字节表示一个符号，那么就会产生浪费，那些只需要一个字节表示的字符就会被补充两个字节的<code>0</code>产生了极大的浪费。</p><p>他造成的结果是：</p><ol><li><p>出现了多种Unicod存储方式，也是说很多不同的二进制格式可以用来表示Unicode。</p></li><li><p>Unicode在很长一段时间无法推广。</p></li></ol><h1 id="3、UTF-8"><a href="#3、UTF-8" class="headerlink" title="3、UTF-8"></a>3、UTF-8</h1><p>互谅网的布局，要求一种统一的编码方式，UTF-8核心问题是制定了Unicode实现标准，解决Unicode位数无法确定，浪费空间的问题。</p><p><strong>所以说UTF-8是Unicode的一种实现方式</strong></p><p>刚才说了UTF-8的一大特点是，它是一种可变的编码方式。他可以使用1~4个字节表示一个符号，根据不同的符号来改变字节长度。</p><p>UTF-8的编码规则很简单，只有两条：</p><ol><li>对单字节的符号，字节第一位为<code>0</code>，后7位位这个符号的Unicode码。因此对于英文来说，UTF-8和ASCII是一样的。</li><li>对于有<code>n</code>个字节的符号（n&gt;1），第一个字节前<code>n</code>位都是<code>1</code>，前<code>n+1</code>位为<code>0</code>。后边的字节前两位都是<code>10</code>。剩下的没有提及的二进制，全部为这个符号的Unicode码。</li></ol><p>​eg：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">Unicode符号范围     |        UTF-8编码方式<br><span class="hljs-section">(十六进制)        |              （二进制）</span><br><span class="hljs-section">----------------------+---------------------------------------------</span><br>0000 0000-0000 007F | 0xxxxxxx<br>0000 0080-0000 07FF | 110xxxxx 10xxxxxx<br>0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx<br>0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>思考</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于发烧的要点</title>
    <link href="/2024/02/01/%E5%85%B3%E4%BA%8E%E5%8F%91%E7%83%A7%E7%9A%84%E8%A6%81%E7%82%B9/"/>
    <url>/2024/02/01/%E5%85%B3%E4%BA%8E%E5%8F%91%E7%83%A7%E7%9A%84%E8%A6%81%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p><img src="https://logflies.oss-cn-chengdu.aliyuncs.com/uPic/u=554504066,4144554805&fm=253&fmt=auto&app=120&f=JPEG.webp" alt="u=554504066,4144554805&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG"></p><p>国内和国外在对待发烧这件事情看法差异巨大。国内一般要是有小孩发烧，家长就会心急如焚，甚至马上送去急症。但是在外国，一般都是在家观察三天，否则去了医院也被医生赶回来；如果三天后还是没有自愈或者出现了更严重的状况（呼吸困难等等）才会进行就医。</p><p>这阵子由于是寒冬腊月，加上各种流感侵袭（主要是乙流），身边的很多朋友都由于发烧引起了担忧和恐慌。特意整理了一份内部资料，格式比较简陋但是都是采集于各家专业医学期刊和媒体。</p><p>如果你是医学专业人士，欢迎提出建议，我会持续完善本文</p><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><ul><li>体温控制是人类免疫系统的一部分：体温越高，人类体内的大部分细菌和病毒的活性就越差，而另一方面，高体温却可以提高白细胞以及其它免疫细胞的活力，因此高体温有助于我们的免疫系统尽快获胜；</li><li>既然如此，为什么体温不进化到 40 度甚至 50 度以上呢？因为热量是有成本的，体温越高意味着你需要消耗越多热量去维持体温。在缺乏食物的古代，体温过高的人类更容易饿死，因此时刻保持 40 度以上的体温从进化上来看是不划算的。37 度左右是比较均衡的体温，只有在需要对抗细菌病毒的时候才会临时升高体温。</li></ul><h3 id="误解："><a href="#误解：" class="headerlink" title="误解："></a>误解：</h3><ul><li>谈发烧色变，是最大的误解。发烧只是大脑主动控制身体升高体温的表现，目的是协助免疫系统对抗病毒和细菌，因此发烧本身对身体不仅无害、甚至还有益；</li><li>“烧坏脑子”也是个民间的误解，误解的来源是过去发生脑炎的时候会伴随着发烧，导致民间认为是发烧导致了脑炎的各种症状（意识混乱、癫痫、昏迷等）。实际上弄坏脑子的原因是脑炎病毒，而不是发烧本身。根据研究，只有体温持续超过 42 度才会对大脑细胞造成损伤，而一般人发烧是极难达到这么高温的；</li><li>很多家长看到孩子体温 40 度就吓尿了，其实40度本身一点都不危险。与体温相比，更重要的是孩子的面色、举止和精神状态：比如一个体温才38度但已经走路不稳的孩子，和一个体温40 度但活蹦乱跳、嘻嘻哈哈的孩子，前者要严重得多。</li></ul><h3 id="怕冷："><a href="#怕冷：" class="headerlink" title="怕冷："></a>怕冷：</h3><p>免疫系统开始工作后，大脑中枢发出了“让体温升高”的信号，具体来说分为两种任务：</p><ul><li>减少散热：主要是锁紧毛孔；</li><li>增加产热：主要是让肌肉快速收缩和扩张（可以理解为运动发热），所以人会感觉肌肉颤抖（也被称为“寒颤”）</li></ul><p>由于，大脑中枢把身体最新的“理想体温”抬高到了 39 度以上，而此时你的体温还在缓慢上升中，尚未达到理想温度，因此大脑会故意让你感觉冷，从而让你寻求保暖的方式，以加速升高体温。在这段时间内，可以加一些保暖衣物或毯子。</p><p>等到体温上升完成后，寒颤和怕冷就会消失，这时候你就要开始做相反的事情：减少保暖的衣服毯子，增加散热。</p><h3 id="测温："><a href="#测温：" class="headerlink" title="测温："></a>测温：</h3><ul><li>检测体温最准确的位置直肠内部（因为最靠近体内器官、且不容易被外界环境温度影响），其次是耳朵的鼓膜温度，再次是舌底，而最不准确的是腋窝和额头的温度，因为距离内部器官比较远、且受环境影响较大。考虑到方便度和舒适度，优先推荐耳温枪。</li><li>耳温枪的原理是检测鼓膜上的血管的温度，因此关键在于对准鼓膜，正确的测法是耳朵往后拉扯，并且让枪头尽可能往里塞。否则测出来的是耳道温度，会低 0.5 度左右；</li><li>两只耳朵测出来的温度不同是正常的，因为耳道宽窄不同，耳朵或者耳内异物也会影响鼓膜的对准程度，以温度高的那个为准；</li><li>建议单耳测试三次，取平均值；</li><li>考虑到有些人平时体温就偏高、或者耳温枪本身存在固有的机械或电子误差，建议平时在健康的时候就先测试一个基准值，发烧时可以做对比；</li></ul><h3 id="退烧药："><a href="#退烧药：" class="headerlink" title="退烧药："></a>退烧药：</h3><ul><li>重要的事情说三遍：退烧药无法治病，退烧药无法治病，退烧药无法治病；</li><li>退烧药的作用原理，通俗得说包括两部分：<ol><li>降低痛觉神经的敏感性；</li><li>麻痹让身体升高体温的生化信号。因此退烧药的确可以辅助退烧、并减轻身体不适，但退烧药的作用是表面的，并不能解决引起发烧的真正疾病。就像发生股灾的时候，你看着手机流泪，退烧药这时候走出来给了你一颗安眠药而已，让你没那么痛苦，但并没有解决股灾本身</li></ol></li><li>如果发烧期间身体没有感觉不适（无论睡着或清醒时），就不需要吃退烧药；</li><li>如果睡的很好，就不要叫醒吃药；</li><li>退烧药千万不要过量吃，否则会导致器官损伤；</li><li>泰诺和布洛芬的效果区别不大，不需要交替吃；</li><li>吃退烧药前后24 小时避免喝酒，否则可能会导致肝损伤</li></ul><h3 id="降温："><a href="#降温：" class="headerlink" title="降温："></a>降温：</h3><ul><li>对孩子不要使用酒精擦拭，酒精可以通过皮肤吸收，导致孩子酒精中毒；</li><li>不要用冷水擦拭或泡澡，这会让大脑本能的刺激身体创造更多热量；</li><li>至于用温水敷额头、擦拭或泡澡，虽然最新的医学指南不再推荐了，但也不反对。温水可以帮助降低体温1 ~ 2度，但只能维持 30 ~ 45分钟，意义并不大，但如果能起到安慰性质的心理作用，也可以做；</li><li>综上所述，最佳的降温方式：<ol><li>放在空气流通且温度适宜的地方；</li><li>不要穿很多衣服、不要捂被子；</li><li>如果有必要，再吃退烧药</li></ol></li></ul><h3 id="康复："><a href="#康复：" class="headerlink" title="康复："></a>康复：</h3><ul><li>大量喝水；</li><li>充足睡眠；</li><li>室内通风且温度适宜；</li><li>发烧初期发寒颤的时候可以使用保暖加热措施，但寒颤消失后就不能再保暖加热了；</li><li>记录每天的体温和精神状态，以便后期医生研究病情需要；</li><li>发烧的时候胃口不好很正常，吃得少了就更要注意食物种有足够的营养（蛋白质、维生素 C等），千万别只喝白粥；</li><li>如果是孩子，要注意观察平静时的呼吸次数，5 岁以上如果每分钟高于 20 次，可能存在肺炎风险，要联系医生；</li><li>如果口唇周围发青，也肺炎的典型症状之一，要联系医生</li></ul><h3 id="病程："><a href="#病程：" class="headerlink" title="病程："></a>病程：</h3><p>发烧的反复频率和持续时间，通常取决于引起发烧的感染类型。由病毒引起的发烧可能在两到三天后就退去，也可能持续长达两周。由细菌感染引起的发烧，则可能要到接受抗生素治疗后才会退去。</p><h3 id="就医："><a href="#就医：" class="headerlink" title="就医："></a>就医：</h3><p>但如果出现以下情况之一，可以就医：</p><ul><li>皮肤上出现斑点状的皮疹</li><li>无法喝水</li><li>呼吸困难</li><li>皮肤苍白或者明显病态</li><li>意识混乱或模糊</li><li>出现部位明确的疼痛（例如耳痛或喉咙痛）</li><li>退烧超过24小时，此后又再次发烧</li><li>昏睡且难以叫醒</li><li>颈部僵硬</li><li>咳嗽出的痰里有血丝（肺炎迹象）</li><li>连续发烧超过三天</li><li>有肺炎的症状（如呼吸急促、唇口发青等）</li></ul><h3 id="声明："><a href="#声明：" class="headerlink" title="声明："></a>声明：</h3><ul><li>本人非医学专业背景，本文不对任何人构成医学建议；</li><li>本文内容仅针对发烧本身，而非新冠感染。如果有新冠感染的症状，请查询专门的新冠诊疗方案。</li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python从零开始(持续更新)</title>
    <link href="/2024/01/27/Python%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/"/>
    <url>/2024/01/27/Python%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Python简介"><a href="#1-Python简介" class="headerlink" title="1 Python简介"></a>1 Python简介</h1><p>Python是著名的龟叔Guido van Rossum在1989年圣诞节，为了打发无聊的圣诞节而编写的一个人编程语言。</p><p>高级语言通常都会提供一个比较完善的基础代码库，让开发者直接调用。Python就为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象的称作“内置电池（batteries included）”。</p><p>除了内置库外，Python还有大量的第三方库，也就是别人开发好的，直接共给你使用的东西。当然，如果你自己开发封装也可以作为第三方库给别人使用。</p><p>Python的定位是“优雅”、“明确”、“简单”，所以python程序看上去简单易懂，适合于网络应用、包括网站、后台服务等，其次是各种日常需要的小工具，包括系统管理员需要的脚本任务等。然后就是被称之为胶水语言，把其他语言开发的程序包装起来使用。</p><p>Python的缺点，第一个是运行比较慢，解释型语言的通用诟病。但是由于大量的应用程序不需要那么快的运行速度，很多情况下就是1.1s和1.001秒的区别。第二个是代码不能加密，编译型语言都没有这个问题，解释型则必须把源码发布出去。</p><h1 id="2-安装Python"><a href="#2-安装Python" class="headerlink" title="2 安装Python"></a>2 安装Python</h1><p>因为Python是跨平台的，它可以运行在Windows、mac、linux&#x2F;unix系统上。</p><p>开始学习Python编程，首先就要把Python安装到你的电脑里。安装后，你就会得到Python解释器（负责运行Python程序），一个命令行交互环境，还有一个简单的集成开发的环境。</p><h2 id="2-1安装Python3-12"><a href="#2-1安装Python3-12" class="headerlink" title="2.1安装Python3.12"></a>2.1安装Python3.12</h2><p>目前，Python有两个版本，一个是2.x版本，一个是3.x版本，这两个版本是不兼容的。</p><p>在mac上安装Python</p><p>方法一：从Python官网下载Python 3.12的<a href="https://www.python.org/downloads/">安装程序</a>，下载后双击运行并安装；</p><p>方法二：如果安装了<a href="https://brew.sh/">Homebrew</a>，直接通过命令<code>brew install python3</code>安装即可。</p><h1 id="3-Python基础"><a href="#3-Python基础" class="headerlink" title="3 Python基础"></a>3 Python基础</h1><h2 id="3-1-数据类型和变量"><a href="#3-1-数据类型和变量" class="headerlink" title="3.1 数据类型和变量"></a>3.1 数据类型和变量</h2><p>Python中，能直接处理的数据类型有以下几种：</p><ul><li><p>整数</p><p>Python可以处理任意大小的整数，包括负数。十六进制表述整形比较方便，十六进制用<code>0x</code>前缀和0-9、a-f表示。对于很大的数，例如<code>10000000000</code>也可以写成<code>10_000_000_000</code>。</p></li><li><p>浮点数</p><p>浮点数也就是小数，之所以称之为浮点数，是因为按照科学计数法表示时，一个浮点数的小数位置可以改变。1.23x 10^9^把10当成e代替，也就是1.23e9，负数0.000012写成1.2e-5。</p></li><li><p>字符串</p><p>单引号<code>&#39;</code>  或者双引号<code>&quot;</code>括起来的任意文本。字符串里包含<code>&#39;</code>、<code>&quot;</code>,用转义符<code>\</code>来标识。使用<code>r&#39;&#39;</code>表示<code>&#39;&#39;</code>内部的字符传不能转义。Python允许使用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的格式标识多行。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;&#x27;line1</span><br><span class="hljs-string">line2</span><br><span class="hljs-string">line3&#x27;&#x27;&#x27;</span>)<br>line1<br>line2<br>line3<br></code></pre></td></tr></table></figure></li><li><p>布尔值</p><p>布尔值和布尔代数的表达完全一致，一个布尔值只有True、False两个值</p></li><li><p>空值</p></li><li><p>变量</p><p>变量名必须是大小写英文、数字和<code>_</code>的组合，且不能数字开头。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-string">&#x27;ABC&#x27;</span><br></code></pre></td></tr></table></figure><p>python解释器干了两件事：</p><ol><li>在内存里创建了一个<code>ABC</code>的字符串；</li><li>在内存中创建了一个名为<code>a</code>d的变量，并把它指向<code>ABC</code>。</li></ol></li><li><p>常量</p><p>Python通常用全部大写的变量名表示常量</p></li></ul><p>解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是<code>/</code>，<code>/</code>除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数。</p><p>还有一种除法是<code>//</code>，称为地板除，两个整数的除法仍然是整数。</p><p>整数的地板除<code>//</code>永远是整数，即使除不尽。要做精确的除法，使用<code>/</code>就可以</p><h2 id="3-2-字符串和编码"><a href="#3-2-字符串和编码" class="headerlink" title="3.2 字符串和编码"></a>3.2 字符串和编码</h2><p><strong>字符编码</strong></p><p>计算机只能处理数字，如果要处理文本，就必须把文本转化为数字处理。最早的计算机在设计的时候，采用8个比特（bit）作为一个字节（byte）。</p><p>一开始最早只有127个字符被编码到计算机，大小写英文、数字和一些符号，这个编码被称为<code>ASCII</code>编码。</p><p>中国制定了<code>GB2312</code>编码，用于把中文编写进去。每个国家有自己的编码，结果就是导致冲突，带来了乱码。</p><p>Unicode的出现就是解决乱码问题，标准也在不断的发展，常用的是<code>UCS-16</code>。</p><p>但是新的问题又出现：如果统一为Unicode编码，乱码问题是可以解决，但是会产生空间浪费，后续又出现了<code>UTF-8</code>编码，把一个Unicode字符按照不同的数字大小编码成1-6个字节。</p><p>一般情况下，从文本读取的UTF-8字符串被转化为Unicode字符到内存中，编辑完成后，保存的时候把Unicode转化为UTF-8保存。</p><p><img src="https://logflies.oss-cn-chengdu.aliyuncs.com/uPic/2024-01-28%2014-34-46.png" alt="2024-01-28 14-34-46"></p><p> 浏览网页的时候也是这个道理，服务器把动态生成的Unicode转化为UTF-8在传输到浏览器：</p><p><img src="https://logflies.oss-cn-chengdu.aliyuncs.com/uPic/2024-01-28%2014-32-51.png" alt="2024-01-28 14-32-51"></p><p>所以很多网页源码上会标注类似<code>&lt;meta charset=&quot;UTF-8&quot;/&gt;</code>，表示该网页用的是UTF-8编码。</p><p><strong>Python的字符串</strong></p><p>在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言。</p><p>对于单独的字符串编码，Python提供了类似<code>ord()</code>函数获取字符的整数表示，<code>char()</code>函数把编码转化为对应的字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>)<br><span class="hljs-number">65</span><br>&gt;&gt;&gt;<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;中&#x27;</span>)<br><span class="hljs-number">20013</span><br>&gt;&gt;&gt;char(<span class="hljs-number">66</span>)<br><span class="hljs-string">&#x27;B&#x27;</span><br>&gt;&gt;&gt;char(<span class="hljs-number">25991</span>)<br><span class="hljs-string">&#x27;文&#x27;</span><br></code></pre></td></tr></table></figure><p>如果想知道字符的整数编码，还可以用十六进制这么写<code>str</code>:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">&gt;&gt;&gt;<span class="hljs-string">&#x27;\u4e2d\u6587&#x27;</span><br><span class="hljs-string">&#x27;中文&#x27;</span><br></code></pre></td></tr></table></figure><p>Python的字符串，在内存里是Unicode表示，一个字符串对应若干个字节。但是在网上传输或者保存在磁盘中是，就要把<code>str</code>转成以字节为单位的<code>bytes</code>。</p><p>Python对<code>bytes</code>类型的数据带<code>b</code>前缀的单引号或者双引号表示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python">x=<span class="hljs-string">b&#x27;abc&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java字节码编程</title>
    <link href="/2023/03/17/java%E5%AD%97%E8%8A%82%E7%A0%81%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/03/17/java%E5%AD%97%E8%8A%82%E7%A0%81%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><img src="https://620image.oss-rg-china-mainland.aliyuncs.com/java%E5%AD%97%E8%8A%82%E7%A0%81%E7%BC%96%E7%A8%8B.png" alt="在这里插入图片描述"></p><h2 id="1-javaagent"><a href="#1-javaagent" class="headerlink" title="1. javaagent"></a>1. javaagent</h2><h3 id="1-简述"><a href="#1-简述" class="headerlink" title="1) 简述"></a>1) 简述</h3><p>从java5开始，jdk中新增了一个java.lang.instrument.Instrumentation 类，它提供在运行时重新加载某个类的的class文件的api。<br>通过addTransformer可以加入一个转换器，转换器可以实现对类加载的事件进行拦截并返回转换后新的字节码，通过redefineClasses或retransformClasses都可以触发类的重新加载事件。</p><h3 id="2-加载方式"><a href="#2-加载方式" class="headerlink" title="2)加载方式"></a>2)加载方式</h3><ul><li>在jvm启动时指定agent，Instrumentation对象会通过agent的premain方法传递。</li><li>在jvm启动后通过jvm提供的机制加载agent，Instrumentation对象会通过agent的agentmain方法传递。</li></ul><h3 id="3-主流的作用"><a href="#3-主流的作用" class="headerlink" title="3)主流的作用"></a>3)主流的作用</h3><p>java instrument在很多应用领域都发挥着重要的作用，比如：</p><ul><li>apm：(Application Performance Management)应用性能管理。pinpoint、cat、skywalking等都基于Instrumentation实现</li><li>idea的HotSwap、Jrebel等热部署工具</li><li>应用级故障演练</li><li>Java诊断工具Arthas、Btrace等<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">Btrace开源地址：https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/btraceio/</span>btrace<br>Arthas开源地址：https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/alibaba/</span>arth<br></code></pre></td></tr></table></figure></li></ul><h2 id="2-ASM"><a href="#2-ASM" class="headerlink" title="2.ASM"></a>2.ASM</h2><h3 id="1-什么是ASM"><a href="#1-什么是ASM" class="headerlink" title="1)什么是ASM"></a>1)什么是ASM</h3><p>　　ASM是一个java字节码操纵框架，它能被用来动态生成类或者增强既有类的功能。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。Java class 被存储在严格格式定义的 .class文件里，这些类文件拥有足够的元数据来解析类中的所有元素：类名称、方法、属性以及 Java 字节码（指令）。ASM从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。</p><h3 id="2-如何使用ASM"><a href="#2-如何使用ASM" class="headerlink" title="2)如何使用ASM"></a>2)如何使用ASM</h3><p>　　ASM框架中的核心类有以下几个：<br>　　①  ClassReader:该类用来解析编译过的class字节码文件。<br>　　②  ClassWriter:该类用来重新构建编译后的类，比如说修改类名、属性以及方法，甚至可以生成新的类的字节码文件。<br>　　③  ClassAdapter:该类也实现了ClassVisitor接口，它将对它的方法调用委托给另一个ClassVisitor对象。</p><h3 id="3-样例"><a href="#3-样例" class="headerlink" title="3)样例"></a>3)样例</h3><p>ASM代理方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ASMProxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">getProxy</span><span class="hljs-params">(Class clazz)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br><br>        <span class="hljs-type">ClassReader</span> <span class="hljs-variable">classReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassReader</span>(clazz.getName());<br>        <span class="hljs-type">ClassWriter</span> <span class="hljs-variable">classWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassWriter</span>(classReader, ClassWriter.COMPUTE_MAXS);<br><br><br>        classReader.accept(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassVisitor</span>(ASM5, classWriter) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> MethodVisitor <span class="hljs-title function_">visitMethod</span><span class="hljs-params">(<span class="hljs-type">int</span> access, <span class="hljs-keyword">final</span> String name, String descriptor, String signature, String[] exceptions)</span> &#123;<br><br><br>                <span class="hljs-comment">// 方法过滤</span><br>                <span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;queryUserInfo&quot;</span>.equals(name))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.visitMethod(access, name, descriptor, signature, exceptions);<br><br><br>                <span class="hljs-keyword">final</span> <span class="hljs-type">MethodVisitor</span> <span class="hljs-variable">methodVisitor</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.visitMethod(access, name, descriptor, signature, exceptions);<br><br><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AdviceAdapter</span>(ASM5, methodVisitor, access, name, descriptor) &#123;<br><br><br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMethodEnter</span><span class="hljs-params">()</span> &#123;<br>                        <span class="hljs-comment">// 执行指令；获取静态属性</span><br>                        methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, <span class="hljs-string">&quot;java/lang/System&quot;</span>, <span class="hljs-string">&quot;out&quot;</span>, <span class="hljs-string">&quot;Ljava/io/PrintStream;&quot;</span>);<br>                        <span class="hljs-comment">// 加载常量 load constant</span><br>                        methodVisitor.visitLdcInsn(name + <span class="hljs-string">&quot; 你被代理了，By ASM！&quot;</span>);<br>                        <span class="hljs-comment">// 调用方法</span><br>                        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="hljs-string">&quot;java/io/PrintStream&quot;</span>, <span class="hljs-string">&quot;println&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="hljs-literal">false</span>);<br>                        <span class="hljs-built_in">super</span>.onMethodEnter();<br>                    &#125;<br>                &#125;;<br>            &#125;<br>        &#125;, ClassReader.EXPAND_FRAMES);<br><br><br>        <span class="hljs-type">byte</span>[] bytes = classWriter.toByteArray();<br><br><br>        <span class="hljs-keyword">return</span> (T) <span class="hljs-keyword">new</span> <span class="hljs-title class_">ASMProxy</span>().defineClass(clazz.getName(), bytes, <span class="hljs-number">0</span>, bytes.length).newInstance();<br>    &#125;<br><br><br>&#125;<br><br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_ASMProxy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">IUserApi</span> <span class="hljs-variable">userApi</span> <span class="hljs-operator">=</span> ASMProxy.getProxy(UserApi.class);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">invoke</span> <span class="hljs-operator">=</span> userApi.queryUserInfo();<br>    logger.info(<span class="hljs-string">&quot;测试结果：&#123;&#125;&quot;</span>, invoke);<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试结果：</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * queryUserInfo 你被代理了，By ASM！</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Process finished with exit code 0</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>场景：全链路监控、破解工具包、CGLIB、Spring获取类元数据等<br>点评：这种代理就是使用字节码编程的方式进行处理，它的实现方式相对复杂，而且需要了解Java虚拟机规范相关的知识。因为你的每一步代理操作，都是在操作字节码指令，例如：Opcodes.GETSTATIC、Opcodes.INVOKEVIRTUAL，除了这些还有小200个常用的指令。但这种最接近底层的方式，也是最快的方式。所以在一些使用字节码插装的全链路监控中，会非常常见。</p><h2 id="3-Byte-Buddy"><a href="#3-Byte-Buddy" class="headerlink" title="3. Byte-Buddy"></a>3. Byte-Buddy</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> ByteBuddyProxy &#123;<br><br><br>    <span class="hljs-built_in">public</span> static &lt;T&gt; T getProxy(<span class="hljs-keyword">Class</span> clazz) throws <span class="hljs-keyword">Exception</span> &#123;<br><br><br>        DynamicType.Unloaded&lt;?&gt; dynamicType = <span class="hljs-built_in">new</span> ByteBuddy()<br>                .subclass(clazz)<br>                .<span class="hljs-keyword">method</span>(ElementMatchers.&lt;MethodDescription&gt;named(&quot;queryUserInfo&quot;))<br>                .intercept(MethodDelegation.<span class="hljs-keyword">to</span>(InvocationHandler.<span class="hljs-keyword">class</span>))<br>                .make();<br><br><br>        <span class="hljs-keyword">return</span> (T) dynamicType.<span class="hljs-keyword">load</span>(Thread.currentThread().getContextClassLoader()).getLoaded().newInstance();<br>    &#125;<br><br><br>&#125;<br><br><br>@RuntimeType<br><span class="hljs-built_in">public</span> static <span class="hljs-keyword">Object</span> intercept(@Origin <span class="hljs-keyword">Method</span> <span class="hljs-keyword">method</span>, @AllArguments <span class="hljs-keyword">Object</span>[] args, @SuperCall Callable&lt;?&gt; callable) throws <span class="hljs-keyword">Exception</span> &#123;<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">method</span>.getName() + &quot; 你被代理了，By Byte-Buddy！&quot;);<br>    <span class="hljs-keyword">return</span> callable.<span class="hljs-keyword">call</span>();<br>&#125;<br><br><br>@Test<br><span class="hljs-built_in">public</span> <span class="hljs-type">void</span> test_ByteBuddyProxy() throws <span class="hljs-keyword">Exception</span> &#123;<br>    IUserApi userApi = ByteBuddyProxy.getProxy(UserApi.<span class="hljs-keyword">class</span>);<br>    String invoke = userApi.queryUserInfo();<br>    logger.<span class="hljs-keyword">info</span>(&quot;测试结果：&#123;&#125;&quot;, invoke);<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试结果：</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * queryUserInfo 你被代理了，By Byte-Buddy！</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Process finished with exit code 0</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>场景：AOP切面、类代理、组件、监控、日志<br>点评：Byte Buddy 也是一个字节码操作的类库，但 Byte Buddy 的使用方式更加简单。无需理解字节码指令，即可使用简单的 API 就能很容易操作字节码，控制类和方法。比起JDK动态代理、cglib，Byte Buddy在性能上具有一定的优势。另外，2015年10月，Byte Buddy被 Oracle 授予了 Duke’s Choice大奖。该奖项对Byte Buddy的“ Java技术方面的巨大创新 ”表示赞赏。</p><h2 id="4-Javassist代理方式"><a href="#4-Javassist代理方式" class="headerlink" title="4. Javassist代理方式"></a>4. Javassist代理方式</h2><p>它已加入了开放源代码JBoss 应用服务器项目,通过使用Javassist对字节码操作为JBoss实现动态AOP框架。javassist是jboss的一个子项目，其主要的优点，在于简单，而且快速。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavassistProxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">getProxy</span><span class="hljs-params">(Class clazz)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br><br>        <span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>        <span class="hljs-comment">// 获取类</span><br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass</span> <span class="hljs-operator">=</span> pool.get(clazz.getName());<br>        <span class="hljs-comment">// 获取方法</span><br>        <span class="hljs-type">CtMethod</span> <span class="hljs-variable">ctMethod</span> <span class="hljs-operator">=</span> ctClass.getDeclaredMethod(<span class="hljs-string">&quot;queryUserInfo&quot;</span>);<br>        <span class="hljs-comment">// 方法前加强</span><br>        ctMethod.insertBefore(<span class="hljs-string">&quot;&#123;System.out.println(\&quot;&quot;</span> + ctMethod.getName() + <span class="hljs-string">&quot; 你被代理了，By Javassist\&quot;);&#125;&quot;</span>);<br><br><br>        <span class="hljs-type">byte</span>[] bytes = ctClass.toBytecode();<br><br><br>        <span class="hljs-keyword">return</span> (T) <span class="hljs-keyword">new</span> <span class="hljs-title class_">JavassistProxy</span>().defineClass(clazz.getName(), bytes, <span class="hljs-number">0</span>, bytes.length).newInstance();<br>    &#125;<br><br><br>&#125;<br><br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_JavassistProxy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">IUserApi</span> <span class="hljs-variable">userApi</span> <span class="hljs-operator">=</span> JavassistProxy.getProxy(UserApi.class)<br>    <span class="hljs-type">String</span> <span class="hljs-variable">invoke</span> <span class="hljs-operator">=</span> userApi.queryUserInfo();<br>    logger.info(<span class="hljs-string">&quot;测试结果：&#123;&#125;&quot;</span>, invoke);<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试结果：</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * queryUserInfo 你被代理了，By Javassist</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Process finished with exit code 0</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>场景：全链路监控、类代理、AOP<br>点评：Javassist 是一个使用非常广的字节码插装框架，几乎一大部分非入侵的全链路监控都是会选择使用这个框架。因为它不想ASM那样操作字节码导致风险，同时它的功能也非常齐全。另外，这个框架即可使用它所提供的方式直接编写插装代码，也可以使用字节码指令进行控制生成代码，所以综合来看也是一个非常不错的字节码框架。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于系统监控的想法和实施（一）：数据监控</title>
    <link href="/2023/02/06/%E5%85%B3%E4%BA%8E%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%E7%9A%84%E6%83%B3%E6%B3%95%E5%92%8C%E5%AE%9E%E6%96%BD%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%9B%91%E6%8E%A7/"/>
    <url>/2023/02/06/%E5%85%B3%E4%BA%8E%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%E7%9A%84%E6%83%B3%E6%B3%95%E5%92%8C%E5%AE%9E%E6%96%BD%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%9B%91%E6%8E%A7/</url>
    
    <content type="html"><![CDATA[<p>​大家好，我是爱吃里脊，下面由我来讨论下监控的想法。提到监控，对于维护系统至关重要，对发现问题，解决问题起着决定性的作用。<br>我们来先来进行整体拆解，一个监控系统包含三个主体：数据采集，数据处理，数据展示。这次我们先来了解数据采集。<br>首先要做监控系统首先得有一个监控对象，了解监控对象需要什么指标，比如一个业务后台系统，需要知道物理指标有的cup，磁盘，负载，魔法指标有接口调用数，接口的tp99，接口的可用率等等。一个前端应用，可能需要用户点击某个按钮，某个页面的次数，甚至是记录某个用户行为等等。其实这些指标很多，不同系统差别很大，关注点也会随之改变。要做好一个数据监控系统，就得应对这些变化。下边是具体的一些指标用于参考：</p><ul><li><strong>机器维度</strong>监控指标包括CPU、Load、内存、网络、IO、磁盘等相关指标，详细指标可以参考Liux监控命令对应的指标数据：<a href="https://linux.cn/article-9373-1.html?pr">https://linux.cn/article-9373-1.html?pr</a> （主要可以参见top、vmstat 、free、iostat、netstat 、iptraf等命令相关的核心指标）。</li><li><strong>应用维度</strong>的监控指标包括JVM使用情况、线程池使用情况：JVM情况主要包括YGC次数、时间，FullGC次数、时间，新生代老年代占比；线程池情况主要包括的线程池大小、最大线程数、活跃线程数、队列大小等。</li><li><strong>服务维度</strong>的监控指标包括error日志报错情况、服务接口调用量、耗时、成功率，调用接口调用量、耗时、成功率，dal层操作调用量、耗时、成功率。</li><li><strong>外部依赖维度</strong>主要指应用系统常见的外部依赖的监控情况，主要包括数据库、缓存、消息队列等，这些一般情况都会独立进行部署，对应的机器监控同上面列举的机器维度监控；另外数据库还需要关注连接数、内存使用、SQL调用量、耗时、成功率，慢SQL等；缓存需要关注调用量、成功率，命中率、内存使用等；消息队列需要关注调用量、成功率，队列积压情况、死信队列等</li><li><strong>整体上</strong>的监控指标包括可用性监控（服务是否可用）、访问量监控（PV&#x2F;UV）、负载监控（限流、熔断情况）、自定义的业务监控（异常业务场景、服务统计等）</li></ul><p>​很显然，如果在应用程序里写这些监控处理，是很笨的，业务代码与功能代码耦合，违反了程序软件开发的开闭原则，单一原则。对之后的维护添堵。比较好的方式是机器安装客户端，或者应用集成客户端来进行采集，应用的日志可以通过aop的方式打印上传，为了尽可能的减少对业务代码的影响，可采用独立线程定时同步或者中间件mq，redis等定时同步。这是推日志的方式，对一些实时性较高的监控还可以进行服务端拉取的方式，这种方式较为复杂，需要客户端注册服务到服务中心，服务端获取服务中心服务后，主动请求目标的日志来拉取。</p><p>这里可以举个例子：<br>     push方法用于<a href="https://graphiteapp.org/">Graphite</a>等系统，而pull方法用于<a href="https://prometheus.io/">Prometheus</a>等监视系统。但是无论哪种方式，基本思想都是这种组件化，独立处理，异步上传日志。</p><p>​下边说说日志结构，监控数据包含在日志中，所以日志的输出不能全部写在一个文件处理，需要对日志归档，日志分类，保持日志大小不能过大，保证日志不混乱分析清晰。而且在输出日志前，需要先定义监控数据结构，结构中包含上述所说的种种指标，为后续数据分析和展示做好铺垫。在elk中，es的数据结构是文档格式，在java应用的系统中可以将对象反序列化成json数组，而且es的性能很好，可以做复杂的索引，全文检索，聚合查询，这点可以解决日志问题，但是不是所有监控系统都是用es的，其他存储这点要注意。<br>最后就是配置相关了，好的监控系统需要有运维界面，来实现可配置可插拔，对一些数据指标问题进行报警配置，对于数据收集这块，不可能是所有指标照单全收，而在监控的初期可能不会明确那些不需要，而且监控系统不成熟，那么就需要在开发前期预留配置的扩展点，保证对后续开发的支持。</p><p><img src="https://logflies.oss-cn-chengdu.aliyuncs.com/uPic/2023-01-01%2024123213-20240110095921703-20240110095939351.png"></p>]]></content>
    
    
    <categories>
      
      <category>思考</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>git常用命令行</title>
    <link href="/2022/11/17/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    <url>/2022/11/17/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-Tips"><a href="#Git-Tips" class="headerlink" title="Git Tips"></a>Git Tips</h1><h2 id="安装卸载"><a href="#安装卸载" class="headerlink" title="安装卸载"></a>安装卸载</h2><p><a href="https://git-scm.com/download/linux">官方教程</a>，在 Linux&#x2F;Unix 系统中，通过工具在中安装 <code>git</code>,这种方式比较简单，便于升级卸载工具。</p><p>下面介绍在 CentOS 系统中，通过 yum 来安装 git</p><blockquote><p><strong>Red Hat Enterprise Linux, Oracle Linux, CentOS, Scientific Linux, et al.</strong><br>RHEL and derivatives typically ship older versions of git. You can <a href="https://www.kernel.org/pub/software/scm/git/">download a tarball</a> and build from source, or use a 3rd-party repository such as <a href="https://ius.io/">the IUS Community Project</a> to obtain a more recent version of git.</p></blockquote><p>官方文档说 git 在 <code>RHEL</code> 和衍生产品通常都会发布旧版本的 <code>git</code>，我们需要源码编译安装，或者使用第三方存储库（如<a href="https://ius.io/">IUS社区项目</a>）。</p><p>现在我们通过，<a href="https://ius.io/GettingStarted/">IUS社区</a>下载 <a href="https://centos7.iuscommunity.org/ius-release.rpm">ius-release.rpm</a> 文件进行安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 注意下载不同的版本，本机 CentOS 7</span><br>wget https://centos7.iuscommunity.org/ius-release.rpm<br><span class="hljs-comment"># 安装rpm文件</span><br>rpm -ivh ius-release.rpm<br></code></pre></td></tr></table></figure><p>查看可安装的git安装包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">repoquery --whatprovides git<br><span class="hljs-comment"># git-0:1.8.3.1-13.el7.x86_64</span><br><span class="hljs-comment"># git2u-0:2.16.5-1.ius.centos7.x86_64</span><br><span class="hljs-comment"># git2u-0:2.16.2-1.ius.centos7.x86_64</span><br><span class="hljs-comment"># git2u-0:2.16.4-1.ius.centos7.x86_64</span><br><span class="hljs-comment"># git-0:1.8.3.1-14.el7_5.x86_64</span><br></code></pre></td></tr></table></figure><p><strong>yum 卸载 git 安装新版本</strong></p><p>卸载 <code>1.8.3</code> 的 <code>git</code>，安装 <code>2.16.5</code> 的 <code>git</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 卸载老的版本</span><br>yum remove git<br><span class="hljs-comment"># 安装新的版本</span><br>yum install git2u<br></code></pre></td></tr></table></figure><h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h2><p>首先是配置帐号信息 <code>ssh -T git@github.com</code> 测试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">help</span> config    <span class="hljs-comment"># 获取帮助信息，查看修改个人信息的参数  </span><br>git config --list  <span class="hljs-comment"># 查看配置的信息</span><br>git config --global user.name <span class="hljs-string">&quot;小弟调调&quot;</span>          <span class="hljs-comment"># 修改全局名字</span><br>git config --global user.email <span class="hljs-string">&quot;wowohoo@qq.com&quot;</span>  <span class="hljs-comment"># 修改全局邮箱</span><br>git config --global --<span class="hljs-built_in">unset</span> &lt;entry-name&gt;  <span class="hljs-comment"># 删除全局设置</span><br></code></pre></td></tr></table></figure><h2 id="不常见的使用场景"><a href="#不常见的使用场景" class="headerlink" title="不常见的使用场景"></a>不常见的使用场景</h2><h3 id="忽略文件的权限变化"><a href="#忽略文件的权限变化" class="headerlink" title="忽略文件的权限变化"></a>忽略文件的权限变化</h3><p>不再将文件的权限变化视作改动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config core.fileMode <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="设置大小写敏感"><a href="#设置大小写敏感" class="headerlink" title="设置大小写敏感"></a>设置大小写敏感</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --get core.ignorecase <span class="hljs-comment"># 查看git 的设置</span><br>git config core.ignorecase <span class="hljs-literal">false</span> <span class="hljs-comment"># 设置大小写敏感</span><br>git <span class="hljs-built_in">rm</span> -r --cached &lt;目录/文件&gt;  <span class="hljs-comment"># 远程有俩相同目录，通过这种方式清除掉，然后提交记录</span><br></code></pre></td></tr></table></figure><h3 id="配置自动换行"><a href="#配置自动换行" class="headerlink" title="配置自动换行"></a>配置自动换行</h3><p>自动转换坑太大，提交到git是自动将换行符转换为lf </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global core.autocrlf input<br></code></pre></td></tr></table></figure><h3 id="创建SSH密钥"><a href="#创建SSH密钥" class="headerlink" title="创建SSH密钥"></a>创建SSH密钥</h3><p>这个密钥用来跟 github 通信，在本地终端里生成然后上传到 github</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&#x27;wowohoo@qq.com&#x27;</span> <span class="hljs-comment"># 生成密钥  </span><br>ssh-keygen -t rsa -C <span class="hljs-string">&quot;wowohoo@qq.com&quot;</span> -f ~/.ssh/ww_rsa <span class="hljs-comment"># 指定生成目录文件名字</span><br>ssh -T git@github.com <span class="hljs-comment"># 测试是否成功  </span><br></code></pre></td></tr></table></figure><h3 id="多账号ssh配置"><a href="#多账号ssh配置" class="headerlink" title="多账号ssh配置"></a>多账号ssh配置</h3><p><strong>1.生成指定名字的密钥</strong></p><p><code>ssh-keygen -t rsa -C &quot;邮箱地址&quot; -f ~/.ssh/jslite_rsa</code><br>会生成 <code>jslite_rsa</code> 和 <code>jslite_rsa.pub</code> 这两个文件  </p><p><strong>2.密钥复制到托管平台上</strong></p><p><code>vim ~/.ssh/jslite_rsa.pub</code><br>打开公钥文件 <code>jslite_rsa.pub</code> ，并把内容复制至代码托管平台上   </p><p><strong>3.修改config文件</strong></p><p><code>vim ~/.ssh/config</code> #修改config文件，如果没有创建 <code>config</code>  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">Host jslite.github.com<br>  HostName github.com<br>  User git<br>  IdentityFile ~/.ssh/jslite_rsa<br><br>Host work.github.com<br>  HostName github.com<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">Port 服务器open-ssh端口（默认：22,默认时一般不写此行）</span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">PreferredAuthentications 配置登录时用什么权限认证</span> <br><span class="hljs-meta prompt_">  # </span><span class="language-bash">                         publickey|password publickey|keyboard-interactive等</span><br>  User git<br>  IdentityFile ~/.ssh/work_rsa<br></code></pre></td></tr></table></figure><ul><li><code>Host</code> 这里是个别名可以随便命名</li><li><code>HostName</code> 一般是网站如：<code>git@ss.github.com:username/repo.git</code> 填写 <code>github.com</code></li><li><code>User</code> 通常填写<code>git</code></li><li><code>IdentityFile</code> 使用的公钥文件地址</li></ul><p><strong>4.测试</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -T git@jslite.github.com  <span class="hljs-comment"># `@`后面跟上定义的Host  </span><br>ssh -T work.github.com        <span class="hljs-comment"># 通过别名测试</span><br>ssh -i ~/公钥文件地址 Host别名  <span class="hljs-comment"># 如 ssh -i ~/.ssh/work_rsa work.github.com</span><br></code></pre></td></tr></table></figure><p><strong>5.使用</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 原来的写法</span><br>git <span class="hljs-built_in">clone</span> git@github.com:&lt;jslite的用户名&gt;/learngit.git<br><span class="hljs-comment"># 现在的写法</span><br>git <span class="hljs-built_in">clone</span> git@jslite.github.com:&lt;jslite的用户名&gt;/learngit.git<br>git <span class="hljs-built_in">clone</span> git@work.github.com:&lt;work的用户名&gt;/learngit.git<br></code></pre></td></tr></table></figure><p><strong>5.注意</strong></p><p>如果你修改了id_rsa的名字，你需要将ssh key添加到SSH agent中，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-add ~/.ssh/jslite_rsa<br>ssh-add -l  <span class="hljs-comment"># 查看所有的key</span><br>ssh-add -D  <span class="hljs-comment"># 删除所有的key</span><br>ssh-add -d  ~/.ssh/jslite_rsa <span class="hljs-comment"># 删除指定的key</span><br></code></pre></td></tr></table></figure><h3 id="免密码登录远程服务器"><a href="#免密码登录远程服务器" class="headerlink" title="免密码登录远程服务器"></a>免密码登录远程服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-keygen -t rsa -P <span class="hljs-string">&#x27;&#x27;</span> -f ~/.ssh/aliyunserver.key<br>$ ssh-copy-id -i ~/.ssh/aliyunserver.key.pub root@192.168.182.112 <span class="hljs-comment"># 这里需要输入密码一次</span><br></code></pre></td></tr></table></figure><p>编辑 <code>~/.ssh/config</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">Host aliyun1<br>  HostName 192.168.182.112<br>  User root<br>  PreferredAuthentications publickey<br>  IdentityFile ~/.ssh/aliyunserver.key<br></code></pre></td></tr></table></figure><p>上面配置完了，可以通过命令登录，不需要输入IP地址和密码 <code>ssh aliyun1</code></p><h3 id="https协议下提交代码免密码"><a href="#https协议下提交代码免密码" class="headerlink" title="https协议下提交代码免密码"></a>https协议下提交代码免密码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/username/rep.git<br></code></pre></td></tr></table></figure><p>通过上面方式克隆可能需要密码，解决办法：进入当前克隆的项目 <code>vi rep/.git/config</code> 编辑 <code>config</code>, 按照下面方式修改，你就可以提交代码不用输入密码了。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs diff">[core]<br>repositoryformatversion = 0<br>filemode = true<br>bare = false<br>logallrefupdates = true<br>ignorecase = true<br>precomposeunicode = true<br>[remote &quot;origin&quot;]<br><span class="hljs-deletion">-url = https://github.com/username/rep.git</span><br><span class="hljs-addition">+url = https://用户名:密码@github.com/username/rep.git</span><br>fetch = +refs/heads/*:refs/remotes/origin/*<br>[branch &quot;master&quot;]<br>remote = origin<br>merge = refs/heads/master<br></code></pre></td></tr></table></figure><h3 id="文件推向3个git库"><a href="#文件推向3个git库" class="headerlink" title="文件推向3个git库"></a>文件推向3个git库</h3><p><strong>1. 增加3个远程库地址</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote add origin https://github.com/JSLite/JSLite.git  <br>git remote set-url --add origin https://gitlab.com/wang/JSLite.js.git  <br>git remote set-url --add origin https://oschina.net/wang/JSLite.js.git  <br></code></pre></td></tr></table></figure><p><strong>2. 删除其中一个 set-url 地址</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">usage: git remote set-url [--push] &lt;name&gt; &lt;newurl&gt; [&lt;oldurl&gt;]<br>   or: git remote set-url --add &lt;name&gt; &lt;newurl&gt;<br>   or: git remote set-url --delete &lt;name&gt; &lt;url&gt;<br></code></pre></td></tr></table></figure><p><code>git remote set-url --delete origin https://oschina.net/wang/JSLite.js.git</code></p><p><strong>3.推送代码</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin master<br>git push -f origin master  <span class="hljs-comment"># 强制推送  </span><br></code></pre></td></tr></table></figure><p><strong>4.拉代码</strong></p><p>只能拉取 <code>origin</code> 里的一个url地址，这个fetch-url<br>默认为你添加的到 <code>origin</code>的第一个地址  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">git pull origin master   <br>git pull --all # 获取远程所有内容包括tag  <br>git pull origin next:master # 取回origin主机的next分支，与本地的master分支合并  <br>git pull origin next # 远程分支是与当前分支合并  <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">上面一条命令等同于下面两条命令</span>   <br>git fetch origin  <br>git merge origin/next  <br></code></pre></td></tr></table></figure><p>如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。<br>但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git pull -p</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">等同于下面的命令</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git fetch --prune origin</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git fetch -p</span><br></code></pre></td></tr></table></figure><p><strong>5.更改pull</strong></p><p>只需要更改config文件里，那三个url的顺序即可，fetch-url会直接对应排行第一的那个utl连接。    </p><h3 id="修改远程仓库地址"><a href="#修改远程仓库地址" class="headerlink" title="修改远程仓库地址"></a>修改远程仓库地址</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote remove origin  <span class="hljs-comment"># 删除该远程路径  </span><br>git remote add origin git@jslite.github.com:JSLite/JSLite.git  <span class="hljs-comment"># 添加远程路径 </span><br></code></pre></td></tr></table></figure><h3 id="撤销远程记录"><a href="#撤销远程记录" class="headerlink" title="撤销远程记录"></a>撤销远程记录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset --hard HEAD~1 # 撤销一条记录   <br>git push -f origin HEAD:master # 同步到远程仓库  <br></code></pre></td></tr></table></figure><h3 id="放弃本地的文件修改"><a href="#放弃本地的文件修改" class="headerlink" title="放弃本地的文件修改"></a>放弃本地的文件修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset --hard FETCH_HEAD # FETCH_HEAD表示上一次成功git pull之后形成的commit点。然后git pull<br></code></pre></td></tr></table></figure><p><code>git reset --hard FETCH_HEAD</code> 出现错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull<br>You are not currently on a branch, so I cannot use any<br><span class="hljs-string">&#x27;branch.&lt;branchname&gt;.merge&#x27;</span> <span class="hljs-keyword">in</span> your configuration file.<br>Please specify <span class="hljs-built_in">which</span> remote branch you want to use on the <span class="hljs-built_in">command</span><br>line and try again (e.g. <span class="hljs-string">&#x27;git pull &lt;repository&gt; &lt;refspec&gt;&#x27;</span>).<br>See git-pull(1) FOR details.<br></code></pre></td></tr></table></figure><p>解决方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b temp <span class="hljs-comment"># 新建+切换到temp分支 </span><br>git checkout master<br></code></pre></td></tr></table></figure><h3 id="最简单放弃本地修改内容"><a href="#最简单放弃本地修改内容" class="headerlink" title="最简单放弃本地修改内容"></a>最简单放弃本地修改内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 如果有的修改以及加入暂存区的话</span><br>git reset --hard <br><span class="hljs-comment"># 还原所有修改，不会删除新增的文件</span><br>git checkout . <br><span class="hljs-comment"># 下面命令会删除新增的文件</span><br>git clean -xdf<br></code></pre></td></tr></table></figure><p>通过存储暂存区stash，在删除暂存区的方法放弃本地修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash &amp;&amp; git stash drop <br></code></pre></td></tr></table></figure><h3 id="回退到某一个版本"><a href="#回退到某一个版本" class="headerlink" title="回退到某一个版本"></a>回退到某一个版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard &lt;<span class="hljs-built_in">hash</span>&gt;<br><span class="hljs-comment"># 例如 git reset --hard a3hd73r</span><br><span class="hljs-comment"># --hard代表丢弃工作区的修改，让工作区与版本代码一模一样，与之对应，</span><br><span class="hljs-comment"># --soft参数代表保留工作区的修改。</span><br></code></pre></td></tr></table></figure><h3 id="搜索-commit-历史记录"><a href="#搜索-commit-历史记录" class="headerlink" title="搜索 commit 历史记录"></a>搜索 commit 历史记录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git log --grep=224<br><span class="hljs-meta prompt_"># </span><span class="language-bash">这条命令是查看含有 <span class="hljs-string">&quot;224&quot;</span> 关键字的 git commit</span> <br></code></pre></td></tr></table></figure><h3 id="回滚到某个commit提交"><a href="#回滚到某个commit提交" class="headerlink" title="回滚到某个commit提交"></a>回滚到某个commit提交</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git revert HEAD~1 # 撤销一条记录 会弹出 commit 编辑<br>git push # 提交回滚<br></code></pre></td></tr></table></figure><h3 id="去掉某个commit"><a href="#去掉某个commit" class="headerlink" title="去掉某个commit"></a>去掉某个commit</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 实质是新建了一个与原来完全相反的commit，抵消了原来commit的效果</span><br>git revert &lt;commit-hash&gt; <br></code></pre></td></tr></table></figure><h3 id="把-A-分支的某一个-commit，放到-B-分支上"><a href="#把-A-分支的某一个-commit，放到-B-分支上" class="headerlink" title="把 A 分支的某一个 commit，放到 B 分支上"></a>把 A 分支的某一个 commit，放到 B 分支上</h3><p>对两个分支，同时都拥有的文件，进行修改后，再同时 <code>commit</code> 到这两个分支，比如 <code>master</code> 分支和 <code>branch1</code> 分支，都拥有文件 <code>test.js</code> ，在 <code>master</code> 或者 <code>branch1</code> 分支下对 <code>test.js</code> 进行修改后，把修改的 <code>test.js</code> 同时提交到 <code>master</code> 分支和 <code>branch1</code> 分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout &lt;branch-name&gt; &amp;&amp; git cherry-pick &lt;commit-id&gt;<br></code></pre></td></tr></table></figure><h3 id="获取最近一次提交的-commit-id"><a href="#获取最近一次提交的-commit-id" class="headerlink" title="获取最近一次提交的 commit id"></a>获取最近一次提交的 commit id</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git rev-parse HEAD <span class="hljs-comment"># e10721cb8859b2cd340d31a52ef4bf4b9629ddda</span><br>git rev-parse --short HEAD <span class="hljs-comment"># e10721c</span><br></code></pre></td></tr></table></figure><h3 id="两个-git-仓库合并"><a href="#两个-git-仓库合并" class="headerlink" title="两个 git 仓库合并"></a>两个 git 仓库合并</h3><p>现在有两个仓库 <a href="https://github.com/kktjs/kkt.git">kktjs&#x2F;kkt</a> 和 <a href="https://github.com/kktjs/kkt-next.git">kktjs&#x2F;kkt-next</a> 我们需要将 <code>kkt-next</code> 仓库合并到 <code>kkt</code> 并保留 <code>kkt-next</code> 的所有提交内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 克隆主仓库代码</span><br>git <span class="hljs-built_in">clone</span> git@github.com:kktjs/kkt.git<br><span class="hljs-comment"># 2. 将 kkt-next 作为远程仓库，添加到 kkt 中，设置别名为 other</span><br>git remote add other git@github.com:kktjs/kkt-next.git<br><span class="hljs-comment"># 3. 从 kkt-next 仓库中拉取数据到本仓库</span><br>git fetch other<br><span class="hljs-comment"># 4. 将 kkt-next 仓库拉取的 master 分支作为新分支 checkout 到本地，新分支名设定为 kkt-next</span><br>git checkout -b kkt-next other/master<br><span class="hljs-comment"># 5. 切换回 kkt 的 master 分支</span><br>git checkout master<br><span class="hljs-comment"># 6. 将 kkt-next 合并入 kkt 的 master 分支</span><br>git merge kkt-next<br><span class="hljs-comment"># 如果第 6 步报错 `fatal: refusing to merge unrelated histories`</span><br><span class="hljs-comment"># 请执行下面命令 ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span><br>git merge kkt-next --allow-unrelated-histories<br></code></pre></td></tr></table></figure><p>在合并时有可能两个分支对同一个文件都做了修改，这时需要解决冲突，对文本文件来说很简单，根据需要对冲突的位置进行处理就可以。对于二进制文件，需要用到如下命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout --theirs YOUR_BINARY_FILES     <span class="hljs-comment"># 保留需要合并进来的分支的修改</span><br>git checkout --ours YOUR_BINARY_FILES       <span class="hljs-comment"># 保留自己的修改</span><br>git add YOUR_BINARY_FILES<br></code></pre></td></tr></table></figure><h3 id="合并多个commit"><a href="#合并多个commit" class="headerlink" title="合并多个commit"></a>合并多个commit</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这个命令，将最近4个commit合并为1个，HEAD代表当前版本。</span><br><span class="hljs-comment"># 将进入VIM界面，你可以修改提交信息。</span><br>git rebase -i HEAD~4 <br><span class="hljs-comment"># 可以看到其中分为两个部分，上方未注释的部分是填写要执行的指令，</span><br><span class="hljs-comment"># 而下方注释的部分则是指令的提示说明。指令部分中由前方的命令名称、commit hash 和 commit message 组成</span><br><span class="hljs-comment"># 当前我们只要知道 pick 和 squash 这两个命令即可。</span><br><span class="hljs-comment"># --&gt; pick 的意思是要会执行这个 commit</span><br><span class="hljs-comment"># --&gt; squash 的意思是这个 commit 会被合并到前一个commit</span><br><br><span class="hljs-comment"># 我们将 需要保留的 这个 commit 前方的命令改成 squash 或 s，然后输入:wq以保存并退出</span><br><span class="hljs-comment"># 这是我们会看到 commit message 的编辑界面</span><br><br><span class="hljs-comment"># 其中, 非注释部分就是两次的 commit message, 你要做的就是将这两个修改成新的 commit message。</span><br><span class="hljs-comment"># </span><br><span class="hljs-comment"># 输入wq保存并推出, 再次输入git log查看 commit 历史信息，你会发现这两个 commit 已经合并了。</span><br><span class="hljs-comment"># 将修改强制推送到前端</span><br>git push -f origin master<br></code></pre></td></tr></table></figure><h3 id="修改远程Commit记录"><a href="#修改远程Commit记录" class="headerlink" title="修改远程Commit记录"></a>修改远程Commit记录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit --amend<br><span class="hljs-comment"># amend只能修改没有提交到线上的，最后一次commit记录</span><br>git rebase -i HEAD~3<br><span class="hljs-comment"># 表示要修改当前版本的倒数第三次状态</span><br><span class="hljs-comment"># 将要更改的记录行首单词 pick 改为 edit</span><br>pick 96dc3f9 doc: Update quick-start.md<br>pick f1cce8a <span class="hljs-built_in">test</span>(Transition):Add transition <span class="hljs-built_in">test</span> (#47)<br>pick 6293516 feat(Divider): Add Divider component.<br><span class="hljs-comment"># Rebase eeb03a4..6293516 onto eeb03a4 (3 commands)</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Commands:</span><br><span class="hljs-comment"># p, pick = use commit</span><br><span class="hljs-comment"># r, reword = use commit, but edit the commit message</span><br><span class="hljs-comment"># e, edit = use commit, but stop for amending</span><br><span class="hljs-comment"># s, squash = use commit, but meld into previous commit</span><br><span class="hljs-comment"># f, fixup = like &quot;squash&quot;, but discard this commit&#x27;s log message</span><br><span class="hljs-comment"># x, exec = run command (the rest of the line) using shell</span><br><span class="hljs-comment"># d, drop = remove commit</span><br></code></pre></td></tr></table></figure><p>保存并退出，会弹出下面提示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># You can amend the commit now, with</span><br><span class="hljs-comment"># </span><br><span class="hljs-comment">#   git commit --amend</span><br><span class="hljs-comment"># </span><br><span class="hljs-comment"># Once you are satisfied with your changes, run</span><br><span class="hljs-comment"># </span><br><span class="hljs-comment">#   git rebase --continue</span><br><br><span class="hljs-comment"># 通过这条命令进入编辑页面更改commit，保存退出</span><br>git commit --amend<br><span class="hljs-comment"># 保存退出确认修改，继续执行 rebase, </span><br>git rebase --<span class="hljs-built_in">continue</span><br><span class="hljs-comment"># 如果修改多条记录反复执行上面两条命令直到完成所有修改</span><br><br><span class="hljs-comment"># 最后，确保别人没有提交进行push，最好不要加 -f 强制推送</span><br>git push -f origin master<br></code></pre></td></tr></table></figure><h3 id="利用commit关闭一个issue"><a href="#利用commit关闭一个issue" class="headerlink" title="利用commit关闭一个issue"></a>利用commit关闭一个issue</h3><p>这个功能在Github上可以玩儿，Gitlab上特别老的版本不能玩儿哦，那么如何跟随着commit关闭一个issue呢? 在confirm merge的时候可以使用一下命令来关闭相关issue:  </p><p><code>fixes #xxx</code>、 <code>fixed #xxx</code>、 <code>fix #xxx</code>、 <code>closes #xxx</code>、 <code>close #xxx</code>、 <code>closed #xxx</code>、</p><h3 id="新建一个空分支"><a href="#新建一个空分支" class="headerlink" title="新建一个空分支"></a>新建一个空分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这种方式新建的分支(gh-pages)是没有 commit 记录的</span><br>git checkout --orphan gh-pages<br><span class="hljs-comment"># 删除新建的gh-pages分支原本的内容，如果不删除，提交将作为当前分支的第一个commit</span><br>git <span class="hljs-built_in">rm</span> -rf .<br><span class="hljs-comment"># 查看一下状态 有可能上面一条命令，没有删除还没有提交的的文件</span><br>git state <br></code></pre></td></tr></table></figure><h3 id="添加忽略文件"><a href="#添加忽略文件" class="headerlink" title="添加忽略文件"></a>添加忽略文件</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">echo</span> node_modules/ &gt;&gt; <span class="hljs-string">.gitignore</span><br></code></pre></td></tr></table></figure><h3 id="忽略某个文件的改动"><a href="#忽略某个文件的改动" class="headerlink" title="忽略某个文件的改动"></a>忽略某个文件的改动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git update-index --assume-unchanged path/to/file <span class="hljs-comment"># 关闭 track 指定文件的改动，也就是 Git 将不会在记录这个文件的改动</span><br>git update-index --no-assume-unchanged path/to/file <span class="hljs-comment"># 恢复 track 指定文件的改动</span><br></code></pre></td></tr></table></figure><h3 id="同步fork的上游仓库"><a href="#同步fork的上游仓库" class="headerlink" title="同步fork的上游仓库"></a>同步fork的上游仓库</h3><p><a href="https://help.github.com/articles/syncing-a-fork/">Github教程同步fork教程</a>，<a href="http://www.miss77.net/549.html">在Github上同步一个分支(fork)</a>  </p><p><strong>设置添加多个远程仓库地址。</strong></p><p>在同步之前，需要创建一个远程点指向上游仓库(repo).如果你已经派生了一个原始仓库，可以按照如下方法做。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git remote -v</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">List the current remotes （列出当前远程仓库）</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">origin  https://github.com/user/repo.git (fetch)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">origin  https://github.com/user/repo.git (push)</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git remote add upstream https://github.com/otheruser/repo.git</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Set a new remote (设置一个新的远程仓库)</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git remote -v</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Verify new remote (验证新的原唱仓库)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">origin    https://github.com/user/repo.git (fetch)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">origin    https://github.com/user/repo.git (push)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">upstream  https://github.com/otheruser/repo.git (fetch)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">upstream  https://github.com/otheruser/repo.git (push)</span><br></code></pre></td></tr></table></figure><p><strong>同步更新仓库内容</strong></p><p>同步上游仓库到你的仓库需要执行两步：首先你需要从远程拉去，之后你需要合并你希望的分支到你的本地副本分支。从上游的存储库中提取分支以及各自的提交内容。 <code>master</code> 将被存储在本地分支机构 <code>upstream/master</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">git fetch upstream<br><span class="hljs-meta prompt_"># </span><span class="language-bash">remote: Counting objects: 75, <span class="hljs-keyword">done</span>.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">remote: Compressing objects: 100% (53/53), <span class="hljs-keyword">done</span>.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">remote: Total 62 (delta 27), reused 44 (delta 9)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Unpacking objects: 100% (62/62), <span class="hljs-keyword">done</span>.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">From https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> * [new branch]      master     -&gt; upstream/master</span><br></code></pre></td></tr></table></figure><p>检查你的 fork’s 本地 <code>master</code> 分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout master<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Switched to branch <span class="hljs-string">&#x27;master&#x27;</span></span><br></code></pre></td></tr></table></figure><p>合并来自 <code>upstream/master</code> 的更改到本地 master  分支上。  这使你的前 fork’s <code>master</code> 分支与上游资源库同步，而不会丢失你本地修改。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">git merge upstream/master<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Updating a422352..5fdff0f</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Fast-forward</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> README                    |    9 -------</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> README.md                 |    7 ++++++</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> 2 files changed, 7 insertions(+), 9 deletions(-)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> delete mode 100644 README</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> create mode 100644 README.md</span><br></code></pre></td></tr></table></figure><h3 id="手动合并冲突的-Pull-Request"><a href="#手动合并冲突的-Pull-Request" class="headerlink" title="手动合并冲突的 Pull Request"></a>手动合并冲突的 Pull Request</h3><p>以 <a href="https://github.com/tsbbjs/tsbb">tsbbjs&#x2F;tsbb</a> 为例，合并来自 <a href="https://github.com/jaywcjlove/tsbb">jaywcjlove&#x2F;tsbb</a> master分支的 <code>Pull Request</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 克隆主仓库</span><br>git <span class="hljs-built_in">clone</span> git@github.com:tsbbjs/tsbb.git <br><span class="hljs-comment"># 2. 在主仓库 master 分支切个 jaywcjlove-master 分支出来，并且切换到 jaywcjlove-master 分支</span><br>git checkout -b jaywcjlove-master master<br><span class="hljs-comment"># 3. 获取 jaywcjlove/tsbb 仓库 master 分支最新代码</span><br>git pull https://github.com/jaywcjlove/tsbb.git master<br><span class="hljs-comment"># ⚠️ 注意下面是输出内容：</span><br><span class="hljs-comment"># ----------------------</span><br><span class="hljs-comment"># Auto-merging src/babel/transform.ts</span><br><span class="hljs-comment"># CONFLICT (content): Merge conflict in src/babel/transform.ts</span><br><span class="hljs-comment"># ----------------------</span><br><span class="hljs-comment"># ⚠️ 注意上面 CONFLICT 标识是有冲突无法自动合并的代码，根据路径进入代码手动合并</span><br><span class="hljs-comment"># 4. 合并完成之后，进行 commit 说明合并内容</span><br>git commit -m <span class="hljs-string">&quot;Merge branch &#x27;master&#x27; of github.com:jaywcjlove/tsbb #3&quot;</span><br><span class="hljs-comment"># 5. 切换到 master 分支，如果是 PR 其它分支，这里就切其它分支</span><br>git checkout master<br><span class="hljs-comment"># 6. 合并 jaywcjlove-master 分支的代码</span><br>git merge --no-ff jaywcjlove-master<br><span class="hljs-comment"># 7. 提交代码</span><br>git push origin master<br></code></pre></td></tr></table></figure><h3 id="修改作者名"><a href="#修改作者名" class="headerlink" title="修改作者名"></a>修改作者名</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> commit --amend --author=<span class="hljs-string">&#x27;Author Name &lt;email<span class="hljs-variable">@address</span>.com&gt;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="批量修改历史commit中的名字和邮箱"><a href="#批量修改历史commit中的名字和邮箱" class="headerlink" title="批量修改历史commit中的名字和邮箱"></a>批量修改历史commit中的名字和邮箱</h3><p>这是 <a href="https://help.github.com/articles/changing-author-info/">Github官方教程</a></p><p><strong>1.克隆仓库</strong></p><p>注意参数，这个不是普通的clone，clone下来的仓库并不能参与开发</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> --bare https://github.com/user/repo.git<br><span class="hljs-built_in">cd</span> repo.git<br></code></pre></td></tr></table></figure><p><strong>2.命令行中运行代码</strong></p><p>OLD_EMAIL原来的邮箱<br>CORRECT_NAME更正的名字<br>CORRECT_EMAIL更正的邮箱  </p><p>将下面代码复制放到命令行中执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">git filter-branch -f --env-filter <span class="hljs-string">&#x27;</span><br><span class="hljs-string">OLD_EMAIL=&quot;wowohoo@qq.com&quot;</span><br><span class="hljs-string">CORRECT_NAME=&quot;小弟调调&quot;</span><br><span class="hljs-string">CORRECT_EMAIL=&quot;更正的邮箱@qq.com&quot;</span><br><span class="hljs-string">if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]</span><br><span class="hljs-string">then</span><br><span class="hljs-string">    export GIT_COMMITTER_NAME=&quot;$CORRECT_NAME&quot;</span><br><span class="hljs-string">    export GIT_COMMITTER_EMAIL=&quot;$CORRECT_EMAIL&quot;</span><br><span class="hljs-string">fi</span><br><span class="hljs-string">if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]</span><br><span class="hljs-string">then</span><br><span class="hljs-string">    export GIT_AUTHOR_NAME=&quot;$CORRECT_NAME&quot;</span><br><span class="hljs-string">    export GIT_AUTHOR_EMAIL=&quot;$CORRECT_EMAIL&quot;</span><br><span class="hljs-string">fi</span><br><span class="hljs-string">&#x27;</span> --tag-name-filter <span class="hljs-built_in">cat</span> -- --branches --tags<br></code></pre></td></tr></table></figure><p>执行过程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">Rewrite 160d4df2689ff6df3820563bfd13b5f1fb9ba832 (479/508) (16 seconds passed, remaining 0 predicted)<br>Ref <span class="hljs-string">&#x27;refs/heads/dev&#x27;</span> was rewritten<br>Ref <span class="hljs-string">&#x27;refs/heads/master&#x27;</span> was rewritten<br></code></pre></td></tr></table></figure><p><strong>3.同步到远程仓库</strong></p><p>同步到push远程git仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push --force --tags origin <span class="hljs-string">&#x27;refs/heads/*&#x27;</span><br></code></pre></td></tr></table></figure><p>我还遇到了如下面错误，lab默认给master分支加了保护，不允许强制覆盖。<code>Project(项目)</code>-&gt;<code>Setting</code>-&gt;<code>Repository</code> 菜单下面的<code>Protected branches</code>把master的保护去掉就可以了。修改完之后，建议把master的保护再加回来，毕竟强推不是件好事。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">remote: GitLab: You are not allowed to force push code to a protected branch on this project.<br></code></pre></td></tr></table></figure><p>当上面的push 不上去的时候，先 <code>git pull</code> 确保最新代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull  --allow-unrelated-histories<br><span class="hljs-comment"># 或者指定分枝</span><br>git pull origin master --allow-unrelated-histories<br></code></pre></td></tr></table></figure><p><strong>4. 删除仓库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ..<br><span class="hljs-built_in">rm</span> -rf repo.git<br></code></pre></td></tr></table></figure><h3 id="查看两个星期内的改动"><a href="#查看两个星期内的改动" class="headerlink" title="查看两个星期内的改动"></a>查看两个星期内的改动</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git whatchanged --since</span>=<span class="hljs-string">&#x27;2 weeks ago&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="查看某个文件历史"><a href="#查看某个文件历史" class="headerlink" title="查看某个文件历史"></a>查看某个文件历史</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">git log --pretty=oneline 文件名  # 列出文件的所有改动历史  <br>git show c178bf49   # 某次的改动的修改记录  <br>git log -p c178bf49 # 某次的改动的修改记录  <br>git blame 文件名     # 显示文件的每一行是在那个版本最后修改。  <br>git whatchanged 文件名  # 显示某个文件的每个版本提交信息：提交日期，提交人员，版本号，提交备注（没有修改细节）  <br></code></pre></td></tr></table></figure><h3 id="查看git仓库中最近修改的分支"><a href="#查看git仓库中最近修改的分支" class="headerlink" title="查看git仓库中最近修改的分支"></a>查看git仓库中最近修改的分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git for-each-ref --count=30 --<span class="hljs-built_in">sort</span>=-committerdate refs/heads/ --format=<span class="hljs-string">&#x27;%(refname:short)&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="更新所有本地分支"><a href="#更新所有本地分支" class="headerlink" title="更新所有本地分支"></a>更新所有本地分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch \<br>  --format <span class="hljs-string">&quot;%(if)%(upstream:short)%(then)git push . %(upstream:short):%(refname:short)%(end)&quot;</span> |<br>  sh<br></code></pre></td></tr></table></figure><h3 id="打造自己的git命令"><a href="#打造自己的git命令" class="headerlink" title="打造自己的git命令"></a>打造自己的git命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">git config --global alias.st status<br>git config --global alias.br branch<br>git config --global alias.co checkout<br>git config --global alias.ci commit<br></code></pre></td></tr></table></figure><p>配置好后再输入git命令的时候就不用再输入一大段了，例如我们要查看状态，只需：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git st<br></code></pre></td></tr></table></figure><h3 id="删除已经合并到-master-的分支"><a href="#删除已经合并到-master-的分支" class="headerlink" title="删除已经合并到 master 的分支"></a>删除已经合并到 master 的分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch --merged master | grep -v <span class="hljs-string">&#x27;^\*\|  master&#x27;</span> | xargs -n 1 git branch -d<br></code></pre></td></tr></table></figure><h3 id="中文乱码的解决方案"><a href="#中文乱码的解决方案" class="headerlink" title="中文乱码的解决方案"></a>中文乱码的解决方案</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global core.quotepath <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="提交一个空文件夹"><a href="#提交一个空文件夹" class="headerlink" title="提交一个空文件夹"></a>提交一个空文件夹</h3><p>在空文件夹中建立一个文件 <code>.gitkeep</code>, 你就可以提交这个空文件夹了。</p><h2 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h2><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p><code>git init</code> #初始化  </p><h3 id="status"><a href="#status" class="headerlink" title="status"></a>status</h3><p><code>git status</code> #获取状态  </p><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><p><code>git add file</code> # .或*代表全部添加<br><code>git rm --cached &lt;added_file_to_undo&gt;</code> # 在commit之前撤销git add操作<br><code>git reset head</code> # 好像比上面<code>git rm --cached</code>更方便  </p><h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><p><code>git commit -m &quot;message&quot;</code> #此处注意乱码  </p><h3 id="remote"><a href="#remote" class="headerlink" title="remote"></a>remote</h3><p><code>git remote add origin git@github.com:JSLite/test.git</code> #添加源  </p><h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push -u origin master <span class="hljs-comment"># push同事设置默认跟踪分支  </span><br>git push origin master  <br>git push -f origin master <span class="hljs-comment"># 强制推送文件，缩写 -f（全写--force）</span><br></code></pre></td></tr></table></figure><h2 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git://github.com/JSLite/JSLite.js.git   <br>git <span class="hljs-built_in">clone</span> git://github.com/JSLite/JSLite.js.git --depth=1  <br>git <span class="hljs-built_in">clone</span> git://github.com/JSLite/JSLite.js.git mypro <span class="hljs-comment"># 克隆到自定义文件夹  </span><br>git <span class="hljs-built_in">clone</span> [user@]example.com:path/to/repo.git/ <span class="hljs-comment"># SSH协议还有另一种写法。  </span><br></code></pre></td></tr></table></figure><p>git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。<code>git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</code>  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> http[s]://example.com/path/to/repo.git/</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> ssh://example.com/path/to/repo.git/</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> ssh://example.com/path/to/repo.git/</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> git://example.com/path/to/repo.git/</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> /opt/git/project.git</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> file:///opt/git/project.git</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> ftp[s]://example.com/path/to/repo.git/</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> rsync://example.com/path/to/repo.git/</span><br></code></pre></td></tr></table></figure><h2 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h2><h3 id="help"><a href="#help" class="headerlink" title="help"></a>help</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">help</span> config <span class="hljs-comment"># 获取帮助信息  </span><br></code></pre></td></tr></table></figure><h3 id="add-1"><a href="#add-1" class="headerlink" title="add"></a>add</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add *   # 跟踪新文件   <br>git add -u [path]   # 添加[指定路径下]已跟踪文件   <br></code></pre></td></tr></table></figure><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm *&amp;git rm *          # 移除文件  <br>git rm -f *            # 移除文件  <br>git rm --cached *      # 取消跟踪  <br>git mv file_from file_to  # 重命名跟踪文件  <br>git log   # 查看提交记录  <br></code></pre></td></tr></table></figure><h3 id="commit-1"><a href="#commit-1" class="headerlink" title="commit"></a>commit</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">git commit #提交更新   <br>git commit -m &#x27;message&#x27; #提交说明   <br>git commit -a #跳过使用暂存区域，把所有已经跟踪过的文件暂存起来一并提交   <br>git commit --amend #修改最后一次提交   <br>git commit log #查看所有提交，包括没有push的commit    <br>git commit -m &quot;#133&quot; #关联issue 任意位置带上# 符号加上issue号码  <br>git commit -m &quot;fix #133&quot; commit关闭issue  <br>git commit -m &#x27;概要描述&#x27;$&#x27;\n\n&#x27;&#x27;1.详细描述&#x27;$&#x27;\n&#x27;&#x27;2.详细描述&#x27; #提交简要描述和详细描述  <br></code></pre></td></tr></table></figure><h3 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset HEAD *  # 取消已经暂存的文件   <br>git reset --mixed HEAD * # 同上   <br>git reset --soft HEAD *  # 重置到指定状态，不会修改索引区和工作树   <br>git reset --hard HEAD *  # 重置到指定状态，会修改索引区和工作树   <br>git reset -- files *     # 重置index区文件   <br></code></pre></td></tr></table></figure><h3 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git revert HEAD   # 撤销前一次操作   <br>git revert HEAD~  # 撤销前前一次操作   <br>git revert commit # 撤销指定操作   <br></code></pre></td></tr></table></figure><h3 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout -- file  # 取消对文件的修改（从暂存区——覆盖worktree file）  <br>git checkout branch|tag|commit -- file_name  # 从仓库取出file覆盖当前分支   <br>git checkout HEAD~1 [文件]  # 将会更新 working directory 去匹配某次 commit   <br>git checkout -- .          # 从暂存区取出文件覆盖工作区   <br>git checkout -b gh-pages  0c304c9  # 这个表示 从当前分支 commit 哈希值为 0c304c9 的节点，分一个新的分支gh-pages出来，并切换到 gh-pages   <br></code></pre></td></tr></table></figure><h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">git diff file     # 查看指定文件的差异   <br>git diff --stat   # 查看简单的diff结果   <br>git diff          # 比较 Worktree 和 Index 之间的差异   <br>git diff --cached   # 比较Index和HEAD之间的差异   <br>git diff HEAD       # 比较Worktree和HEAD之间的差异   <br>git diff branch     # 比较Worktree和branch之间的差异   <br>git diff branch1 branch2  # 比较两次分支之间的差异   <br>git diff commit commit    # 比较两次提交之间的差异   <br>git diff master..test   # 上面这条命令只显示两个分支间的差异  <br>git diff master...test    # 你想找出‘master’,‘test’的共有 父分支和&#x27;test&#x27;分支之间的差异，你用3个‘.&#x27;来取代前面的两个&#x27;.&#x27;  <br></code></pre></td></tr></table></figure><h3 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h3><p>存储当前的修改，但不用提交 commit</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">git stash # 将工作区现场（已跟踪文件）储藏起来，等以后恢复后继续工作。  <br>git stash -u    # 保存当前状态，包括 untracked 的文件<br>git stash list  # 查看保存的工作现场   <br>git stash apply # 恢复工作现场   <br>git stash drop  # 删除stash内容<br>git stash clear # 删除所有的 stash<br>git stash pop   # 恢复的同时直接删除stash内容   <br>git stash apply stash@&#123;0&#125; # 恢复指定的工作现场，当你保存了不只一份工作现场时。<br>git checkout &lt;stash@&#123;n&#125;&gt; -- &lt;file-path&gt; # 从 stash 中拿出某个文件的修改<br></code></pre></td></tr></table></figure><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git merge --squash <span class="hljs-built_in">test</span> <span class="hljs-comment"># 合并压缩，将test上的commit压缩为一条   </span><br></code></pre></td></tr></table></figure><h3 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git cherry-pick commit    # 拣选合并，将commit合并到当前分支   <br>git cherry-pick -n commit # 拣选多个提交，合并完后可以继续拣选下一个提交   <br></code></pre></td></tr></table></figure><h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">git rebase master   # 将master分之上超前的提交，变基到当前分支  <br>git rebase --onto master 169a6  # 限制回滚范围，rebase当前分支从169a6以后的提交  <br>git rebase --interactive # 交互模式，修改commit   <br>git rebase --continue    # 处理完冲突继续合并   <br>git rebase --skip        # 跳过   <br>git rebase --abort       # 取消合并    <br></code></pre></td></tr></table></figure><h2 id="分支branch"><a href="#分支branch" class="headerlink" title="分支branch"></a>分支branch</h2><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push origin :branchName  # 删除远程分支  <br>git push origin --delete new # 删除远程分支new   <br>git branch -d branchName     # 删除本地分支，强制删除用-D  <br>git branch -d test      # 删除本地test分支   <br>git branch -D test      # 强制删除本地test分支   <br>git remote prune origin # 远程删除了，本地还能看到远程存在，这条命令删除远程不存在的分支<br></code></pre></td></tr></table></figure><h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push -u origin branchName <span class="hljs-comment"># 提交分支到远程origin主机中  </span><br></code></pre></td></tr></table></figure><h3 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch -p <span class="hljs-comment"># 拉取远程分支时，自动清理 远程分支已删除，本地还存在的对应同名分支。  </span><br>git fetch origin <span class="hljs-string">&#x27;+refs/heads/*:refs/heads/*&#x27;</span> <span class="hljs-comment"># 更新所有分支内容</span><br></code></pre></td></tr></table></figure><h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git merge branchName      # 合并分支 - 将分支branchName和当前所在分支合并   <br>git merge origin/master   # 在本地分支上合并远程分支。   <br>git rebase origin/master  # 在本地分支上合并远程分支。   <br>git merge test            # 将test分支合并到当前分支   <br></code></pre></td></tr></table></figure><h3 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -m old new <span class="hljs-comment"># 重命名分支  </span><br></code></pre></td></tr></table></figure><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch      # 列出本地分支   <br>git branch -r   # 列出远端分支   <br>git branch -a   # 列出所有分支   <br>git branch -v   # 查看各个分支最后一个提交对象的信息   <br>git branch --merge      # 查看已经合并到当前分支的分支   <br>git branch --no-merge   # 查看为合并到当前分支的分支   <br>git remote show origin  # 可以查看remote地址，远程分支<br></code></pre></td></tr></table></figure><h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch test # 新建test分支  <br>git branch newBrach 3defc69 # 指定哈希3defc69，新建分支名字为newBrach<br>git checkout -b newBrach origin/master # 取回远程主机的更新以后，在它的基础上创建一个新的分支  <br>git checkout -b newBrach 3defc69 # 以哈希值3defc69，新建 newBrach 分支，并切换到该分支<br></code></pre></td></tr></table></figure><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch --set-upstream dev origin/dev     # 将本地dev分支与远程dev分支之间建立链接  <br>git branch --set-upstream master origin/next # 手动建立追踪关系  <br></code></pre></td></tr></table></figure><h3 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout -        # 快速切换分支上一个分支<br>git checkout test     # 切换到test分支   <br>git checkout -b test  # 新建+切换到test分支   <br>git checkout -b test dev # 基于dev新建test分支，并切换   <br></code></pre></td></tr></table></figure><h2 id="远端"><a href="#远端" class="headerlink" title="远端"></a>远端</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">git fetch &lt;远程主机名&gt; &lt;分支名&gt;   # fetch取回所有分支（branch）的更新  <br>git fetch origin remotebranch[:localbranch]   #  从远端拉去分支[到本地指定分支]   <br>git merge origin/branch   # 合并远端上指定分支   <br>git pull origin remotebranch:localbranch  #  拉去远端分支到本地分支   <br>git push origin branch    # 将当前分支，推送到远端上指定分支   <br>git push origin localbranch:remotebranch  # 推送本地指定分支，到远端上指定分支   <br>git push origin :remotebranch   # 删除远端指定分支   <br>git checkout -b [--track] test origin/dev # 基于远端dev分支，新建本地test分支[同时设置跟踪]  <br></code></pre></td></tr></table></figure><h2 id="submodule"><a href="#submodule" class="headerlink" title="submodule"></a>submodule</h2><p>克隆项目同时克隆 submodule</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/jaywcjlove/handbook.git --depth=1 --recurse-submodules<br></code></pre></td></tr></table></figure><p>克隆项目，之后再手动克隆 submodule 子项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">git submodule add -b gh-pages --force <span class="hljs-string">&#x27;仓库地址&#x27;</span> <span class="hljs-string">&#x27;路径&#x27;</span><br>git submodule add --force <span class="hljs-string">&#x27;仓库地址&#x27;</span> <span class="hljs-string">&#x27;路径&#x27;</span><br><span class="hljs-comment"># 其中，仓库地址是指子模块仓库地址，路径指将子模块放置在当前工程下的路径。</span><br><span class="hljs-comment"># 注意：路径不能以 / 结尾（会造成修改不生效）、不能是现有工程已有的目录（不能順利 Clone）</span><br>git submodule init <span class="hljs-comment"># 初始化 submodule</span><br>git submodule update <span class="hljs-comment"># 更新submodule(必须在根目录执行命令)</span><br>git submodule update --init --recursive  <span class="hljs-comment"># 下载的工程带有submodule</span><br>git submodule update --recursive --remote <span class="hljs-comment"># 对于 git 1.8.2 或更高版本，添加了选项 --remote 以支持更新远程分支</span><br>git pull --recurse-submodules <span class="hljs-comment"># 更新 submodule git 1.7.3 版本</span><br></code></pre></td></tr></table></figure><p>当使用<code>git clone</code>下来的工程中带有submodule时，初始的时候，submodule的内容并不会自动下载下来的，此时，只需执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git submodule foreach --recursive git submodule init<br></code></pre></td></tr></table></figure><h3 id="更新-submodule"><a href="#更新-submodule" class="headerlink" title="更新 submodule"></a>更新 submodule</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git submodule foreach git pull  <span class="hljs-comment"># submodule 里有其他的 submodule 一次更新</span><br>git submodule foreach git pull origin master <span class="hljs-comment"># submodule更新</span><br>git submodule foreach --recursive git submodule update<br>git submodule update --recursive --remote<br>git pull --recurse-submodules<br>git submodule deinit --all -f <span class="hljs-comment"># 清理 submodule</span><br></code></pre></td></tr></table></figure><h3 id="删除-submodule"><a href="#删除-submodule" class="headerlink" title="删除 submodule"></a>删除 submodule</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">git ls-files --stage &lt;子项目名称路径&gt; <span class="hljs-comment"># 查看子项目</span><br>vim .gitmodules <span class="hljs-comment"># 删除对应的 submodule</span><br>vim .git/config <span class="hljs-comment"># 删除对应的 submodule</span><br>git <span class="hljs-built_in">rm</span> --cached &lt;子模块名称&gt; <span class="hljs-comment"># 删除缓存中的子项目，注意没有 `/`</span><br>git <span class="hljs-built_in">rm</span> --cached subProjectName<br><span class="hljs-built_in">rm</span> -rf project/subProjectName<br><span class="hljs-built_in">rm</span> .git/module/* <span class="hljs-comment"># 删除模块下的子模块目录，每个子模块对应一个目录，注意只删除对应的子模块目录即可</span><br></code></pre></td></tr></table></figure><h3 id="转换分支"><a href="#转换分支" class="headerlink" title="转换分支"></a>转换分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config -f .gitmodules submodule.public.branch gh-pages<br></code></pre></td></tr></table></figure><p>下面是更改 <code>.gitmodules</code>  文件内容</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[submodule &quot;public&quot;]</span><br>  <span class="hljs-attr">path</span> = public<br>  <span class="hljs-attr">url</span> = git@github.com:jaywcjlove/gitke.git<br>  <span class="hljs-attr">branch</span> = gh-pages<br></code></pre></td></tr></table></figure><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">rm</span> -rf node_modules/<br></code></pre></td></tr></table></figure><h2 id="remote-1"><a href="#remote-1" class="headerlink" title="remote"></a>remote</h2><p>git是一个分布式代码管理工具，所以可以支持多个仓库，在git里，服务器上的仓库在本地称之为remote。个人开发时，多源用的可能不多，但多源其实非常有用。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote add origin1 git@github.com:yanhaijing/data.js.git  <br>git remote    # 显示全部源  <br>git remote -v # 显示全部源+详细信息  <br>git remote rename origin1 origin2 # 重命名  <br>git remote rm origin    # 删除  <br>git remote show origin  # 查看指定源的全部信息  <br></code></pre></td></tr></table></figure><h2 id="标签tag"><a href="#标签tag" class="headerlink" title="标签tag"></a>标签tag</h2><p>当开发到一定阶段时，给程序打标签是非常棒的功能。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag -a v0.1.1 9fbc3d0           <span class="hljs-comment"># 补打 tag，根据 hash 创建 tag</span><br>git tag -a v0.1 -m <span class="hljs-string">&#x27;my version 1.4&#x27;</span> <span class="hljs-comment"># 新建带注释标签   </span><br>git push origin --tags              <span class="hljs-comment"># 一次性推送所有分支 </span><br>git push origin v1.5                <span class="hljs-comment"># 推送单个tag到orgin源上 </span><br>git tag -v v1.4.2.1                 <span class="hljs-comment"># 验证标签，验证已经签署的标签</span><br>git show v1.5                       <span class="hljs-comment"># 看到对应的 GPG 签</span><br><br>git tag        <span class="hljs-comment"># 列出现有标签   </span><br>git tag v0gi.1 <span class="hljs-comment"># 新建标签   </span><br>git checkout tagname   <span class="hljs-comment"># 切换到标签       </span><br>git tag -d v0.1 <span class="hljs-comment"># 删除标签   </span><br>git push origin :refs/tags/v0.1 <span class="hljs-comment"># 删除远程标签   </span><br>git pull --all <span class="hljs-comment"># 获取远程所有内容包括tag  </span><br>git --git-dir=<span class="hljs-string">&#x27;&lt;绝对地址&gt;/.git&#x27;</span> describe --tags HEAD <span class="hljs-comment"># 查看本地版本信息  </span><br></code></pre></td></tr></table></figure><h3 id="重命名Tag"><a href="#重命名Tag" class="headerlink" title="重命名Tag"></a>重命名Tag</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> .git/refs/tags/1.9.1 .git/refs/tags/v1.9.1<br>git push -f --tags<br></code></pre></td></tr></table></figure><h2 id="日志log"><a href="#日志log" class="headerlink" title="日志log"></a>日志log</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global format.pretty <span class="hljs-string">&quot;%Cgreen%h%Creset %s %Cblue@%cn%Creset %Cred%ai%Creset&quot;</span> <span class="hljs-comment"># 全局配置彩色 log 输出</span><br>git config --global format.pretty <span class="hljs-string">&quot;%h: %s @%cn %ai&quot;</span> <span class="hljs-comment"># 全局配置格式化后的 log</span><br>git config format.pretty oneline  <span class="hljs-comment"># 显示历史记录时，每个提交的信息只显示一行   </span><br>git config color.ui <span class="hljs-literal">true</span> <span class="hljs-comment"># 彩色的 git 输出   </span><br>git <span class="hljs-built_in">log</span> <span class="hljs-comment"># 查看最近的提交日志</span><br>git <span class="hljs-built_in">log</span> --grep=224 <span class="hljs-comment"># 这条命令是查看含有 &quot;224&quot; 关键字的 git commit </span><br>git <span class="hljs-built_in">log</span> --pretty=oneline <span class="hljs-comment"># 单行显示提交日志   </span><br>git <span class="hljs-built_in">log</span> --graph --pretty=oneline --abbrev-commit   <br>git <span class="hljs-built_in">log</span> -num <span class="hljs-comment"># 显示第几条log（倒数）   </span><br>git reflog   <span class="hljs-comment"># 查看所有分支的所有操作记录   </span><br>git <span class="hljs-built_in">log</span> --since=1.day <span class="hljs-comment"># 一天内的提交；你可以给出各种时间格式，比如说具体的某一天（“2008-01-15”），或者是多久以前（“2 years 1 day 3 minutes ago”）。   </span><br>git <span class="hljs-built_in">log</span> --pretty=<span class="hljs-string">&quot;%h - %s&quot;</span> --author=自己的名字 <span class="hljs-comment"># 查看自己的日志   </span><br>git <span class="hljs-built_in">log</span> -p -2  <span class="hljs-comment"># 展开两次更新显示每次提交的内容差异   </span><br>git <span class="hljs-built_in">log</span> --<span class="hljs-built_in">stat</span> <span class="hljs-comment"># 要快速浏览其他协作者提交的更新都作了哪些改动   </span><br>git <span class="hljs-built_in">log</span> --pretty=format:<span class="hljs-string">&quot;%h - %an, %ar : %s&quot;</span># 定制要显示的记录格式   <br>git <span class="hljs-built_in">log</span> --pretty=format:<span class="hljs-string">&#x27;%h : %s&#x27;</span> --date-order --graph <span class="hljs-comment"># 拓扑顺序展示   </span><br>git <span class="hljs-built_in">log</span> --pretty=format:<span class="hljs-string">&#x27;%h : %s - %ad&#x27;</span> --<span class="hljs-built_in">date</span>=short   <span class="hljs-comment"># 日期YYYY-MM-DD显示</span><br>git <span class="hljs-built_in">log</span> --pretty=oneline --graph --decorate --all <span class="hljs-comment"># 展示简化的 commit 历史</span><br>git <span class="hljs-built_in">log</span> &lt;last tag&gt; HEAD --pretty=format:%s <span class="hljs-comment"># 只显示commit   </span><br>git config --global format.pretty <span class="hljs-string">&#x27;%h : %s - %ad&#x27;</span> --<span class="hljs-built_in">date</span>=short <span class="hljs-comment">#日期YYYY-MM-DD显示 写入全局配置</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>%H</td><td>提交对象（commit）的完整哈希字串</td><td>%ad</td><td>作者修订日期（可以用 -date&#x3D; 选项定制格式）</td></tr><tr><td>%h</td><td>提交对象的简短哈希字串</td><td>%ar</td><td>作者修订日期，按多久以前的方式显示</td></tr><tr><td>%T</td><td>树对象（tree）的完整哈希字串</td><td>%cn</td><td>提交者(committer)的名字</td></tr><tr><td>%t</td><td>树对象的简短哈希字串</td><td>%ce</td><td>提交者的电子邮件地址</td></tr><tr><td>%P</td><td>父对象（parent）的完整哈希字串</td><td>%cd</td><td>提交日期</td></tr><tr><td>%p</td><td>父对象的简短哈希字串</td><td>%cr</td><td>提交日期，按多久以前的方式显示</td></tr><tr><td>%an</td><td>作者（author）的名字</td><td>%s</td><td>提交说明</td></tr><tr><td>%ae</td><td>作者的电子邮件地址</td><td>-</td><td>-</td></tr></tbody></table><p><a href="https://git-scm.com/docs/git-log#_pretty_formats">Pretty Formats</a></p><h2 id="重写历史"><a href="#重写历史" class="headerlink" title="重写历史"></a>重写历史</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit --amend    <span class="hljs-comment"># 改变最近一次提交  </span><br>git rebase -i HEAD~3  <span class="hljs-comment"># 修改最近三次的提交说明，或者其中任意一次  </span><br>git commit --amend    <span class="hljs-comment"># 保存好了，这些指示很明确地告诉了你该干什么  </span><br>git rebase --<span class="hljs-built_in">continue</span> <span class="hljs-comment"># 修改提交说明，退出编辑器。  </span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">pick f7f3f6d changed my name a bit<br>pick 310154e updated README formatting and added blame<br>pick a5f4a0d added cat-file<br></code></pre></td></tr></table></figure><p>改成</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">pick <span class="hljs-number">310154</span>e updated README formatting <span class="hljs-keyword">and </span><span class="hljs-keyword">added </span><span class="hljs-keyword">blame</span><br><span class="hljs-keyword"></span>pick f<span class="hljs-symbol">7f</span><span class="hljs-symbol">3f</span>6d changed my name a <span class="hljs-keyword">bit</span><br></code></pre></td></tr></table></figure><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">help</span> *  <span class="hljs-comment"># 获取命令的帮助信息  </span><br>git status  <span class="hljs-comment"># 获取当前的状态，非常有用，因为git会提示接下来的能做的操作  </span><br></code></pre></td></tr></table></figure><h2 id="报错问题解决"><a href="#报错问题解决" class="headerlink" title="报错问题解决"></a>报错问题解决</h2><p><strong>1. <code>git fatal: protocol error: bad line length character: No s</code></strong></p><p>解决办法：更换remote地址为 <code>http/https</code> 的  </p><p><strong>2. <code>The requested URL returned error: 403 Forbidden while accessing</code></strong></p><p>解决github push错误的办法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">vim 编辑器打开 当前项目中的config文件</span><br>vim .git/config<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">修改</span><br>[remote &quot;origin&quot;]  <br>    url = https://github.com/jaywcjlove/example.git  <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">为下面代码</span><br>[remote &quot;origin&quot;]  <br>    url = https://jaywcjlove@github.com/jaywcjlove/example.git  <br></code></pre></td></tr></table></figure><p><strong>3. git status 显示中文问题</strong></p><p>在查看状态的时候 git status 如果是中文就显示下面的情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">\344\272\247\345\223\201\351\234\200\346\261\202<br></code></pre></td></tr></table></figure><p>解决这个问题方法是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global core.quotepath <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>4. The authenticity of host 192.168.0.xxx can’t be establis</strong></p><p>修改 <code>/etc/ssh/ssh_config</code> 中的 <code>StrictHostKeyChecking</code> 的 <code>ask</code> 为 <code>no</code> 解决问题。</p><p><strong>5. SSH连接时出现 Host key verification failed 的原因及解决方法</strong></p><p>用 OpenSSH 的人都知 ssh 会把你每个你访问过计算机的公钥(public key)都记录在~&#x2F;.ssh&#x2F;known_hosts。当下次访问相同计算机时，OpenSSH 会核对公钥。如果公钥不同，OpenSSH 会发出警告，避免你受到 DNS Hijack 之类的攻击。<br>SSH 对主机的 public_key 的检查等级是根据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">StrictHostKeyChecking=no  <span class="hljs-comment"># 最不安全的级别，当然也没有那么多烦人的提示了，相对安全的内网测试时建议使用。如果连接server的key在本地不存在，那么就自动添加到文件中（默认是known_hosts），并且给出一个警告。</span><br>StrictHostKeyChecking=ask <span class="hljs-comment"># 默认的级别，就是出现刚才的提示了。如果连接和key不匹配，给出提示，并拒绝登录。</span><br>StrictHostKeyChecking=<span class="hljs-built_in">yes</span> <span class="hljs-comment"># 最安全的级别，如果连接与key不匹配，就拒绝连接，不会提示详细信息。</span><br></code></pre></td></tr></table></figure><p>【解决方法1】在 <code>.ssh/config</code>（或者<code>/etc/ssh/ssh_config</code>）中配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs conf">StrictHostKeyChecking no<br>UserKnownHostsFile /dev/null<br></code></pre></td></tr></table></figure><p>解决方法 2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi ~/.ssh/known_hosts <span class="hljs-comment"># 删除对应ip的相关rsa信息</span><br><span class="hljs-built_in">rm</span> known_hosts <span class="hljs-comment"># 或者直接全部删除</span><br></code></pre></td></tr></table></figure><p><strong>5. insufficient permission for adding an object to repository database .git&#x2F;objects</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> .git/objects<br><span class="hljs-built_in">ls</span> -al<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chown</span> -R yourname:yourgroup *<br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://git-scm.com/">Git官网</a></li><li><a href="https://try.github.io/"><strong>Github 15分钟学习Git</strong></a></li><li><a href="http://gitref.org/zh/index.html">Git参考手册</a></li><li><a href="http://www.mceiba.com/tool/git-cheat-sheet.html">Git简明手册</a></li><li><a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/">Git Magic</a></li><li><a href="http://gitbook.liuhui998.com/index.html">Git Community Book 中文版</a></li><li><a href="http://git-scm.com/book/en/v2">Pro Git</a></li><li><a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html">图解Git</a></li><li><a href="http://rogerdudler.github.io/git-guide/index.zh.html">git-简明指南</a></li><li><a href="http://pcottle.github.io/learnGitBranching/">learnGitBranching 在线学习工具</a></li><li><a href="http://rogerdudler.github.io/git-guide/index.zh.html">初级教程</a> </li><li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">廖雪峰的Git教程</a></li><li><a href="http://www.worldhello.net/gotgithub/">蒋鑫老师将带你入github的大门</a></li><li><a href="http://www.open-open.com/lib/view/open1328069609436.html">git详解</a></li><li><a href="http://git.oschina.net/progit/">oschina教程</a></li><li><a href="https://github.com/blog/2019-how-to-undo-almost-anything-with-git">How to undo (almost) anything with Git撤销一切，汇总各种回滚撤销的场景，加强学习。</a></li><li><a href="http://www.runoob.com/git/git-tutorial.html">Git 教程 | 菜鸟教程runoob.com</a></li><li><a href="https://gold.xitu.io/post/5842f9b861ff4b005889ade6">Git 本地仓库和裸仓库</a></li><li><a href="http://www.kancloud.cn/kancloud/igit/46710">沉浸式学 Git</a></li><li><a href="http://way.oschina.io/2016/12/15/notes/GitAdvance/?utm_source=gank.io&utm_medium=email">Git进阶用法，主要是rebase高级用法</a></li><li><a href="https://www.atlassian.com/git/tutorials">成为一个git大师</a></li><li><a href="https://github.com/geeeeeeeeek/git-recipes">高质量的Git中文教程</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>命令行</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>总结JVM参数使用手则</title>
    <link href="/2022/11/17/%E6%80%BB%E7%BB%93JVM%E5%8F%82%E6%95%B0%E4%BD%BF%E7%94%A8%E6%89%8B%E5%88%99/"/>
    <url>/2022/11/17/%E6%80%BB%E7%BB%93JVM%E5%8F%82%E6%95%B0%E4%BD%BF%E7%94%A8%E6%89%8B%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h3 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h3><p>通过这些参数可以对JVM的内存分配做调整</p><ul><li>Xms</li></ul><p>  英文解释：Initial heap size(in bytes)</p><p>  中文释义：堆区初始值</p><p>  使用方法：-Xms2g 或 -XX:InitialHeapSize&#x3D;2048m</p><ul><li><p>Xmx</p><p>英文解释：Maximum heap size(in bytes)</p><p>中文释义：堆区最大值</p><p>使用方法：-Xmx2g 或 -XX:MaxHeapSize&#x3D;2048m</p></li></ul><p>Xmn<br>英文解释：Maximum new generation size(in bytes)<br>中文释义：新生代最大值<br>使用方法：-Xmn512m 或 -XX:MaxNewSize&#x3D;512m</p><p>PermSize(JDK1.8以后已废弃)<br>英文解释：Initial size of permanent generation(in bytes)<br>中文释义：永久代初始大小<br>使用方法：-XX:PermSize&#x3D;128m</p><p>MaxPermSize(JDK1.8以后已废弃)<br>英文解释：Maximum size of permanent generation(in bytes)<br>中文释义：永久代最大值<br>使用方法：-XX:MaxPermSize&#x3D;256m</p><p>MetaspaceSize(JDK1.8以后用于替换PermSize)<br>英文解释：Initial size of Metaspaces (in bytes)<br>中文释义：元数据区初始大小<br>使用方法：-XX:MetaspaceSize&#x3D;128m</p><p>MaxMetaspaceSize(JDK1.8以后用于替换MaxPermSize)<br>英文解释：Maximum size of Metaspaces (in bytes)<br>中文释义：元数据区最大值<br>使用方法：-XX:MaxMetaspaceSize&#x3D;256m</p><p>Xss<br>英文解释：Thread Stack Size(in Kbytes)<br>中文释义：线程栈最大值<br>使用方法：-Xss256k 或 -XX:ThreadStackSize&#x3D;256k</p><p>MaxDirectMemorySize<br>英文解释：Maximum total size of NIO direct-buffer allocations<br>中文释义：最大直接内存（堆外）大小<br>使用方法：-XX:MaxDirectMemorySize&#x3D;256m</p><h3 id="GC策略相关"><a href="#GC策略相关" class="headerlink" title="GC策略相关"></a>GC策略相关</h3><p>通过这些参数可以对JVM的GC性能进行调优</p><p>NewRatio<br>英文解释：Ratio of old&#x2F;new generation sizes<br>中文释义：老年代和新生代的比值<br>使用方法：-XX:NewRatio&#x3D;2<br>使用经验：假如设为2，则表示老年代最大内存占堆最大内存的2&#x2F;3，新生代则为1&#x2F;3。如果设置了Xmn或者NewSize&#x2F;MaxNewSize，那么NewRatio配置无效</p><p>SurvivorRatio<br>英文解释：Rato of eden&#x2F;survivor space size<br>中文释义：新生代中eden区和survivor区的比值<br>使用方法：-XX:SurvivorRatio&#x3D;6<br>使用经验：假如设为6，则表示每个survivor区跟eden区的比值为1:6,每个survivor区占新生代的八分之一</p><p>PretenureSizeThreshold<br>英文解释：Maximum size in bytes of objects allocated in DefNew generation;zero means no maximum<br>中文释义：可以在新生代直接分配的对象最大值，0表示没有最大值<br>使用方法：-XX:PretenureSizeThreshold&#x3D;1000000<br>使用经验：设置该参数，可以使大于这个值的对象直接在老年代分配，避免在Eden区和Survivor区发生大量的内存复制，该参数只对Serial和ParNew收集器有效，Parallel Scavenge并不认识该参数</p><p>MaxTenuringThreshold<br>英文解释：Maximum value fo tenuring threshold<br>中文释义：年轻代最大年龄<br>使用方法：-XX:MaxTenuringThreshold&#x3D;10<br>使用经验：每个对象在坚持过一次Minor GC之后，年龄就增加1，当超过这个参数值时就进入老年代，最大支持15</p><p>UseSerialGC<br>英文解释：Use the Serial garbage collector<br>中文释义：年轻代使用Serial垃圾收集器<br>使用方法：<br>开启 -XX:+UseSerialGC<br>使用经验：不推荐使用，性能太差，老年代将会使用SerialOld垃圾收集器</p><p>UseParNewGC<br>英文解释：Use parallel threads in the new generation<br>中文释义：年轻代使用ParNew垃圾收集器<br>使用方法：<br>开启 -XX:+UseParNewGC</p><p>ParallelGCThreads<br>英文解释：Number of parallel threads parallel gc will use<br>中文释义：并行执行gc的线程数<br>使用方法：-XX:ParallelGCThreads&#x3D;16</p><p>UseParallelGC<br>英文解释：Use the Parallel Scavenge garbage collector<br>中文释义：年轻代使用Parallel Scavenge垃圾收集器<br>使用方法：<br>开启 -XX:+UseParallelGC<br>使用经验：Linux下1.6,1.7,1.8默认开启，老年代将会使用SerialOld垃圾收集器</p><p>UseParallelOldGC<br>英文解释：Use the Parallel Old garbage collector<br>中文释义：年轻代使用Parallel Scavenge收集器<br>使用方法：<br>开启 -XX:+UseParallelOldGC<br>使用经验：老年代将会使用Parallel Old收集器</p><p>UseConcMarkSweepGC<br>英文解释：Use Concurrent Mark-Sweep GC in the old generation<br>中文释义：老年代使用CMS收集器（如果出现”Concurrent Mode Failure”，会使用SerialOld收集器）<br>使用方法：<br>开启 -XX:+UseConcMarkSweepGC<br>使用经验：年轻代将会使用ParNew收集器</p><p>CMSInitiatingOccupancyFraction<br>英文解释：Percentage CMS generation occupancy to start a CMS collection cycle. A negative value means that CMSTriggerRatio is used<br>中文释义：触发执行CMS回收的当前年代区内存占用的百分比，负值表示使用CMSTriggerRatio设置的值<br>使用方法：-XX:CMSInitiatingOccupancyFraction&#x3D;75<br>使用经验：该参数需配合UseCMSInitiatingOccupancyOnly一起使用</p><p>UseCMSInitiatingOccupancyOnly<br>英文解释：Only use occupancy as a criterion for staring a CMS collection<br>中文释义：只根据占用情况作为开始执行CMS收集的标准，默认关闭<br>使用方法：<br>开启 -XX:+UseCMSInitiatingOccupancyOnly</p><p>UseCMSCompactAtFullCollection<br>英文解释：Use Mark-Sweep-Compact algorithm at full collections<br>中文释义：使用CMS执行Full GC时对内存进行压缩，默认关闭<br>使用方法：<br>开启 -XX:+UseCMSCompactAtFullCollection</p><p>CMSFullGCsBeforeCompaction<br>英文解释：Number of CMS full collection done before compaction if &gt; 0<br>中文释义：多少次FGC后进行内存压缩<br>使用方法：-XX:CMSFullGCsBeforeCompaction&#x3D;1</p><p>CMSClassUnloadingEnabled<br>英文解释：Whether class unloading enabled when using CMS GC<br>中文释义：当使用CMS GC时是否启用类卸载功能，默认关闭<br>使用方法：<br>开启 -XX:+CMSClassUnloadingEnabled</p><p>CMSParallelRemarkEnabled<br>英文解释：Whether parallel remark enabled (only if ParNewGC)<br>中文释义：是否启用并行标记（仅限于ParNewGC），默认关闭<br>使用方法：<br>开启 -XX:+CMSParallelRemarkEnabled</p><p>UseG1GC<br>英文解释：Use the Garbage-First garbage collector<br>中文释义：使用G1垃圾收集器<br>使用方法：<br>开启 -XX:+UseG1GC</p><p>MaxGCPauseMillis<br>英文解释：Adaptive size policy maximum GC pause time goal in millisecond, or (G1 Only) the maximum GC time per MMU time slice<br>中文释义：自适应大小策略的最大GC暂停时间目标（以毫秒为单位），或（仅G1）每个MMU时间片的最大GC时间<br>使用方法：-XX:MaxGCPauseMillis&#x3D;200</p><p>DisableExplicitGC<br>英文解释：Ignore calls to System.gc()<br>中文释义：禁用System.gc()触发FullGC<br>使用方法：<br>开启 -XX:+DisableExplicitGC<br>PS:不建议开启，如果开启了这个参数可能会导致堆外内存无法及时回收造成内存溢出</p><h3 id="GC日志相关"><a href="#GC日志相关" class="headerlink" title="GC日志相关"></a>GC日志相关</h3><p>通过这些参数可以对JVM的GC日志输出进行配置，方便分析</p><p>Xloggc<br>英文解释：GC log file<br>中文释义：GC日志文件路径<br>使用方法：-Xloggc:&#x2F;data&#x2F;gclog&#x2F;gc.log</p><p>UseGCLogFileRotation<br>英文解释：Rotate gclog files(for long running applications). It requires -Xloggc:<filename><br>中文释义：滚动GC日志文件，须配置Xloggc<br>使用方法：<br>开启 -XX:+UseGCLogFileRotation</p><p>NumberOfGCLogFiles<br>英文解释：Number of gclog files in rotation(default:0,no rotation)<br>中文释义：滚动GC日志文件数，默认0，不滚动<br>使用方法：-XX:NumberOfGCLogFiles&#x3D;4</p><p>GCLogFileSize<br>英文解释：GC log file size,requires UseGCLogFileRotation. Set to 0 to only trigger rotation via jcmd<br>中文释义：GC文件滚动大小，需配置UseGCLogFileRotation，设置为0表示仅通过jcmd命令触发<br>使用方法：-XX:GCLogFileSize&#x3D;100k</p><p>PrintGCDetails<br>英文解释：Print more details at garbage collection<br>中文释义：GC时打印更多详细信息，默认关闭<br>使用方法：<br>开启 -XX:+PrintGCDetails<br>可以通过jinfo -flag [+|-]PrintGCDetails <pid> 或 jinfo -flag PrintGCDetails&#x3D;<value> <pid> 来动态开启或设置值</p><p>PrintGCDateStamps<br>英文解释：Print date stamps at garbage collection<br>中文释义：GC时打印时间戳信息，默认关闭<br>使用方法：<br>开启 -XX:+PrintGCDateStamps<br>可以通过jinfo -flag [+|-]PrintGCDateStamps <pid> 或 jinfo -flag PrintGCDateStamps&#x3D;<value> <pid> 来动态开启或设置值</p><p>PrintTenuringDistribution<br>英文解释：Print tenuring age information<br>中文释义：打印存活实例年龄信息，默认关闭<br>使用方法：<br>开启 -XX:+PrintTenuringDistribution</p><p>PrintGCApplicationStoppedTime<br>英文解释：Print the time of application has been stopped<br>中文释义：打印应用暂停时间，默认关闭<br>使用方法：<br>开启 -XX:+PrintGCApplicationStoppedTime</p><p>PrintHeapAtGC<br>英文解释：Print heap layout before and after each GC<br>中文释义：GC前后打印堆区使用信息，默认关闭<br>使用方法：<br>开启 -XX:+PrintHeapAtGC</p><h3 id="异常相关"><a href="#异常相关" class="headerlink" title="异常相关"></a>异常相关</h3><p>通过这些参数可以在JVM异常情况下执行某些操作，以保留现场做分析用</p><p>HeapDumpOnOutOfMemoryError<br>英文解释：Dump heap to file when java.lang.OutOfMemoryError is thrown<br>中文释义：抛出内存溢出错误时导出堆信息到指定文件，默认关闭<br>使用方法：<br>开启 -XX:+HeapDumpOnOutOfMemoryError<br>可以通过jinfo -flag [+|-]HeapDumpOnOutOfMemoryError <pid> 或 jinfo -flag HeapDumpOnOutOfMemoryError&#x3D;<value> <pid> 来动态开启或设置值</p><p>HeapDumpPath<br>英文解释：When HeapDumpOnOutOfMemoryError is on, the path(filename or directory) of the dump file(defaults to java_pid<pid>.hprof in the working directory)<br>中文释义：当HeapDumpOnOutOfMemoryError开启的时候，dump文件的保存路径，默认为工作目录下的java_pid<pid>.hprof文件<br>使用方法：-XX:HeapDumpPath&#x3D;&#x2F;data&#x2F;dump&#x2F;jvm.dump<br>使用经验：除非必要，建议不设置</p><p>OmitStackTraceInFastThrow<br>英文解释：Omit backtraces for some ‘hot’ exceptions in optimized code<br>中文释义：在优化代码里面忽略热点异常回溯<br>使用方法：<br>关闭 -XX:-OmitStackTraceInFastThrow<br>使用经验：某些热点异常抛的太多的话，JVM默认会做优化，会使用JVM初始化的时候创建的异常代替实际的异常，这些异常是没有异常栈信息的，不方便定位问题，如果有碰到这种情况，可以考虑关闭这个配置</p><h3 id="问题定位及优化相关"><a href="#问题定位及优化相关" class="headerlink" title="问题定位及优化相关"></a>问题定位及优化相关</h3><p>通过这些参数可以对JVM进行性能优化或者排查定位问题</p><p>server<br>英文解释：server mode<br>中文释义：使用服务端模式<br>使用方法：-server</p><p>TieredCompilation<br>英文解释：Enable tiered compilation<br>中文释义：启用多层编译<br>使用方法：<br>开启 -XX:+TieredCompilation<br>关闭 -XX:-TieredCompilation<br>使用经验：java 1.8默认开启分层编译，该参数无效</p><p>NativeMemoryTracking<br>英文解释：Native memory tracking options<br>中文释义：开启本机内存追踪<br>使用方法：<br>开启详细信息 -XX:NativeMemoryTracking&#x3D;detail<br>开启概要信息 -XX:NativeMemoryTracking&#x3D;summary<br>使用经验：开启的话，大概会增加5%-10%的性能消耗</p><p>UnlockDiagnosticVMOptions<br>英文解释：Enable normal processing of flags<br>中文释义：解锁对JVM进行诊断的选项参数，默认关闭<br>使用方法：<br>开启 -XX:+UnlockDiagnosticVMOptions</p><p>PrintNMTStatistics<br>英文解释：Print native memory tracking summary data if it is on<br>中文释义：在jvm shutdown的时候输出整体的native memory统计，默认关闭<br>使用方法：<br>开启 -XX:+PrintNMTStatistics<br>使用经验：必须配合参数-XX:+UnlockDiagnosticVMOptions使用，并且只能加在其后才能生效</p><p>UseAdaptiveSizePolicy<br>英文解释：Use adaptive generation sizing policies<br>中文释义：使用自适应分代内存策略<br>使用方法：<br>开启 -XX:+UseAdaptiveSizePolicy<br>关闭 -XX:-UseAdaptiveSizePolicy<br>使用经验：1.7以后默认会开启该参数，如果使用CMS回收算法，则会关闭该参数，该参数开启以后会使SurvivorRatio参数失效，如果显示指定了SurvivorRatio，需要关闭该参数</p><p>参考文献：</p><p><a href="https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE">https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE</a><br>own的时候输出整体的native memory统计，默认关闭使用方法： 开启-XX:+PrintNMTStatistics&#96;<br>使用经验：必须配合参数-XX:+UnlockDiagnosticVMOptions使用，并且只能加在其后才能生效</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Netty 的 Channel、Promise、Pipeline 详解</title>
    <link href="/2022/10/26/Netty%20%E7%9A%84%20Channel%E3%80%81Promise%E3%80%81Pipeline%20%E8%AF%A6%E8%A7%A3/"/>
    <url>/2022/10/26/Netty%20%E7%9A%84%20Channel%E3%80%81Promise%E3%80%81Pipeline%20%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Netty-Demo-示例"><a href="#Netty-Demo-示例" class="headerlink" title="Netty Demo 示例"></a>Netty Demo 示例</h1><p>首先通过一个示例来分析，创建一个 <code>NioServerSocketChannel</code> 监听本机端口 11111 的 <code>Socket</code> 连接，将收到的消息原样返回；然后再创建一个 <code>NioSocketChannel</code>，发起对本机的 11111 端口的 Socket 连接，发送字符串 ”Netty rocks!“。预期能收到服务端返回的 “Netty rocks!” 响应。</p><h2 id="Maven-依赖"><a href="#Maven-依赖" class="headerlink" title="Maven 依赖"></a>Maven 依赖</h2><p>本文使用的 Netty 版本是 <strong>5.0.0.Alpha2</strong>，与 4.x 版本相比变化还是挺大的。pom 文件添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;io.netty&lt;/groupId&gt;<br>    &lt;artifactId&gt;netty-all&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">5.0</span><span class="hljs-number">.0</span>.Alpha2&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h2 id="创建一个-Server"><a href="#创建一个-Server" class="headerlink" title="创建一个 Server"></a>创建一个 Server</h2><p>创建一个 NioServerSocketChannel，监听本机端口 11111 的 Socket 连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EchoServer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> port;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">EchoServer</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span> &#123;<br>        <span class="hljs-built_in">this</span>.port = port;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">EchoServer</span>(<span class="hljs-number">11111</span>).start();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">EchoServerHandler</span> <span class="hljs-variable">serverHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EchoServerHandler</span>();<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>            b.group(group).channel(NioServerSocketChannel.class)<br>                    .localAddress(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(port))<br>                    .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            socketChannel.pipeline().addLast(serverHandler);<br>                        &#125;<br>                    &#125;);<br><br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> b.bind().sync();<br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            group.shutdownGracefully().sync();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>EchoServerHandler 的实现如下，在 channelRead 时将数据写入 ChannelHandlerContext，并将数据输出到控制台。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EchoServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelHandlerAdapter</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> (ByteBuf) msg;<br>        System.out.println(<span class="hljs-string">&quot;Server received : &quot;</span> + in.toString(CharsetUtil.UTF_8));<br>        ctx.write(in);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>        ctx.writeAndFlush(Unpooled.EMPTY_BUFFER) .addListener(ChannelFutureListener.CLOSE);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx,</span><br><span class="hljs-params">            Throwable cause)</span> &#123;<br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="创建一个-Client"><a href="#创建一个-Client" class="headerlink" title="创建一个 Client"></a>创建一个 Client</h2><p>创建一个 NioSocketChannel，发起对本机的 11111 端口的 Socket 连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EchoClient</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String host;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> port;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">EchoClient</span><span class="hljs-params">(String host, <span class="hljs-type">int</span> port)</span> &#123; <span class="hljs-built_in">this</span>.host = host;<br>        <span class="hljs-built_in">this</span>.port = port;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">EchoClient</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">11111</span>).start();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br>            bootstrap.group(group).channel(NioSocketChannel.class)<br>                    .remoteAddress(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(host, port))<br>                    .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EchoClientHandler</span>());<br>                        &#125;<br>                    &#125;);<br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.connect().sync();<br>            channelFuture.channel().closeFuture().sync();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            group.shutdownGracefully().sync();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>EchoClientHandler 的实现如下，messageReceived（在 Netty 4.x 为 channelRead0）对于泛型 I（本例中是 ByteBuf）进行处理，将数据输出到控制台。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EchoClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;ByteBuf&gt; &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;Netty rocks!&quot;</span>,<br>                CharsetUtil.UTF_8));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> &#123;<br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">messageReceived</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<br>                <span class="hljs-string">&quot;Client received: &quot;</span> + msg.toString(CharsetUtil.UTF_8));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="io-netty-channel-Channel-类"><a href="#io-netty-channel-Channel-类" class="headerlink" title="io.netty.channel.Channel 类"></a>io.netty.channel.Channel 类</h1><p>上面 demo 中直接使用到的 2 个类是：NioServerSocketChannel 和 NioSocketChannel，这两个类底层都是实现了 Channel 接口，注意这个 Channel 接口是 <code>io.netty.channel.Channel</code>，而不是 JDK 自带的 java.nio.channels.Channel！两个类的继承关系如下：</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2019-10-15-060744.png" alt="NioServerSocketChannel"></p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2019-10-16-115532.png" alt="NioSocketChannel"></p><p>Channel 提供应用程序网络套接字或其他组件连接，提供读、写、连接和绑定等 I&#x2F;O 操作。</p><ul><li>Channel 的当前状态（开启、关闭）</li><li>Channel 的配置参数（接收缓冲区大小）</li><li>I&#x2F;O 操作（读、写、连接、绑定）</li><li>ChannelPipeline，处理所有与 Channel 绑定的 I&#x2F;O 事件和请求</li></ul><h2 id="所有-I-O-操作都是异步的"><a href="#所有-I-O-操作都是异步的" class="headerlink" title="所有 I&#x2F;O 操作都是异步的"></a>所有 I&#x2F;O 操作都是<code>异步</code>的</h2><p>Netty 中所有 I&#x2F;O 操作都是异步的。这意味着所有的 I&#x2F;O 调用都会立即返回，不能保证在调用结束时请求的 I&#x2F;O 操作是否完成。调用者会得到一个 ChannelFuture 实例，该实例会在请求的 I&#x2F;O 操作成功、失败、取消时通知调用者。</p><h2 id="Channel-是分层级的"><a href="#Channel-是分层级的" class="headerlink" title="Channel 是分层级的"></a>Channel 是分层级的</h2><p>Channel 可以有 parent，这取决于 Channel 的创建方式。例如被 ServerSocketChannel 接收的 SocketChannel，会得到一个 ServerSocketChannel 作为它的 parent。</p><h2 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h2><p>使用完毕后，调用 close() 或 close(ChannelPromise) 释放资源非常重要。</p><h1 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h1><p>ChannelFuture 是一个<code>异步 Channel I/O 操作的结果</code>。如上面所说，Netty 中所有 I&#x2F;O 操作都是异步的。这意味着所有的 I&#x2F;O 调用都会立即返回，不能保证在调用结束时请求的 I&#x2F;O 操作是否完成。调用者会得到一个 ChannelFuture 实例。</p><p>ChannelFuture 只有 2 种状态：未完成、已完成。I&#x2F;O 操作开始时，将会创建一个新的 ChannelFuture 对象，初始时是未完成状态 —— 不是成功、失败或取消的任何一种状态，因为 I&#x2F;O 操作还没有完成。如果 I&#x2F;O 操作结束（无论成功、失败、取消），ChannelFuture 都会处于完成状态。注意即使是失败也属于完成状态。</p><pre><code class="hljs">                                      +---------------------------+                                      | Completed successfully    |                                      +---------------------------+                                 +----&gt;      isDone() = true      | +--------------------------+    |    |   isSuccess() = true      | |        Uncompleted       |    |    +===========================+ +--------------------------+    |    | Completed with failure    | |      isDone() = false    |    |    +---------------------------+ |   isSuccess() = false    |----+----&gt;   isDone() = true         | | isCancelled() = false    |    |    |    cause() = non-null     | |       cause() = null     |    |    +===========================+ +--------------------------+    |    | Completed by cancellation |                                 |    +---------------------------+                                 +----&gt;      isDone() = true      |                                      | isCancelled() = true      |                                      +---------------------------+</code></pre><p>我们还可以添加 ChannelFutureListener，以便在 I&#x2F;O 操作完成时收到通知。</p><h2 id="使用-addListener-GenericFutureListener-而不是-await"><a href="#使用-addListener-GenericFutureListener-而不是-await" class="headerlink" title="使用 addListener(GenericFutureListener) 而不是 await()"></a>使用 addListener(GenericFutureListener) 而不是 await()</h2><p>addListener(GenericFutureListener) 是非阻塞的，只需要将特定的 ChannelFutureListener 添加到ChannelFuture 即可，I&#x2F;O 线程会在 ChannelFuture 绑定的 I&#x2F;O 操作完成时通知监听器。<code>ChannelFutureListener</code> 完全非阻塞，因此效率极高。</p><p>而 await() 是阻塞操作，一旦调用，调用者线程就会阻塞直到操作完成。使用 await() 操作更容易，但是成本更高。此外，在特定的情况下还可能出现死锁。</p><h2 id="使用-ChannelHandler-而不是-await"><a href="#使用-ChannelHandler-而不是-await" class="headerlink" title="使用 ChannelHandler 而不是 await()"></a>使用 ChannelHandler 而不是 await()</h2><p><code>ChannelHandler</code> 中的事件处理方法通常由 I&#x2F;O 线程调用，如果 await() 是由事件处理方法（I&#x2F;O 线程）调用的，那么它正在等待的 I&#x2F;O 操作可能永远也不会完成，因为 await() 方法可以阻止它正在等待的 I&#x2F;O 操作，也就是发生了死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// BAD - NEVER DO THIS</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, GoodByeMessage msg)</span> &#123;<br>    <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">future</span> <span class="hljs-operator">=</span> ctx.channel().close();<br>    future.awaitUninterruptibly();<br>    <span class="hljs-comment">// Perform post-closure operation</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// GOOD</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx,  GoodByeMessage msg)</span> &#123;<br>    <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">future</span> <span class="hljs-operator">=</span> ctx.channel().close();<br>    future.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureListener</span>() &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> &#123;<br>            <span class="hljs-comment">// Perform post-closure operation</span><br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="创建-Channel"><a href="#创建-Channel" class="headerlink" title="创建 Channel"></a>创建 Channel</h1><p>在 Bootstrap（客户端） 和 ServerBootstrap（服务端） 的启动过程中都会调用 AbstractBootstrap#channel(…) 方法（参考文章开头的 Demo）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> B <span class="hljs-title function_">channel</span><span class="hljs-params">(Class&lt;? extends C&gt; channelClass)</span> &#123;<br>    <span class="hljs-keyword">if</span> (channelClass == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;channelClass&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> channelFactory(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReflectiveChannelFactory</span>&lt;C&gt;(channelClass));<br>&#125;<br></code></pre></td></tr></table></figure><p>对于上一行的 return 语句，首先看里面的 ReflectiveChannelFactory 对象，它是一个 ChannelFactory，通过反射调用对应 Class 的默认构造函数来实例化新的 Channel。其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectiveChannelFactory</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Channel</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ChannelFactory</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>&gt; clazz;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>clazz 是 Channel 的子类，其中 newChannel 方法仅仅是调用的 Class 的 newInstance() 方法。</p><p>再来看 return 语句中的 channelFactory 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> B <span class="hljs-title function_">channelFactory</span><span class="hljs-params">(io.netty.channel.ChannelFactory&lt;? extends C&gt; channelFactory)</span> &#123;<br>    <span class="hljs-keyword">return</span> channelFactory((ChannelFactory&lt;C&gt;) channelFactory);<br>&#125;<br></code></pre></td></tr></table></figure><p>下面代码可以看出，就是将上面通过 ReflectiveChannelFactory 创建出来的 channelFactory 赋值到对应字段。注意此时并没有创建 Channel，而是在：</p><ul><li>对于 NioSocketChannel，由于它充当客户端的功能，它的创建时机在 connect(…) 的时候；</li><li>对于 NioServerSocketChannel 来说，它充当服务端功能，它的创建时机在绑定端口 bind(…) 的时候。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> B <span class="hljs-title function_">channelFactory</span><span class="hljs-params">(ChannelFactory&lt;? extends C&gt; channelFactory)</span> &#123;<br>    <span class="hljs-keyword">if</span> (channelFactory == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;channelFactory&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.channelFactory != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;channelFactory set already&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">this</span>.channelFactory = channelFactory;<br>    <span class="hljs-keyword">return</span> (B) <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们看下 ServerBootstrap 是如何创建 NioServerSocketChannel 的，以及 NioSocketChannel 是如何与 JDK 交互的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title function_">bind</span><span class="hljs-params">()</span> &#123;<br>    validate();<br>    <span class="hljs-type">SocketAddress</span> <span class="hljs-variable">localAddress</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.localAddress;<br>    <span class="hljs-keyword">if</span> (localAddress == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;localAddress not set&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> doBind(localAddress);<br>&#125;<br></code></pre></td></tr></table></figure><p>首先是 validate() 方法，验证 group 和 channelFactory 不能为 null，否则会抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> B <span class="hljs-title function_">validate</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (group == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;group not set&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (channelFactory == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;channel or channelFactory not set&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (B) <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是验证 localAddress 不为空，之后就是核心的 doBind() 逻辑了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> ChannelFuture <span class="hljs-title function_">doBind</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketAddress localAddress)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">regFuture</span> <span class="hljs-operator">=</span> initAndRegister();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> regFuture.channel();<br>    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> regFuture;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (regFuture.isDone()) &#123;<br>        <span class="hljs-comment">// At this point we know that the registration was complete and successful.</span><br>        <span class="hljs-type">ChannelPromise</span> <span class="hljs-variable">promise</span> <span class="hljs-operator">=</span> channel.newPromise();<br>        doBind0(regFuture, channel, localAddress, promise);<br>        <span class="hljs-keyword">return</span> promise;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Registration future is almost always fulfilled already, but just in case it&#x27;s not.</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">PendingRegistrationPromise</span> <span class="hljs-variable">promise</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PendingRegistrationPromise</span>(channel);<br>        regFuture.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureListener</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                <span class="hljs-type">Throwable</span> <span class="hljs-variable">cause</span> <span class="hljs-operator">=</span> future.cause();<br>                <span class="hljs-keyword">if</span> (cause != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span><br>                    <span class="hljs-comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span><br>                    promise.setFailure(cause);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// Registration was successful, so set the correct executor to use.</span><br>                    <span class="hljs-comment">// See https://github.com/netty/netty/issues/2586</span><br>                    promise.executor = channel.eventLoop();<br>                &#125;<br>                doBind0(regFuture, channel, localAddress, promise);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> promise;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先就是 initAndRegister()，返回一个注册的 ChannelFuture，通过它来获取 Channel。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title function_">initAndRegister</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> channelFactory().newChannel();<br>    <span class="hljs-keyword">try</span> &#123;<br>        init(channel);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        channel.unsafe().closeForcibly();<br>        <span class="hljs-comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultChannelPromise</span>(channel, GlobalEventExecutor.INSTANCE).setFailure(t);<br>    &#125;<br><br>    <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">regFuture</span> <span class="hljs-operator">=</span> group().register(channel);<br>    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (channel.isRegistered()) &#123;<br>            channel.close();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            channel.unsafe().closeForcibly();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> regFuture;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中比较重要的是 <code>init(channel)</code>，它有 ServerBootstrap 和 Bootstrap 两个实现，这里就不细致展开。</p><p>还有一个重要的语句是：<code>ChannelFuture regFuture = group().register(channel);</code>，其中 group() 就是 ServerBootstrap 或 Bootstrap 的 EventLoopGroup 成员变量，每个 Bootstrap 还有一个 <code>private volatile EventLoopGroup childGroup;</code> 。</p><p>io.netty.channel.AbstractChannel.AbstractUnsafe#register 方法实现如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(EventLoop eventLoop, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> &#123;<br>    ...<br><br>    <span class="hljs-comment">// 需要重用 eventloop 对象，否则用户就会得到具有不同状态的多个对象</span><br>    <span class="hljs-keyword">if</span> (AbstractChannel.<span class="hljs-built_in">this</span>.eventLoop == <span class="hljs-literal">null</span>) &#123;<br>        AbstractChannel.<span class="hljs-built_in">this</span>.eventLoop = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PausableChannelEventLoop</span>(eventLoop);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        AbstractChannel.<span class="hljs-built_in">this</span>.eventLoop.unwrapped = eventLoop;<br>    &#125;<br><br>    <span class="hljs-comment">// 当前线程是否被 event loop 执行</span><br>    <span class="hljs-keyword">if</span> (eventLoop.inEventLoop()) &#123;<br>        register0(promise);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            eventLoop.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OneTimeTask</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    register0(promise);<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="NioSocketChannel"><a href="#NioSocketChannel" class="headerlink" title="NioSocketChannel"></a>NioSocketChannel</h1><p>NioSocketChannel 的无参构造参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">NioSocketChannel</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>(DEFAULT_SELECTOR_PROVIDER);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">NioSocketChannel</span><span class="hljs-params">(SelectorProvider provider)</span> &#123;<br>    <span class="hljs-comment">// newSocket(provider) 方法会创建 JDK 的 SocketChannel</span><br>    <span class="hljs-built_in">this</span>(newSocket(provider));<br>&#125;<br></code></pre></td></tr></table></figure><p>其最终会调用：io.netty.channel.nio.AbstractNioChannel#AbstractNioChannel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-title function_">AbstractNioByteChannel</span><span class="hljs-params">(Channel parent, SelectableChannel ch)</span> &#123;<br>    <span class="hljs-comment">// 客户端关心 OP_READ 事件，等待读取服务端返回数据</span><br>    <span class="hljs-built_in">super</span>(parent, ch, SelectionKey.OP_READ);<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-title function_">AbstractNioChannel</span><span class="hljs-params">(Channel parent, SelectableChannel ch, <span class="hljs-type">int</span> readInterestOp)</span> &#123;<br>    <span class="hljs-built_in">super</span>(parent);<br>    <span class="hljs-built_in">this</span>.ch = ch;<br>    <span class="hljs-built_in">this</span>.readInterestOp = readInterestOp;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 将 SelectableChannel 配置为「非阻塞」模式</span><br>        ch.configureBlocking(<span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h1><p>ServerSocketChannel 是一个 TCP&#x2F;IP ServerChannel，处理 TCP&#x2F;IP 连接请求。</p><h1 id="NioServerSocketChannel"><a href="#NioServerSocketChannel" class="headerlink" title="NioServerSocketChannel"></a>NioServerSocketChannel</h1><p>NioServerSocketChannel 是一个 ServerSocketChannel 的实现，基于 NIO 选择器来接收新的连接。</p><h1 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h1><p>ChannelHandler 列表处理和拦截 Channel 的传入事件和传出操作。ChannelPipeline 是 Intercepting Filter 模式的扩展，用户可以完全控制事件的处理方式和管道中 ChannelHandlers 如何交互。</p><h2 id="Pipeline-创建"><a href="#Pipeline-创建" class="headerlink" title="Pipeline 创建"></a>Pipeline 创建</h2><p>每个 Channel 都有自己的 Pipeline，并且在创建 Channel 时会自动创建 Pipeline。</p><h2 id="事件是如何在-Pipeline-中传递的"><a href="#事件是如何在-Pipeline-中传递的" class="headerlink" title="事件是如何在 Pipeline 中传递的"></a>事件是如何在 Pipeline 中传递的</h2><p>下图描述了 ChannelPipeline 是如何处理 ChannelHandler 的 I&#x2F;O 事件的。 I&#x2F;O 事件由 ChannelInboundHandler 或 ChannelOutboundHandler 处理，并通过调用 ChannelHandlerContext 中定义的事件传播方法（例如 ChannelHandlerContext.fireChannelRead(Object) 和 ChannelOutboundInvoker.write(Object)）转发到其最近的 handler。</p><pre><code class="hljs">                                               I/O Request                                          via Channel or                                      ChannelHandlerContext                                                    |+---------------------------------------------------+---------------+|                           ChannelPipeline         |               ||                                                  \|/              ||    +----------------------------------------------+----------+    ||    |                   ChannelHandler  N                     |    ||    +----------+-----------------------------------+----------+    ||              /|\                                  |               ||               |                                  \|/              ||    +----------+-----------------------------------+----------+    ||    |                   ChannelHandler N-1                    |    ||    +----------+-----------------------------------+----------+    ||              /|\                                  .               ||               .                                   .               || ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()||          [method call]                      [method call]         ||               .                                   .               ||               .                                  \|/              ||    +----------+-----------------------------------+----------+    ||    |                   ChannelHandler  2                     |    ||    +----------+-----------------------------------+----------+    ||              /|\                                  |               ||               |                                  \|/              ||    +----------+-----------------------------------+----------+    ||    |                   ChannelHandler  1                     |    ||    +----------+-----------------------------------+----------+    ||              /|\                                  |               |+---------------+-----------------------------------+---------------+                |                                  \|/+---------------+-----------------------------------+---------------+|               |                                   |               ||       [ Socket.read() ]                    [ Socket.write() ]     ||                                                                   ||  Netty Internal I/O Threads (Transport Implementation)            |+-------------------------------------------------------------------+</code></pre><p>比如下面的例子，以 Inbound 开头的类表示是入站处理程序，以 Outbound 开头的类表示是出站处理程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> ...;<br>p.addLast(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">InboundHandlerA</span>());<br>p.addLast(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">InboundHandlerB</span>());<br>p.addLast(<span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutboundHandlerA</span>());<br>p.addLast(<span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutboundHandlerB</span>());<br>p.addLast(<span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">InboundOutboundHandlerX</span>());<br></code></pre></td></tr></table></figure><p>上面的示例配置中，事件进入时处理顺序是1，2，3，4，5；事件出站顺序为5，4，3，2，1。</p><ul><li>3 和 4 没有实现 ChannelInboundHandler，因此入站事件实际顺序是 1，2，5</li><li>1 和 2 没有实现 ChannelOutboundHandler，因此出站事件实际顺序是 5，4，3</li><li>5 同时实现了 ChannelInboundHandler 和 ChannelOutboundHandler</li></ul><h2 id="将事件转发到下一个-Handler"><a href="#将事件转发到下一个-Handler" class="headerlink" title="将事件转发到下一个 Handler"></a>将事件转发到下一个 Handler</h2><p>处理程序必须调用 ChannelHandlerContext 中的事件传播方法，将事件转发到其下一个处理程序。这些方法包括：</p><ul><li><p>入站事件传播方法：</p><ul><li>ChannelHandlerContext.fireChannelRegistered()</li><li>ChannelHandlerContext.fireChannelActive()</li><li>ChannelHandlerContext.fireChannelRead(Object)</li><li>ChannelHandlerContext.fireChannelReadComplete()</li><li>ChannelHandlerContext.fireExceptionCaught(Throwable)</li><li>ChannelHandlerContext.fireUserEventTriggered(Object)</li><li>ChannelHandlerContext.fireChannelWritabilityChanged()</li><li>ChannelHandlerContext.fireChannelInactive()</li><li>ChannelHandlerContext.fireChannelUnregistered()</li></ul></li><li><p>出站事件传播方法：</p><ul><li>ChannelOutboundInvoker.bind(SocketAddress, ChannelPromise)</li><li>ChannelOutboundInvoker.connect(SocketAddress, SocketAddress, ChannelPromise)</li><li>ChannelOutboundInvoker.write(Object, ChannelPromise)</li><li>ChannelHandlerContext.flush()</li><li>ChannelHandlerContext.read()</li><li>ChannelOutboundInvoker.disconnect(ChannelPromise)</li><li>ChannelOutboundInvoker.close(ChannelPromise)</li><li>ChannelOutboundInvoker.deregister(ChannelPromise)</li></ul></li></ul><p>下面的示例说明了事件是如何传播的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInboundHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Connected!&quot;</span>);<br>        ctx.fireChannelActive();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyOutboundHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelOutboundHandlerAdapter</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Closing ..&quot;</span>);<br>        ctx.close(promise);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="建立-Pipeline"><a href="#建立-Pipeline" class="headerlink" title="建立 Pipeline"></a>建立 Pipeline</h2><p>假定用户在 Pipeline 中具有一个或多个 ChannelHandler，用于处理 I&#x2F;O 事件。比如：</p><ul><li>协议解码器：将二进制数据（例如 ByteBuf）转换为 Java 对象。</li><li>协议编码器：将 Java 对象转换为二进制数据。</li><li>业务逻辑处理程序：执行实际的业务逻辑（数据库访问）。</li></ul><p>一个代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">EventExecutorGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultEventExecutorGroup</span>(<span class="hljs-number">16</span>);<br>...<br><br><span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br><br>pipeline.addLast(<span class="hljs-string">&quot;decoder&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyProtocolDecoder</span>());<br>pipeline.addLast(<span class="hljs-string">&quot;encoder&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyProtocolEncoder</span>());<br><br><span class="hljs-comment">// Tell the pipeline to run MyBusinessLogicHandler&#x27;s event handler methods</span><br><span class="hljs-comment">// in a different thread than an I/O thread so that the I/O thread is not blocked by</span><br><span class="hljs-comment">// a time-consuming task.</span><br><span class="hljs-comment">// If your business logic is fully asynchronous or finished very quickly, you don&#x27;t</span><br><span class="hljs-comment">// need to specify a group.</span><br>pipeline.addLast(group, <span class="hljs-string">&quot;handler&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyBusinessLogicHandler</span>());<br></code></pre></td></tr></table></figure><h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><p>ChannelHandler 可以在任何时候添加到 ChannelPipeline中，也可以随时从 ChannelPipeline 中移出，它是<strong>线程安全</strong>的。</p><h1 id="EventExecutorGroup"><a href="#EventExecutorGroup" class="headerlink" title="EventExecutorGroup"></a>EventExecutorGroup</h1><p>定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EventExecutorGroup</span><br><span class="hljs-keyword">extends</span> <span class="hljs-title class_">java</span>.util.concurrent.ScheduledExecutorService, java.lang.Iterable&lt;EventExecutor&gt;<br></code></pre></td></tr></table></figure><p><code>EventExecutorGroup</code> 顾名思义，就是 <code>EventExecutor 的 group</code>，负责通过其 next() 方法<code>提供要使用的 EventExecutor</code>。除此之外，它还负责处理 EventExecutor 的生命周期，并允许以全局方式关闭它们。</p><h1 id="EventExecutor"><a href="#EventExecutor" class="headerlink" title="EventExecutor"></a>EventExecutor</h1><p>EventExecutor 是一个特殊的 EventExecutorGroup，它提供一些方便的方法来查看某个线程是否在事件循环中执行。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2019-10-16-030302.png"></p><h1 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h1><p>在一个 Channel 注册后，将处理这个 Channel 的所有 I&#x2F;O 操作。<code>一个 EventLoop 实例通常将处理多个 Channel</code>。</p><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>可写的 Future。</p><h1 id="ChannelPromise"><a href="#ChannelPromise" class="headerlink" title="ChannelPromise"></a>ChannelPromise</h1><p>可写的 ChannelFuture。下图中上面的 Future 是 JDK 的 Future，下面的 Future 是 Netty 自定义的 Future，具有异步操作的结果。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2019-10-16-120128.png"></p><p>Netty 自定义的 Future 接口其方法如下图，增加了很多方法：</p><ul><li>addListener：添加 listener</li><li>await：等待 future 完成</li><li>sync：等待 future 完成，如果失败会抛出失败原因</li></ul><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2019-10-16-120511.png"></p>]]></content>
    
    
    <categories>
      
      <category>组件&amp;中间件知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Lucene、Elasticsearch、Kibana 入门教程和环境搭建</title>
    <link href="/2022/07/03/Lucene%E3%80%81Elasticsearch%E3%80%81Kibana%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%E5%92%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/07/03/Lucene%E3%80%81Elasticsearch%E3%80%81Kibana%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%E5%92%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="信息检索模型"><a href="#信息检索模型" class="headerlink" title="信息检索模型"></a>信息检索模型</h1><p>信息检索模型最重要的概念就是<code>倒排索引</code>，倒排索引是搜索引擎中常见的索引方法，用来存储在全文搜索下某个单词在一个文档中存储位置的映射。通过倒排索引，我们输入一个关键词，可以非常快地获取包含这个关键词的文档列表。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-07-02-140114.png"></p><h1 id="Lucene"><a href="#Lucene" class="headerlink" title="Lucene"></a>Lucene</h1><p>Lucene 是一个基于 Java 的全文信息检索工具包，它不是一个完整的搜索应用程序，而是为你的应用程序提供索引和搜索功能。Lucene 目前是 Apache Jakarta 家族中的一个开源项目。也是目前最为流行的基于 Java 开源全文检索工具包。</p><p>Elasticsearch 就是基于 Lucene 的。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-07-02-142736.png"></p><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><p>官网：<a href="https://lucene.apache.org/core/downloads.html">https://lucene.apache.org/core/downloads.html</a></p><p>可以使用国内镜像下载：<a href="https://mirrors.tuna.tsinghua.edu.cn/apache/lucene/java/8.5.2/lucene-8.5.2.zip">https://mirrors.tuna.tsinghua.edu.cn/apache/lucene/java/8.5.2/lucene-8.5.2.zip</a></p><p>下面是 Java 代码的简单例子，Maven 配置文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;<br>    &lt;artifactId&gt;lucene-core&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">8.5</span><span class="hljs-number">.2</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;<br>    &lt;artifactId&gt;lucene-queryparser&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">8.5</span><span class="hljs-number">.2</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;<br>    &lt;artifactId&gt;lucene-analyzers-common&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">8.5</span><span class="hljs-number">.2</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;<br>    &lt;artifactId&gt;lucene-analyzers-smartcn&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">8.5</span><span class="hljs-number">.2</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h2 id="测试分词"><a href="#测试分词" class="headerlink" title="测试分词"></a>测试分词</h2><p>注意下面使用的 SmartChineseAnalyzer 是包 lucene-analyzers-smartcn。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAnalyzer</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">chinese</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;中华人民共和国简称中国，是一个有13亿人口的国家&quot;</span>;<br>    <span class="hljs-type">Analyzer</span> <span class="hljs-variable">analyzer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SmartChineseAnalyzer</span>();<br>    <span class="hljs-type">TokenStream</span> <span class="hljs-variable">tokenStream</span> <span class="hljs-operator">=</span> analyzer.tokenStream(chinese, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringReader</span>(chinese));<br>    tokenStream.reset();<br>    <span class="hljs-type">CharTermAttribute</span> <span class="hljs-variable">attribute</span> <span class="hljs-operator">=</span> tokenStream.getAttribute(CharTermAttribute.class);<br>    System.out.println(<span class="hljs-string">&quot;分词结果：&quot;</span>);<br>    <span class="hljs-keyword">while</span> (tokenStream.incrementToken()) &#123;<br>        System.out.print(attribute.toString() + <span class="hljs-string">&quot;|&quot;</span>);<br>    &#125;<br>    analyzer.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">分词结果：<br>中华人民共和国|<span class="hljs-string">简称</span>|<span class="hljs-string">中国</span>|<span class="hljs-string">是</span>|<span class="hljs-string">一个</span>|<span class="hljs-string">有</span>|<span class="hljs-string">13</span>|<span class="hljs-string">亿</span>|<span class="hljs-string">人口</span>|<span class="hljs-string">的</span>|<span class="hljs-string">国家</span>|<br></code></pre></td></tr></table></figure><h2 id="测试索引"><a href="#测试索引" class="headerlink" title="测试索引"></a>测试索引</h2><p>下面程序创建了3个包含 id, title, content 的文档，其中每个类型都是 FieldType，使用 SmartChineseAnalyzer。索引目录是 web 根目录下的 indexDir 文件夹。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testIndex</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    List&lt;String&gt; titleList = Lists.newArrayList(<span class="hljs-string">&quot;中国房企洛杉矶丑闻：百万美元行贿案遭曝光&quot;</span>, <span class="hljs-string">&quot;2025年之前美国不会退出WTO了&quot;</span>,<br>            <span class="hljs-string">&quot;特朗普退出总统竞选？&quot;</span>);<br>    List&lt;String&gt; contentList = Lists.newArrayList(<br>            <span class="hljs-string">&quot;据调查，惠泽尔从中国房企手里收取了超过150万美元的现金贿赂，合人民币超过1000万元。&quot;</span>,<br>            <span class="hljs-string">&quot;美国特朗普政府上台以来，每隔几月，便总要传出有关“美国要退出世贸组织（WTO）”的消息。那么究竟美国能不能退出WTO？&quot;</span>,<br>            <span class="hljs-string">&quot;“共和党的操盘手首次提出了这样的可能性”，即川普总统可能会退出2020年总统竞选&quot;</span>);<br><br>    <span class="hljs-type">Path</span> <span class="hljs-variable">indexPath</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;indexDir&quot;</span>);<br>    <span class="hljs-type">Directory</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> FSDirectory.open(indexPath);<br><br>    <span class="hljs-comment">// 设置新闻ID索引并存储</span><br>    <span class="hljs-type">FieldType</span> <span class="hljs-variable">idType</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FieldType</span>();<br>    idType.setIndexOptions(IndexOptions.DOCS);<br>    idType.setStored(<span class="hljs-literal">true</span>);<br><br>    <span class="hljs-comment">// 设置新闻标题索引文档、此项频率、位移信息、偏移量，存储并词条化</span><br>    <span class="hljs-type">FieldType</span> <span class="hljs-variable">titleType</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FieldType</span>();<br>    titleType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);<br>    titleType.setStored(<span class="hljs-literal">true</span>);<br>    titleType.setTokenized(<span class="hljs-literal">true</span>);<br><br>    <span class="hljs-type">FieldType</span> <span class="hljs-variable">contentType</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FieldType</span>();<br>    contentType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);<br>    contentType.setStored(<span class="hljs-literal">true</span>);<br>    contentType.setTokenized(<span class="hljs-literal">true</span>);<br>    contentType.setStoreTermVectors(<span class="hljs-literal">true</span>);<br>    contentType.setStoreTermVectorOffsets(<span class="hljs-literal">true</span>);<br>    contentType.setStoreTermVectorPayloads(<span class="hljs-literal">true</span>);<br>    contentType.setStoreTermVectorPositions(<span class="hljs-literal">true</span>);<br><br>    <span class="hljs-type">Analyzer</span> <span class="hljs-variable">analyzer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SmartChineseAnalyzer</span>();<br>    <span class="hljs-type">IndexWriterConfig</span> <span class="hljs-variable">indexWriterConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexWriterConfig</span>(analyzer);<br>    indexWriterConfig.setOpenMode(IndexWriterConfig.OpenMode.CREATE);<br>    <span class="hljs-type">IndexWriter</span> <span class="hljs-variable">indexWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexWriter</span>(dir, indexWriterConfig);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; titleList.size(); i++) &#123;<br>        <span class="hljs-type">Document</span> <span class="hljs-variable">doc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Document</span>();<br>        doc.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Field</span>(<span class="hljs-string">&quot;id&quot;</span>, Integer.toString(i + <span class="hljs-number">1</span>), idType));<br>        doc.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Field</span>(<span class="hljs-string">&quot;title&quot;</span>, titleList.get(i), titleType));<br>        doc.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Field</span>(<span class="hljs-string">&quot;content&quot;</span>, contentList.get(i), contentType));<br>        indexWriter.addDocument(doc);<br>    &#125;<br>    indexWriter.commit();<br>    indexWriter.close();<br>    dir.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>在运行代码后，会在根目录生成 indexDir 文件夹（代码中指定），如下图所示。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-07-02-141536.png"></p><h2 id="搜索索引"><a href="#搜索索引" class="headerlink" title="搜索索引"></a>搜索索引</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSearch</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Path</span> <span class="hljs-variable">indexPath</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;indexDir&quot;</span>);<br>    <span class="hljs-type">Directory</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> FSDirectory.open(indexPath);<br>    <span class="hljs-type">IndexReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> DirectoryReader.open(dir);<br>    <span class="hljs-type">IndexSearcher</span> <span class="hljs-variable">searcher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexSearcher</span>(reader);<br>    <span class="hljs-type">Analyzer</span> <span class="hljs-variable">analyzer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SmartChineseAnalyzer</span>();<br>    <span class="hljs-type">QueryParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryParser</span>(<span class="hljs-string">&quot;title&quot;</span>, analyzer);<br>    parser.setDefaultOperator(QueryParser.Operator.AND);<br>    <span class="hljs-type">Query</span> <span class="hljs-variable">query</span> <span class="hljs-operator">=</span> parser.parse(<span class="hljs-string">&quot;房企&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;query : &quot;</span> + query.toString());<br><br>    <span class="hljs-type">TopDocs</span> <span class="hljs-variable">topDocs</span> <span class="hljs-operator">=</span> searcher.search(query, <span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">for</span> (ScoreDoc sd : topDocs.scoreDocs) &#123;<br>        <span class="hljs-type">Document</span> <span class="hljs-variable">doc</span> <span class="hljs-operator">=</span> searcher.doc(sd.doc);<br>        System.out.println(<span class="hljs-string">&quot;docId: &quot;</span> + sd.doc);<br>        System.out.println(<span class="hljs-string">&quot;id: &quot;</span> + doc.get(<span class="hljs-string">&quot;id&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;title: &quot;</span> + doc.get(<span class="hljs-string">&quot;title&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;content: &quot;</span> + doc.get(<span class="hljs-string">&quot;content&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;文档评分：&quot;</span> + sd.score);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>会搜出关于房企的信息。</p><h1 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h1><p>全文搜索属于最常见的需求，开源的 Elasticsearch （以下简称 Elastic）是目前全文搜索引擎的首选。</p><p>它可以快速地储存、搜索和分析海量数据。维基百科、Stack Overflow、Github 都采用它。</p><p>Elastic 的底层是开源库 Lucene。但是，你没法直接用 Lucene，必须自己写代码去调用它的接口。Elastic 是 Lucene 的封装，提供了 REST API 的操作接口，开箱即用。</p><p>入门教程推荐阮一峰的<a href="http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html">《全文搜索引擎 Elasticsearch 入门教程》</a></p><p>官网是：<a href="https://www.elastic.co/cn/%EF%BC%8C%E4%B8%8A%E9%9D%A2%E5%86%85%E5%AE%B9%E5%BE%88%E5%85%A8%E9%9D%A2%EF%BC%8C%E6%84%9F%E8%A7%89%E7%9B%B4%E6%8E%A5%E7%9C%8B%E5%AE%98%E7%BD%91%E6%9C%80%E5%A5%BD%E3%80%82">https://www.elastic.co/cn/，上面内容很全面，感觉直接看官网最好。</a></p><h2 id="Elastic-Stack"><a href="#Elastic-Stack" class="headerlink" title="Elastic Stack"></a>Elastic Stack</h2><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-07-02-142838.png"></p><p>原来是通过 Logstash 进行日志收集与解析，Elasticsearch 作为搜索引擎，Kibana 作为可视化分析平台。但是 Logstash 有CPU和内存性能问题，官方开发了 Beats 数据采集工具。本文通过一个例子使用 Java 直接向 Elasticsearch 发送消息，并搭建 Kibana 数据可视化查询。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-07-02-142649.png"></p><h2 id="Docker-搭建-Elasticsearch"><a href="#Docker-搭建-Elasticsearch" class="headerlink" title="Docker 搭建 Elasticsearch"></a>Docker 搭建 Elasticsearch</h2><p>说明：经过试验，本文不使用最新版本，而是使用 Elasticsearch 6.8.4 版本，因为 Spring boot data 2.3 集成的版本就是 6.8.4，同时 Kibana 也要和 Elasticsearch 版本完全一致，否则会出各种奇葩问题。</p><p>docker 拉取 6.8.4 版本镜像：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> pull elasticsearch:<span class="hljs-number">6</span>.<span class="hljs-number">8</span>.<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>启动镜像：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d -p <span class="hljs-number">9200</span>:<span class="hljs-number">9200</span> -p <span class="hljs-number">9300</span>:<span class="hljs-number">9300</span> -e <span class="hljs-string">&quot;discovery.type=single-node&quot;</span> elasticsearch:<span class="hljs-number">6</span>.<span class="hljs-number">8</span>.<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>这里使用简单模式，9200是 HTTP rest 协议，9300 是 tcp 协议。启动完成后，可以在浏览器中输入网址 0.0.0.0:9200，返回一下内容说明启动成功：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;_jhdsik&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;cluster_name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;docker-cluster&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;cluster_uuid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mpaTnrRaSY2_e3LFPz4QXw&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;number&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;6.8.4&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;build_flavor&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;default&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;build_type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;docker&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;build_hash&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;bca0c8d&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;build_date&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2019-10-16T06:19:49.319352Z&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;build_snapshot&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;lucene_version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;7.7.2&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;minimum_wire_compatibility_version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;5.6.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;minimum_index_compatibility_version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;5.0.0&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;tagline&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;You Know, for Search&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>如果要看 log，可以使用命令：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> logs -f <span class="hljs-number">44</span>afc4738685<br></code></pre></td></tr></table></figure><p>其中 44afc4738685 是 CONTAINER ID（可通过 docker ps 查看）。</p><p>修改 Elasticsearch 配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it epic_beaver /bin/bash<br></code></pre></td></tr></table></figure><p>其中 epic_beaver 是我的 docker Elasticsearch 容器名称。进入 config 目录修改 elasticsearch.yml 文件。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">cluster</span>.name: &quot;docker-cluster&quot;<br>network.host: <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br># xpack.<span class="hljs-keyword">security</span>.enabled: <span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><p>其中 <code>xpack.security.enabled</code> 在设置密码时使用，暂时不做设置。</p><p>修改完配置文件，重启容器。</p><h2 id="Docker-搭建-Kibana"><a href="#Docker-搭建-Kibana" class="headerlink" title="Docker 搭建 Kibana"></a>Docker 搭建 Kibana</h2><p>由于 Elasticsearch 使用的是 6.8.4 版本，Kibana 也要使用这个版本。</p><p>docker 下载 Kibana 镜像：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> pull kebana:<span class="hljs-number">6</span>.<span class="hljs-number">8</span>.<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>修改配置文件（本例是 &#x2F;root&#x2F;etc&#x2F;kibana.yml）</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">server.name:</span> kibana<br><span class="hljs-symbol">server.host:</span> <span class="hljs-string">&quot;0&quot;</span><br><span class="hljs-symbol">elasticsearch.hosts:</span> [ <span class="hljs-string">&quot;http://0.0.0.0:9200&quot;</span> ]<br><span class="hljs-meta"># xpack.monitoring.ui.container.elasticsearch.enabled: true</span><br></code></pre></td></tr></table></figure><p>注：这里的 <code>elasticsearch.hosts</code> 配置跟 docker 网络模式有关，因为 elasticsearch 和 kibana 是 2 个独立的 docker 容器，直接设置 <a href="http://0.0.0.0:9200/">http://0.0.0.0:9200</a> 可能不通，需要额外配置。本例使用的是阿里云的服务器，配置成了公网 IP，配置中改成了 0.0.0.0，读者需要自行替换。</p><p>docker 启动 Kibana：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">docker run -d --restart=always --<span class="hljs-built_in">log</span>-driver json-<span class="hljs-keyword">file</span> --<span class="hljs-built_in">log</span>-<span class="hljs-keyword">opt</span> <span class="hljs-built_in">max</span>-size=<span class="hljs-number">100</span><span class="hljs-keyword">m</span> --<span class="hljs-built_in">log</span>-<span class="hljs-keyword">opt</span> <span class="hljs-built_in">max</span>-<span class="hljs-keyword">file</span>=<span class="hljs-number">2</span> --name kibana -<span class="hljs-keyword">p</span> <span class="hljs-number">5601</span>:<span class="hljs-number">5601</span> -v /root/etc/kibana.yml:/usr/share/kibana/config/kibana.yml kiban<span class="hljs-variable">a:6</span>.<span class="hljs-number">8.4</span><br></code></pre></td></tr></table></figure><p>在浏览器输入 0.0.0.0:5601，如果出现下面的界面，则表示启动成功。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-07-02-144919.png"></p><p>启动失败可以通过 <code>docker logs -f kibana_container_id</code> 查看日志。</p><h2 id="demo-1"><a href="#demo-1" class="headerlink" title="demo"></a>demo</h2><p>本例使用 Spring boot，Maven pom 引入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在 application.yml 中增加:</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">data</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">elasticsearch</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">cluster-nodes</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0.0.0.0:9300</span><br>    <span class="hljs-attribute">cluster-name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">docker-cluster</span><br></code></pre></td></tr></table></figure><p>写一个实体类 EsNewsEntity，indexName 设置为 news_test：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Builder</span><br><span class="hljs-meta">@Document(indexName = &quot;news_test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EsNewsEntity</span> &#123;<br><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-keyword">private</span> String id;<br>    <span class="hljs-keyword">private</span> String title;<br>    <span class="hljs-keyword">private</span> String content;<br><br>    <span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span><br>    <span class="hljs-meta">@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;, timezone = &quot;GMT+8&quot;)</span><br>    <span class="hljs-keyword">private</span> Date time;<br>&#125;<br></code></pre></td></tr></table></figure><p>整体查询使用 ElasticsearchRepository，里面有 CRUD 的操作，还有分页和排序，Spring data 使各种数据查询有了统一的操作接口，使用起来也很方便。</p><p>本例中只是想 ES 中简单插入一些数据，repository 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EsNewsRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ElasticsearchRepository</span>&lt;EsNewsEntity, String&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>插入数据的代码如下，其中插入了2条 title 为 “韩国男星” 的文章，1条 title 为 “特大暴雨”的文章：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testEs</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">EsNewsEntity</span> <span class="hljs-variable">newsEntity</span> <span class="hljs-operator">=</span> EsNewsEntity.builder().id(<span class="hljs-string">&quot;1&quot;</span>).title(<span class="hljs-string">&quot;韩国男星&quot;</span>)<br>            .content(<span class="hljs-string">&quot;我很喜欢大神、金钟国、光洙&quot;</span>).time(DateTime.now().toDate()).build();<br>    esNewsRepository.save(newsEntity);<br><br>    newsEntity = EsNewsEntity.builder().id(<span class="hljs-string">&quot;2&quot;</span>).title(<span class="hljs-string">&quot;特大暴雨&quot;</span>)<br>            .content(<span class="hljs-string">&quot;特大暴雨夜袭四川冕宁:山洪摧毁村庄 一家5口遇难&quot;</span>).time(DateTime.now().toDate()).build();<br>    esNewsRepository.save(newsEntity);<br><br>    newsEntity = EsNewsEntity.builder().id(<span class="hljs-string">&quot;3&quot;</span>).title(<span class="hljs-string">&quot;韩国男星&quot;</span>)<br>            .content(<span class="hljs-string">&quot;韩国男星身材管理多严格？金秀贤 Rain有八块腹肌&quot;</span>).time(DateTime.now().toDate()).build();<br>    esNewsRepository.save(newsEntity);<br><br>    System.out.println(<span class="hljs-string">&quot;es save ...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行之后，在 Kibana-&gt;Management-&gt;Create index pattern，输入上面 News 的 indexName：news_test，设置 Date 为时间索引。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-07-02-153952.png"></p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-07-02-154129.png"></p><p>之后刷新页面，可以根据时间搜索新插入的几条数据。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-07-02-154226.png"></p><h1 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h1><ol><li>本例的 es 和 Kibana 没有使用密码登录，在实际应用过程中 es 可以限制 ip 访问。我在研究的过程中，设置好 es 和 Kibana 的密码后，没法使用 Spring data 直接与 es 通信，暂时放弃。</li><li>es 和 Kibana 的版本一定要一致！</li><li>spring-boot-starter-data-elasticsearch 的 es 版本并不高，最新版本已经是 7.8，但是 spring-boot-starter-data-elasticsearch 集成的仍然是 6.8，需要注意。如果必须使用最新版，需要额外配置。</li><li>Kibana 在分析日志、数据分析时很强大。</li><li>本示例是 demo 演示，不要在生产环境中使用。</li><li>可以直接在腾讯云、阿里云上购买 es 服务，不过真心贵……小站点或个人开发者还是自行搭建比较划算。</li><li>《Lucene Elasticsearch 全文检索实战》这本书不建议买，书的内容浅显，排版和内容问题很多。比如有的代码分隔符是中文标点，书的前几章代码是深色背景，后几章代码没有背景……</li></ol>]]></content>
    
    
    <categories>
      
      <category>组件&amp;中间件知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM G1 GC 的算法与实现</title>
    <link href="/2022/03/16/JVM%20G1%20GC%20%E7%9A%84%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/03/16/JVM%20G1%20GC%20%E7%9A%84%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="G1GC-是什么？"><a href="#G1GC-是什么？" class="headerlink" title="G1GC 是什么？"></a>G1GC 是什么？</h1><p>G1GC（Garbage First Garbage Collection）是在 OpenJDK 7 中引入的 GC 算法，其最大的特点就是非常重视<code>实时性</code>。</p><h1 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h1><h2 id="实时性"><a href="#实时性" class="headerlink" title="实时性"></a>实时性</h2><p>程序具有实时性，是指程序必须能在最后期限（deadline）之前完成，其中最后期限可以自由指定。实时性分为两种：</p><ul><li><code>硬实时性</code>（hard real-time）：每次处理的时间都不能超过最后期限，比如医疗机器人控制系统、航空管制系统。</li><li><code>软实时性</code>（soft real-time）：稍微超出几次最后期限也没有什么问题的系统，例如网络银行系统。</li></ul><p>G1GC 具有软实时性，为了实现软实时性，必须具备以下功能：</p><ul><li>设置<code>期望暂停时间</code>（最后期限）</li><li><code>可预测性</code>：预测下次 GC 会导致应用程序暂停多长时间。根据预测出的结果，G1GC 会通过<code>延迟执行 GC</code>、<code>拆分 GC 目标对象</code>等手段来遵守上面设置的期望暂停时间。</li></ul><h2 id="G1GC-有什么特点？"><a href="#G1GC-有什么特点？" class="headerlink" title="G1GC 有什么特点？"></a>G1GC 有什么特点？</h2><p>Java 中已经有很多种 GC 算法了，为什么还要增加 G1GC 算法呢？</p><ul><li>以往的 GC 都是尽可能缩短最大暂停时间，但是缩短最大暂停时间很容易导致吞吐量下降。</li><li>以往的 GC 无法预测暂停时间，GC 时可能会使应用程序长时间暂停的风险。</li><li>G1GC 的目的就是高效地实现软实时性，能够让用户设置期望暂停时间。在确保吞吐量比以往的 GC 更好的前提下，实现了软实时性。</li><li>G1GC 能最大程度利用服务器上多处理器的优势，而且在处理巨大的堆时，也不会降低 GC 的性能。</li></ul><h1 id="G1GC-的堆结构是什么样的？"><a href="#G1GC-的堆结构是什么样的？" class="headerlink" title="G1GC 的堆结构是什么样的？"></a>G1GC 的堆结构是什么样的？</h1><p>G1GC 堆的内部被划分为大小相等的区域，所有区域排成一排。G1GC 以区域为单位进行 GC。用户可以随意设置区域大小，但是内部会将用户设置的值向上调整为 2 的指数幂，并以该正数作为区域的大小（如下图）。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210307224725.png" alt="图 1.1"></p><h1 id="G1GC-的执行过程是什么样的？"><a href="#G1GC-的执行过程是什么样的？" class="headerlink" title="G1GC 的执行过程是什么样的？"></a>G1GC 的执行过程是什么样的？</h1><ul><li><code>并发标记</code>（concurrent marking）：和应用程序并发执行，针对区域内所有的存活对象进行标记。</li><li><code>转移</code>（evacuation）：释放堆中死亡对象所占的内存空间。</li></ul><p>白色区域是空闲区域，灰色区域是使用中的区域。</p><ul><li>左图表示的是在选中区域后开始将存活对象复制到空闲区域的操作</li><li>右图表示的是转移后堆的状态。</li></ul><p>为了方便演示，图中的区域以二维的方式排列，但是在内存中其实如下图是排列成一排的。</p><p><img src="https://logflies.oss-cn-chengdu.aliyuncs.com/uPic/20210307225026.png"></p><h1 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h1><h2 id="并发标记是什么"><a href="#并发标记是什么" class="headerlink" title="并发标记是什么"></a>并发标记是什么</h2><p>简单标记，所有可从根直接触达的对象都会被添加标记。带标记的是存活对象，不带标记的是死亡对象。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210308075521.png"></p><p>在并发标记中，存活对象的标记和应用程序几乎是并发进行的，步骤更加复杂。并发标记并不是直接在对象上添加标记，而是在<code>标记位图</code>上添加标记。</p><h2 id="标记位图"><a href="#标记位图" class="headerlink" title="标记位图"></a>标记位图</h2><p>下图表示堆中的一个区域，位图中黑色表示已标记，白色表示未标记。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210308075725.png"></p><p>每个区域有两个标记位图：</p><ul><li><code>next</code>：本次标记的标记位图。</li><li><code>prev</code>：上次标记的标记位图，保存了上次标记的结果。</li></ul><p>标记位图中的每个比特都对应关联区域内的对象的开头部分。图中区域部分：</p><ul><li><code>bottom</code>：区域内众多对象的末尾</li><li><code>top</code>：区域中对象的开头</li><li><code>nextTAMS</code>：本次标记开始时的 top（TAMS-Top At Marking Start）</li><li><code>prevTAMS</code>：上次标记开始时的 top</li></ul><h2 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h2><ol><li><code>初始标记阶段</code>：暂停应用程序，标记可由根直接引用的对象。</li><li><code>并发标记阶段</code>：与应用程序并发进行，扫描 1 中标记的对象所引用的对象。</li><li><code>最终标记阶段</code>：暂停应用程序，扫描 2 中没有标记的对象。本步骤结束后，堆内所有存活对象都会被标记。</li><li><code>存活对象计数</code>：对每个区域中被标记的对象进行计数，并发执行。</li><li><code>收尾工作</code>：暂停应用程序，收尾工作，并为下次标记做准备。</li></ol><h2 id="步骤-1——初始标记阶段"><a href="#步骤-1——初始标记阶段" class="headerlink" title="步骤 1——初始标记阶段"></a>步骤 1——初始标记阶段</h2><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210308080825.png"></p><p>在初始标记阶段，GC 线程首先创建标记位图 next。其中 nextTAMS 是标记开始时，top 所在的位置。位图的大小也和 top 对齐，是 (top-botton)&#x2F;8 字节。</p><p>等所有区域的标记位图都创建完成后，标记由根直接引用的对象（根扫描）。此时是需要暂停应用程序的，这是为了防止扫描过程中根被修改。</p><p>如果一个对象本身被标记，但是子对象没有被扫描，我们称之为<code>未扫描对象</code>，上图用灰色标识，C 持有子对象 A 和 E，但是 A 和 E 并未被扫描。</p><h2 id="步骤-2——并发标记阶段"><a href="#步骤-2——并发标记阶段" class="headerlink" title="步骤 2——并发标记阶段"></a>步骤 2——并发标记阶段</h2><p>在并发标记阶段，GC 线程扫描在 1 阶段标记过的对象，完成对大部分存活对象的标记。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210308082022.png"></p><p>上图表示并发标记结束的状态，对象 C 的子对象 A 和 E 都被标记了。E 对应了标记位图中多个位，只有起始的标记位（mark bit）会被涂成黑色。</p><p>因为并发标记是和应用程序并发执行的，所以在这个阶段可能会产生的对象，上图中 J 和 K 就是在并发标记期间新创建的对象，直接会被 GC 当成存活对象。</p><p>同时因为是并发执行，应用程序可能会改变了对象之间的引用关系，需要使用写屏障技术来记录对象间引用关系的变化。并发标记阶段也会标记和扫描被写屏障感知变化的对象。</p><h3 id="SATB"><a href="#SATB" class="headerlink" title="SATB"></a>SATB</h3><p>SATB（Snapshot At The Beginning，初始快照）是将并发标记阶段开始时对象间的引用关系，以逻辑快照的形式保存起来。标记过程中新生成的对象是“已完成扫描和标记”的，其子对象不会被标记。那如何区分是标记过程中新生成的对象呢？初始标记阶段记录的 nextTAMS 和 当前 top 之间的对象，所以并不需要专门为新生成的对象创建标记位图。</p><p>还有个很重要的问题，在并发标记过程中，对象的域发生了写操作怎么办？此时必须以某种方式记录被改写之前的引用关系。</p><p>G1GC 使用<code>SATB 专用写屏障</code>。在一个对象的域发生写操作时，这个对象会被放入 SATB 本地队列（SATB 本地队列满后，会被添加到全局的 SATB 队列结合）。在并发标记阶段，GC 线程会定期检查 SATB 队列集合的大小，对队列中的全部对象进行标记和扫描。如果获取到已经被标记的对象，这些对象不会再次被标记和扫描。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210308085208.png"></p><h2 id="步骤-3——最终标记阶段"><a href="#步骤-3——最终标记阶段" class="headerlink" title="步骤 3——最终标记阶段"></a>步骤 3——最终标记阶段</h2><p>主要扫描 SATB 本地队列（队里里仍然存放了待扫描对象）。因为 SATB 本地队列会被应用程序操作，所以需要暂停应用程序。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210308085617.png"></p><p>上图中 SATB 本地队列中还有对象 G 和 H 的引用，扫描后对象 G 和 H，以及对象 H 的子对象 I 都会变成黑色。</p><h2 id="步骤-4——存活对象计数"><a href="#步骤-4——存活对象计数" class="headerlink" title="步骤 4——存活对象计数"></a>步骤 4——存活对象计数</h2><p>扫描各个区域的标记位图 next，统计区域内存活对象的字节数，存到区域内的 next_marked_bytes 中。下图中存活对象 A、C、E、G、H 和 I，一共 6 个对象，其中 E 真实大小是 16 个字节，其余 5 个对象分别是 8 个字节，所以 next_marked_bytes 是 56 个字节。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210308090430.png" alt="存活对象计数结束后区域的状态"></p><p>在计数的过程中，又新创建了对象 L 和 M，nextTAMS 和 top 之间的对象都会被当做存活对象处理，没有特意进行计数。</p><h2 id="步骤-5——收尾工作"><a href="#步骤-5——收尾工作" class="headerlink" title="步骤 5——收尾工作"></a>步骤 5——收尾工作</h2><p>收尾工作所操作的数据中有些是和应用程序共享的，所以需要暂停应用程序。</p><p>收尾阶段主要做了两件事情：</p><ul><li>GC 线程逐个扫描每个区域，将标记位图 next 的并发标记结果移动到标记位图 prev 中，再重置标记，为下次并发做准备。</li><li>在扫描过程中，<code>计算每个区域的转移效率</code>，并按照该效率对区域进行降序排序。</li></ul><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210309085124.png" alt="收尾工作完成后区域的状态"></p><p>上图中 prevTAMS 被移动到了 nextTAMS 原来的位置，表示“上次并发标记开始时 top 的位置”。next.next_marked_bytes 也会被重置，同时  nextTAMS 移动到 bottom 的位置，其会在下次并发标记开始时，移动到 top 的最新位置。</p><h2 id="转移效率"><a href="#转移效率" class="headerlink" title="转移效率"></a>转移效率</h2><p>指转移 1 个字节所需的时间。通俗理解就是，区域内死亡对象越多，存活对象就越少；而存活对象越少，那么转移所需的时间就越少。</p><p>计算公式为：死亡对象的字节数 &#x2F; 转移所需时间</p><h2 id="并发标记总结"><a href="#并发标记总结" class="headerlink" title="并发标记总结"></a>并发标记总结</h2><p>并发标记结束后，可以得到：</p><ul><li>并发标记完成时，<code>存活对象和死亡对象的区分</code>（此时在标记位图 prev）</li><li><code>存活对象的字节数</code>（prev_marked_bytes）</li></ul><p>如果新的对象是在并发标记结束后被创建的，因为新对象是分配在 prevTAMS 和 top 之间的，所以后被当成存活对象处理。</p><h1 id="转移"><a href="#转移" class="headerlink" title="转移"></a>转移</h1><h2 id="转移是什么？"><a href="#转移是什么？" class="headerlink" title="转移是什么？"></a>转移是什么？</h2><p>将所选区域内的所有存活对象都转移到空闲区域，因此被转移区域就只剩下死亡对象。重置之后，该区域就会成为空闲区域。</p><h2 id="转移专用记忆集合"><a href="#转移专用记忆集合" class="headerlink" title="转移专用记忆集合"></a>转移专用记忆集合</h2><p>上节介绍的<code>SATB 队列集合</code>是记录<code>标记过程中对象之间引用关系的变化</code>，这里的转移专用记忆集合记录<code>区域间的引用关系</code>，这样不用扫描所有区域的对象，也能查到待转移对象所占区域内的对象被其他区域引用的情况。</p><p>G1GC 是通过卡表（card table）来实现转移专用记忆集合的。</p><h3 id="卡表"><a href="#卡表" class="headerlink" title="卡表"></a>卡表</h3><p>是元素大小为 1B 的数组，堆中大小适当的一段存储空间（通常是 512B）对应卡表中的 1 个元素。在堆大小是 1GB 时，卡表大小为 2MB。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210309091556.png" alt="卡表的构造"></p><p>堆中对象所对应的卡片在卡表的索引值 &#x3D; （对象的地址 - 堆的头部地址） &#x2F; 512</p><p>因为卡片的大小是 1B，所有可以表示很多状态，状态有很多，在后面只介绍两种：</p><ul><li>净卡片</li><li>脏卡片</li></ul><h3 id="转移专用记忆集合的构造"><a href="#转移专用记忆集合的构造" class="headerlink" title="转移专用记忆集合的构造"></a>转移专用记忆集合的构造</h3><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210309092433.png" alt="转移专用记忆集合的构造"></p><p>每个区域都有一个转移专用记忆集合，是通过散列表实现的：</p><ul><li>键：引用本区域的其他区域的地址</li><li>值：数组，数组元素是<code>引用方的对象所对应的卡片索引</code></li></ul><p>在上图中，区域 B 中的对象 b 引用了区域 A 中的对象 a。因为对象 b 不是区域 A 中的对象，所以必须记录这个引用关系。在转移记忆集合 A 中，以区域 B 的地址为键记录了卡片的索引 2048（对象 b 对应的卡片索引），此时对象 b 对对象 a 的引用被准确记录了下来。</p><h2 id="转移专用写屏障"><a href="#转移专用写屏障" class="headerlink" title="转移专用写屏障"></a>转移专用写屏障</h2><p>那 GC 是如何感知域的变化呢？是通过<code>转移专用写屏障</code>，当对象修改时，会被转移专用写屏障记录到转移专用记忆集合中。</p><p>每个应用程序线程都持有一个<code>转移专用记忆集合日志</code>的缓冲区，其中存放的是卡片索引的数组。当对象 b 的域被修改时，写屏障就会感知，并会将对象 b 所对应的卡片索引添加到转移专用记忆集合日志中。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210309093018.png" alt="转移专用记忆集合日志及其集合"></p><h2 id="转移专用记忆集合维护线程"><a href="#转移专用记忆集合维护线程" class="headerlink" title="转移专用记忆集合维护线程"></a>转移专用记忆集合维护线程</h2><p>是和应用程序并发执行的线程，是基于上述日志维护转移专用记忆集合。主要步骤：</p><ul><li>从转移专用记忆集合日志的集合中取出转移专用记忆集合日志，从头开始扫描</li><li>将卡片变为净卡片</li><li>检查卡片所对应存储空间内的所有对象的域</li><li>向域中地址所指向的区域的记忆集合中添加卡片</li></ul><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210309093506.png"></p><h2 id="热卡片"><a href="#热卡片" class="headerlink" title="热卡片"></a>热卡片</h2><p>频繁发生修改的存储空间所对应的卡片就是<code>热卡片</code>。热卡片可能会多次进入转移专用记忆集合日志，被多次处理成脏卡片，增加维护线程的负担。</p><p>可以通过卡片计数器，发现热卡片，当某个卡片变成脏卡片的次数超过阈值，可以等到转移的时候再处理。</p><h2 id="转移的执行步骤"><a href="#转移的执行步骤" class="headerlink" title="转移的执行步骤"></a>转移的执行步骤</h2><ul><li><code>选择回收集合</code>：参考并发标记提供的信息，选择要转移的区域。</li><li><code>根转移</code>：将回收集合内由根直接引用的对象，及被其他区域引用的对象转移到空闲区域中。</li><li><code>转移</code>：以根转移的对象为起点，扫描子孙对象，将所有存活对象一并转移。此时回收集合内所有存活对象都转移完成了。</li></ul><h2 id="步骤-1——选择回收集合"><a href="#步骤-1——选择回收集合" class="headerlink" title="步骤 1——选择回收集合"></a>步骤 1——选择回收集合</h2><p>选择待回收区域的标准：</p><ul><li>转移效率要高</li><li>转移的预测停顿时间在用户的容忍范围内</li></ul><p>在并发标记阶段结束时，堆中区域已经按照转移效率降序了。这里就是按照排好的顺序依次计算各个区域内的预测暂停时间，当所有已选区域预测的暂停时间和快要超过用户的容忍范围时，后续区域的选择就会停止，当前所选的区域就是 1 个回收集合。</p><h2 id="步骤-2——根转移"><a href="#步骤-2——根转移" class="headerlink" title="步骤 2——根转移"></a>步骤 2——根转移</h2><p>根转移的对象包括：</p><ul><li>由根直接引用的对象</li><li>并发标记处理中的对象</li><li>由其他区域对象直接引用的回收集合内的对象</li></ul><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210309094703.png" alt="对象转移"></p><ol><li>对象 a 转移到空闲区域。</li><li>对象 a 在空闲区域中的新地址写入到转移前所在区域中的旧位置。</li><li>将对象 a 引用的所有<code>位于回收集合内的对象</code>，都添加到转移队列中。转移队列临时保存<code>待转移对象的引用方</code>。因为对象 a 引用了对象 b，两个都是要转移的对象，地址都会变化。</li><li>针对对象 a 引用的<code>位于回收集合外的对象</code>，更新转移专用记忆集合。对象 c 所在区域不在回收集合内，但是区域 C 的转移专用记忆集合记录了 a 对应的卡片，在 a 转移之后，需要更新区域 C 的转移专用记忆集合。</li><li>针对<code>对象 a 的引用方</code>，更新转移专用记忆集合。</li></ol><h2 id="步骤-3——转移"><a href="#步骤-3——转移" class="headerlink" title="步骤 3——转移"></a>步骤 3——转移</h2><p>完成根转移后，被转移队列引用的对象会依次转移。当转移队列清空后，转移就完成了。此时回收集合内所有存活对象都转移完成了。</p><h1 id="分代-G1GC-模式"><a href="#分代-G1GC-模式" class="headerlink" title="分代 G1GC 模式"></a>分代 G1GC 模式</h1><p>G1GC 有 2 中模式：</p><ul><li><code>纯 G1GC 模式</code>：pure garbage-first mode</li><li><code>分代 G1GC 模式</code>：generational garbage-first mode</li></ul><p>本文上面讲的都是纯 G1GC 模式。</p><h2 id="两种-GC-的区别"><a href="#两种-GC-的区别" class="headerlink" title="两种 GC 的区别"></a>两种 GC 的区别</h2><p>和纯 G1GC 模式相比，分代 G1GC 模式主要有以下两个不同点。</p><ul><li>区域是分代的</li><li>回收集合的选择是分代的</li></ul><p>在分代 G1GC 模式中，区域被分为<code>新生代区域</code>和<code>老年代区域</code>两类。 和其他分代 GC 算法一样，分代 G1GC 的对象也保存了自身<code>在各次转移中存活下来的次数</code>。新生代区域用来存放新生代对象，老年代区域用来存放老年代对象。</p><p>G1GC 中新生代 GC 是<code>完全新生代 GC</code>，老年代 GC 是<code>部分新生代 GC</code>。二者区别在于完全新生代 GC 将所有新生代区域选入回收集合，而部分新生代 GC 将所有新生代区域，以及一部分老年代区域选入回收集合。</p><h2 id="新生代区域"><a href="#新生代区域" class="headerlink" title="新生代区域"></a>新生代区域</h2><p>新生代区域可以进一步分为两类：</p><ul><li>创建区域：存放刚刚生成，一次也没有转移过的对象</li><li>存活区域：存放至少转移过一次的对象</li></ul><p><em>转移专用写屏障不会应用在新生代区域的对象上</em>。为什么这样做是可以的呢？因为转移专用记忆集合维护的是<code>区域之间的引用关系</code>，所以在转移时不用扫描整个区域就能找到待转移对象所在区域的存活对象。而在分代 G1GC 模式中，所有新生代区域都会被选入回收集合，所有对象的引用都会被检查，这些信息就没有记录在转移专用记忆集合中了。</p><h2 id="分代对象转移"><a href="#分代对象转移" class="headerlink" title="分代对象转移"></a>分代对象转移</h2><p>存活对象保存了自己被转移的次数，这个次数就是<code>对象的年龄</code>。</p><ul><li>年龄&lt;阈值：转移到存活区域</li><li>年龄&gt;&#x3D;阈值：转移到老年代区域</li></ul><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210309102101.png" alt="完全新生代 GC 的执行过程"></p><p>如上图，完全新生代 GC 不会选择老年代区域，而是将所有新生代区域都选入回收集合，然后统一转移回收集合的对象。晋升的对象会被转移到老年代区域，其余的转移到存活区域。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210309102244.png" alt="部分新生代 GC 的执行过程"></p><p>如上图，部分新生代 GC 除了所有新生代区域外，还会选择一些老年代区域进入回收集合。其余都和完全新生代 GC 一样。</p><h2 id="GC-的切换"><a href="#GC-的切换" class="headerlink" title="GC 的切换"></a>GC 的切换</h2><p>如果新生代的区域数太多，可能导致 GC 暂停时间上限的增加，无法保证软实时性。分代 G1GC 模式需要计算出<code>合理的最大新生代区域</code>。该值的设置是在并发标记结束后。</p><p>参考并发标记中标记出的死亡对象个数，预测出下次部分新 生代 GC 的转移效率。然后，根据过去的完全新生代 GC 的转移效率， 预测出下次完全新生代 GC 的转移效率。如果预测出完全新生代 GC 的 转移效率更高，则切换为完全新生代 GC。</p><h2 id="GC-的执行时机"><a href="#GC-的执行时机" class="headerlink" title="GC 的执行时机"></a>GC 的执行时机</h2><p>当新生代区域数达到上限时，会触发转移的执行。，当转移完成并通过以下 4 项检查，会执行并发标记：</p><ul><li>不在并发标记执行过程中</li><li>并发标记的结果已被上次转移使用完</li><li>已经使用了一定量的堆内存</li><li>相比上次转移完成后，堆内存的使用量有所增加</li></ul><h1 id="G1-算法总结"><a href="#G1-算法总结" class="headerlink" title="G1 算法总结"></a>G1 算法总结</h1><h2 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h2><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210309103635.png"></p><p>图中并列的箭头表示可能会并行执行。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>软实时性</li><li>充分发挥高配置机器的性能，缩减 GC 暂停时间</li><li>区域内不会产生内存碎片</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>被限定为“搭载多核处理器、拥有大容量内存的机器”，适用受限。</li><li>尽管区域内不会出现碎片化，但是会出现以区域为单位（整个堆）的碎片化。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入 Java 虚拟机-JVM G1GC 的算法与实现》</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Netty HashedWheelTimer 时间轮源码详解</title>
    <link href="/2022/03/02/Netty%20HashedWheelTimer%20%E6%97%B6%E9%97%B4%E8%BD%AE%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
    <url>/2022/03/02/Netty%20HashedWheelTimer%20%E6%97%B6%E9%97%B4%E8%BD%AE%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>HashedWheelTimer 本质是一种类似延迟任务队列的实现，适用于对时效性不高的，可快速执行的，大量这样的“小”任务，能够做到高性能，低消耗。</p><p>时间轮是一种非常惊艳的数据结构。其在 Linux 内核中使用广泛，是 Linux 内核定时器的实现方法和基础之一。Netty 内部基于时间轮实现了一个 HashedWheelTimer 来优化 I&#x2F;O 超时的检测。</p><p>因为 Netty 需要管理上万的连接，每个连接又会有发送超时、心跳检测等，如果都使用 Timer 定时器的话，将耗费大量的资源。</p><p>在 Netty 中的一个典型应用场景是判断某个连接是否 idle，如果 idle（如客户端由于网络原因导致到服务器的心跳无法送达），则服务器会主动断开连接，释放资源。得益于 Netty NIO 的优异性能，基于 Netty 开发的服务器可以维持大量的长连接，单台 8 核 16G 的云主机可以同时维持几十万长连接，及时掐掉不活跃的连接就显得尤其重要。</p><h1 id="延迟任务方案都有哪些？优缺点？"><a href="#延迟任务方案都有哪些？优缺点？" class="headerlink" title="延迟任务方案都有哪些？优缺点？"></a>延迟任务方案都有哪些？优缺点？</h1><ul><li><code>数据库轮询</code>：数据先保存在数据库中，然后启动一个定时任务，根据时间和状态将待完成的任务数据捞出来，处理完成后再更新数据库。这种方法比较简洁，但是依赖数据库，同时如果任务数据量很大（千万）且的话，会存在数据库读写性能问题，且数据库读写可能占用大量时间，甚至超过任务处理的时间。有点是数据可以持久化，服务重启不丢失，并且可以查询管理未完成的任务。</li><li><code>DelayQueue</code> 本质是一个 PriorityQueue，每次插入和删除都调整堆，时间复杂度是 O(longN)，而 HashedWheelTimer 的时间复杂度是 O(1)。</li><li><code>ScheduledExecutorService</code>，JDK 的 ScheduledExecutorService 本质上仍然是一个 DelayQueue，但是任务是通过多线程的方式进行。</li></ul><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>源码分析首先通过一个<code>使用示例</code>开始，HashedWheelTimer 一个典型的使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">HashedWheelTimer</span> <span class="hljs-variable">wheelTimer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashedWheelTimer</span>();<br>    wheelTimer.newTimeout(timeout -&gt; System.out.println(<span class="hljs-string">&quot;1s delay&quot;</span>), <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>    wheelTimer.newTimeout(timeout -&gt; System.out.println(<span class="hljs-string">&quot;10s delay&quot;</span>), <span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>    wheelTimer.newTimeout(timeout -&gt; System.out.println(<span class="hljs-string">&quot;11s delay&quot;</span>), <span class="hljs-number">11</span>, TimeUnit.SECONDS);<br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">20</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在新建一个 HashedWheelTimer 对象实例后，可以向里面添加一个延迟任务，需要指定任务 TimerTask，延迟时间。</p><h2 id="DOC-文档"><a href="#DOC-文档" class="headerlink" title="DOC 文档"></a>DOC 文档</h2><p>官方的 4.0 版本的 doc 文档：<a href="https://netty.io/4.0/api/io/netty/util/HashedWheelTimer.html">https://netty.io/4.0/api/io/netty/util/HashedWheelTimer.html</a></p><div class="block">A <a href="../../../io/netty/util/Timer.html" title="interface in io.netty.util"><code>Timer</code></a> optimized for approximated I/O timeout scheduling.<h3>Tick Duration</h3>As described with 'approximated', this timer does not execute the scheduled<a href="../../../io/netty/util/TimerTask.html" title="interface in io.netty.util"><code>TimerTask</code></a> on time. <a href="../../../io/netty/util/HashedWheelTimer.html" title="class in io.netty.util"><code>HashedWheelTimer</code></a>, on every tick, willcheck if there are any <a href="../../../io/netty/util/TimerTask.html" title="interface in io.netty.util"><code>TimerTask</code></a>s behind the schedule and executethem.<p>You can increase or decrease the accuracy of the execution timing byspecifying smaller or larger tick duration in the constructor. In mostnetwork applications, I/O timeout does not need to be accurate. Therefore,the default tick duration is 100 milliseconds and you will not need to trydifferent configurations in most cases.</p><h3>Ticks per Wheel (Wheel Size)</h3><a href="../../../io/netty/util/HashedWheelTimer.html" title="class in io.netty.util"><code>HashedWheelTimer</code></a> maintains a data structure called 'wheel'.To put simply, a wheel is a hash table of <a href="../../../io/netty/util/TimerTask.html" title="interface in io.netty.util"><code>TimerTask</code></a>s whose hashfunction is 'dead line of the task'. The default number of ticks per wheel(i.e. the size of the wheel) is 512. You could specify a larger valueif you are going to schedule a lot of timeouts.<h3>Do not create many instances.</h3><a href="../../../io/netty/util/HashedWheelTimer.html" title="class in io.netty.util"><code>HashedWheelTimer</code></a> creates a new thread whenever it is instantiated andstarted. Therefore, you should make sure to create only one instance andshare it across your application. One of the common mistakes, that makesyour application unresponsive, is to create a new instance for every connection.<h3>Implementation Details</h3><a href="../../../io/netty/util/HashedWheelTimer.html" title="class in io.netty.util"><code>HashedWheelTimer</code></a> is based on<a href="https://cseweb.ucsd.edu/users/varghese/">George Varghese</a> andTony Lauck's paper,<a href="https://cseweb.ucsd.edu/users/varghese/PAPERS/twheel.ps.Z">'Hashedand Hierarchical Timing Wheels: data structures to efficiently implement atimer facility'</a>. More comprehensive slides are located<a href="http://www.cse.wustl.edu/~cdgill/courses/cs6874/TimingWheels.ppt">here</a>.</div><p>我们可以看出，HashedWheelTimer 是一个为 I&#x2F;O 超时而定制的任务调度系统。</p><h2 id="源码详细分析（略长）"><a href="#源码详细分析（略长）" class="headerlink" title="源码详细分析（略长）"></a>源码详细分析（略长）</h2><p>示例中将一个任务放入 wheelTimer 中，下面代码会在 1 秒钟后，打印出 1s delay：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">wheelTimer.newTimeout(timeout -&gt; System.out.println(<span class="hljs-string">&quot;1s delay&quot;</span>), <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure><p>其方法签名是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Timeout <span class="hljs-title function_">newTimeout</span><span class="hljs-params">(TimerTask task, <span class="hljs-type">long</span> delay, TimeUnit unit)</span><br></code></pre></td></tr></table></figure><p>这里面涉及到了两个类：Timeout 和 TimerTask。</p><p>其中 Timeout 的接口定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A handle associated with a &#123;<span class="hljs-doctag">@link</span> TimerTask&#125; that is returned by a</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> Timer&#125;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Timeout</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns the &#123;<span class="hljs-doctag">@link</span> Timer&#125; that created this handle.</span><br><span class="hljs-comment">     */</span><br>    Timer <span class="hljs-title function_">timer</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns the &#123;<span class="hljs-doctag">@link</span> TimerTask&#125; which is associated with this handle.</span><br><span class="hljs-comment">     */</span><br>    TimerTask <span class="hljs-title function_">task</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns &#123;<span class="hljs-doctag">@code</span> true&#125; if and only if the &#123;<span class="hljs-doctag">@link</span> TimerTask&#125; associated</span><br><span class="hljs-comment">     * with this handle has been expired.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isExpired</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns &#123;<span class="hljs-doctag">@code</span> true&#125; if and only if the &#123;<span class="hljs-doctag">@link</span> TimerTask&#125; associated</span><br><span class="hljs-comment">     * with this handle has been cancelled.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Attempts to cancel the &#123;<span class="hljs-doctag">@link</span> TimerTask&#125; associated with this handle.</span><br><span class="hljs-comment">     * If the task has been executed or cancelled already, it will return with</span><br><span class="hljs-comment">     * no side effect.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> True if the cancellation completed successfully, otherwise false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>TimerTask 的接口定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A task which is executed after the delay specified with</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> Timer#newTimeout(TimerTask, long, TimeUnit)&#125;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TimerTask</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Executed after the delay specified with</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> Timer#newTimeout(TimerTask, long, TimeUnit)&#125;.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeout a handle which is associated with this task</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(Timeout timeout)</span> <span class="hljs-keyword">throws</span> Exception;<br>&#125;<br></code></pre></td></tr></table></figure><p>还涉及到了一个 Timer 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Schedules &#123;<span class="hljs-doctag">@link</span> TimerTask&#125;s for one-time future execution in a background</span><br><span class="hljs-comment"> * thread.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Timer</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Schedules the specified &#123;<span class="hljs-doctag">@link</span> TimerTask&#125; for one-time execution after</span><br><span class="hljs-comment">     * the specified delay.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> a handle which is associated with the specified task</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IllegalStateException       if this timer has been &#123;<span class="hljs-doctag">@linkplain</span> #stop() stopped&#125; already</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> RejectedExecutionException if the pending timeouts are too many and creating new timeout</span><br><span class="hljs-comment">     *                                    can cause instability in the system.</span><br><span class="hljs-comment">     */</span><br>    Timeout <span class="hljs-title function_">newTimeout</span><span class="hljs-params">(TimerTask task, <span class="hljs-type">long</span> delay, TimeUnit unit)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Releases all resources acquired by this &#123;<span class="hljs-doctag">@link</span> Timer&#125; and cancels all</span><br><span class="hljs-comment">     * tasks which were scheduled but not executed yet.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the handles associated with the tasks which were canceled by</span><br><span class="hljs-comment">     *         this method</span><br><span class="hljs-comment">     */</span><br>    Set&lt;Timeout&gt; <span class="hljs-title function_">stop</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Timer, TimerTask, Timeout 三者的关系为：</p><ul><li>Timer：管理 TimerTask，HashedWheelTimer 也是实现了 Timer 接口</li><li>TimerTask：通过上述的 Timer.newTimeout(TimerTask, long, TimeUnit) 加入，在指定时间后执行的 Task</li><li>Timeout：持有上层的 Timer 实例，和下层的 TimerTask 实例，然后取消任务的操作也在这里面。</li></ul><p>类中的 field 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ResourceLeakTracker&lt;HashedWheelTimer&gt; leak;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Worker</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Thread workerThread;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">WORKER_STATE_INIT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">WORKER_STATE_STARTED</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">WORKER_STATE_SHUTDOWN</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-meta">@SuppressWarnings(&#123; &quot;unused&quot;, &quot;FieldMayBeFinal&quot; &#125;)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> workerState; <span class="hljs-comment">// 0 - init, 1 - started, 2 - shut down</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> tickDuration;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashedWheelBucket[] wheel;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> mask;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">startTimeInitialized</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Queue&lt;HashedWheelTimeout&gt; timeouts = PlatformDependent.newMpscQueue();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Queue&lt;HashedWheelTimeout&gt; cancelledTimeouts = PlatformDependent.newMpscQueue();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">pendingTimeouts</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> maxPendingTimeouts;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> startTime;<br></code></pre></td></tr></table></figure><p>其中比较重要的有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Worker</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>();<br></code></pre></td></tr></table></figure><p>这个 Worker 是 HashedWheelTimer 的内部类，里面有核心的 run 逻辑，后面会详细分析。</p><p>worker 有 3 种状态 init, started, shutdown。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">WORKER_STATE_INIT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">WORKER_STATE_STARTED</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">WORKER_STATE_SHUTDOWN</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>核心是一个 HashedWheelBucket 类型的数组，里面保存了所有的定时任务。wheel 类似于 Java 里面的 HashMap，其中 HashedWheelBucket 每个桶都维护了一个未完成任务的链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashedWheelBucket[] wheel;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashedWheelBucket</span> &#123;<br>    <span class="hljs-comment">// Used for the linked-list datastructure</span><br>    <span class="hljs-keyword">private</span> HashedWheelTimeout head;<br>    <span class="hljs-keyword">private</span> HashedWheelTimeout tail;<br></code></pre></td></tr></table></figure><p>其中 HashedWheelTimeout 就是上面 Timeout 接口的实现。</p><p>下面我们再从调用 io.netty.util.HashedWheelTimer#newTimeout 开始分析，整体代码再贴一遍，方便查看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Timeout <span class="hljs-title function_">newTimeout</span><span class="hljs-params">(TimerTask task, <span class="hljs-type">long</span> delay, TimeUnit unit)</span> &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;task&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (unit == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;unit&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">pendingTimeoutsCount</span> <span class="hljs-operator">=</span> pendingTimeouts.incrementAndGet();<br><br>    <span class="hljs-keyword">if</span> (maxPendingTimeouts &gt; <span class="hljs-number">0</span> &amp;&amp; pendingTimeoutsCount &gt; maxPendingTimeouts) &#123;<br>        pendingTimeouts.decrementAndGet();<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionException</span>(<span class="hljs-string">&quot;Number of pending timeouts (&quot;</span><br>            + pendingTimeoutsCount + <span class="hljs-string">&quot;) is greater than or equal to maximum allowed pending &quot;</span><br>            + <span class="hljs-string">&quot;timeouts (&quot;</span> + maxPendingTimeouts + <span class="hljs-string">&quot;)&quot;</span>);<br>    &#125;<br><br>    start();<br><br>    <span class="hljs-comment">// Add the timeout to the timeout queue which will be processed on the next tick.</span><br>    <span class="hljs-comment">// During processing all the queued HashedWheelTimeouts will be added to the correct HashedWheelBucket.</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + unit.toNanos(delay) - startTime;<br><br>    <span class="hljs-comment">// Guard against overflow.</span><br>    <span class="hljs-keyword">if</span> (delay &gt; <span class="hljs-number">0</span> &amp;&amp; deadline &lt; <span class="hljs-number">0</span>) &#123;<br>        deadline = Long.MAX_VALUE;<br>    &#125;<br>    <span class="hljs-type">HashedWheelTimeout</span> <span class="hljs-variable">timeout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashedWheelTimeout</span>(<span class="hljs-built_in">this</span>, task, deadline);<br>    timeouts.add(timeout);<br>    <span class="hljs-keyword">return</span> timeout;<br>&#125;<br></code></pre></td></tr></table></figure><p>前面是 task 和 unit 参数判空，分析时可以忽略。接下来是 pendingTimeouts 记录新插入的任务数量，每插入一个任务会原子加一，每个任务完成会原子减一。在插入的时候如果大于 maxPendingTimeouts，会拒绝插入（maxPendingTimeouts 默认是-1，不会进行任务数量的校验）。</p><p>接下来，就是 start() 方法，核心在于可能同时并发多个任务加入到 HashedWheelTimer 中，而此时 HashedWheelTimer 的任务还未启动，要确保只启动一次，当然加锁也可以，不过 HashedWheelTimer 的实现效率更高一些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">switch</span> (WORKER_STATE_UPDATER.get(<span class="hljs-built_in">this</span>)) &#123;<br>        <span class="hljs-keyword">case</span> WORKER_STATE_INIT:<br>            <span class="hljs-keyword">if</span> (WORKER_STATE_UPDATER.compareAndSet(<span class="hljs-built_in">this</span>, WORKER_STATE_INIT, WORKER_STATE_STARTED)) &#123;<br>                workerThread.start();<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> WORKER_STATE_STARTED:<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> WORKER_STATE_SHUTDOWN:<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;cannot be started once stopped&quot;</span>);<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Invalid WorkerState&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Wait until the startTime is initialized by the worker.</span><br>    <span class="hljs-keyword">while</span> (startTime == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            startTimeInitialized.await();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignore) &#123;<br>            <span class="hljs-comment">// Ignore - it will be ready very soon.</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来是计算任务的截止时间 deadline，其实很好理解，截止时间 deadline&#x3D;当前时间+任务要延迟的时间-HashedWheelTimer 的启动时间。deadline 是相对于 startTime 的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + unit.toNanos(delay) - startTime;<br></code></pre></td></tr></table></figure><p>最终根据计算出来的 deadline，新建一个 HashedWheelTimeout 对象，并将对象加入到 timeout 队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HashedWheelTimeout</span> <span class="hljs-variable">timeout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashedWheelTimeout</span>(<span class="hljs-built_in">this</span>, task, deadline);<br>timeouts.add(timeout);<br></code></pre></td></tr></table></figure><p>此时 timeout 仅仅是加入到了 Queue<HashedWheelTimeout> timeouts 这个队列中，还没有进入到 HashedWheelBucket[] wheel 里面，下面重点分析一下 io.netty.util.HashedWheelTimer.Worker 内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Initialize the startTime.</span><br>    startTime = System.nanoTime();<br>    <span class="hljs-keyword">if</span> (startTime == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// We use 0 as an indicator for the uninitialized value here, so make sure it&#x27;s not 0 when initialized.</span><br>        startTime = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Notify the other threads waiting for the initialization at start().</span><br>    startTimeInitialized.countDown();<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> waitForNextTick();<br>        <span class="hljs-keyword">if</span> (deadline &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (tick &amp; mask);<br>            processCancelledTasks();<br>            <span class="hljs-type">HashedWheelBucket</span> <span class="hljs-variable">bucket</span> <span class="hljs-operator">=</span><br>                    wheel[idx];<br>            transferTimeoutsToBuckets();<br>            bucket.expireTimeouts(deadline);<br>            tick++;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (WORKER_STATE_UPDATER.get(HashedWheelTimer.<span class="hljs-built_in">this</span>) == WORKER_STATE_STARTED);<br><br>    <span class="hljs-comment">// Fill the unprocessedTimeouts so we can return them from stop() method.</span><br>    <span class="hljs-keyword">for</span> (HashedWheelBucket bucket: wheel) &#123;<br>        bucket.clearTimeouts(unprocessedTimeouts);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">HashedWheelTimeout</span> <span class="hljs-variable">timeout</span> <span class="hljs-operator">=</span> timeouts.poll();<br>        <span class="hljs-keyword">if</span> (timeout == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!timeout.isCancelled()) &#123;<br>            unprocessedTimeouts.add(timeout);<br>        &#125;<br>    &#125;<br>    processCancelledTasks();<br>&#125;<br></code></pre></td></tr></table></figure><p>正常运行时程序一直都处在 while 循环中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> waitForNextTick();<br>    <span class="hljs-keyword">if</span> (deadline &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (tick &amp; mask);<br>        processCancelledTasks();<br>        <span class="hljs-type">HashedWheelBucket</span> <span class="hljs-variable">bucket</span> <span class="hljs-operator">=</span><br>                wheel[idx];<br>        transferTimeoutsToBuckets();<br>        bucket.expireTimeouts(deadline);<br>        tick++;<br>    &#125;<br>&#125; <span class="hljs-keyword">while</span> (WORKER_STATE_UPDATER.get(HashedWheelTimer.<span class="hljs-built_in">this</span>) == WORKER_STATE_STARTED);<br></code></pre></td></tr></table></figure><p>其中 waitForNextTick() 方法是阻塞等到下个滴答的时间（默认时间是 100ms），判断应该使用 HashedWheelBucket[] wheel 中的哪个桶，取出这个桶中的任务并执行。expireTimeouts 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">expireTimeouts</span><span class="hljs-params">(<span class="hljs-type">long</span> deadline)</span> &#123;<br>    <span class="hljs-type">HashedWheelTimeout</span> <span class="hljs-variable">timeout</span> <span class="hljs-operator">=</span> head;<br><br>    <span class="hljs-comment">// process all timeouts</span><br>    <span class="hljs-keyword">while</span> (timeout != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">HashedWheelTimeout</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> timeout.next;<br>        <span class="hljs-keyword">if</span> (timeout.remainingRounds &lt;= <span class="hljs-number">0</span>) &#123;<br>            next = remove(timeout);<br>            <span class="hljs-keyword">if</span> (timeout.deadline &lt;= deadline) &#123;<br>                timeout.expire();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// The timeout was placed into a wrong slot. This should never happen.</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(String.format(<br>                        <span class="hljs-string">&quot;timeout.deadline (%d) &gt; deadline (%d)&quot;</span>, timeout.deadline, deadline));<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timeout.isCancelled()) &#123;<br>            next = remove(timeout);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            timeout.remainingRounds --;<br>        &#125;<br>        timeout = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其核心逻辑就是获取桶的链表 head，依次判断该桶中所有任务是否有到期该执行的，有的话拿出来执行，并且在链表中删除该任务。核心 timeout.expire() 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">expire</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (!compareAndSetState(ST_INIT, ST_EXPIRED)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        task.run(<span class="hljs-built_in">this</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-keyword">if</span> (logger.isWarnEnabled()) &#123;<br>            logger.warn(<span class="hljs-string">&quot;An exception was thrown by &quot;</span> + TimerTask.class.getSimpleName() + <span class="hljs-string">&#x27;.&#x27;</span>, t);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>里面核心就是执行了 run 方法，执行核心的任务逻辑。</p><p>io.netty.util.HashedWheelTimer.Worker#run 的 while 循环里还有一个 transferTimeoutsToBuckets 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transferTimeoutsToBuckets</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// transfer only max. 100000 timeouts per tick to prevent a thread to stale the workerThread when it just</span><br>    <span class="hljs-comment">// adds new timeouts in a loop.</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>        <span class="hljs-type">HashedWheelTimeout</span> <span class="hljs-variable">timeout</span> <span class="hljs-operator">=</span> timeouts.poll();<br>        <span class="hljs-keyword">if</span> (timeout == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// all processed</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (timeout.state() == HashedWheelTimeout.ST_CANCELLED) &#123;<br>            <span class="hljs-comment">// Was cancelled in the meantime.</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">calculated</span> <span class="hljs-operator">=</span> timeout.deadline / tickDuration;<br>        timeout.remainingRounds = (calculated - tick) / wheel.length;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ticks</span> <span class="hljs-operator">=</span> Math.max(calculated, tick); <span class="hljs-comment">// Ensure we don&#x27;t schedule for past.</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">stopIndex</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (ticks &amp; mask);<br><br>        <span class="hljs-type">HashedWheelBucket</span> <span class="hljs-variable">bucket</span> <span class="hljs-operator">=</span> wheel[stopIndex];<br>        bucket.addTimeout(timeout);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了保证每次 tick 不会阻塞 run 方法，每次转移的任务不超过 10w 个。这个方法所做的就是将 Queue<HashedWheelTimeout> timeouts 中的任务分配到对应的桶中，加入的逻辑就是放入对应桶链表的尾端。</p><p>至此代码已经分析完了，如下图所示（图片摘自：<a href="https://www.javadoop.com/post/HashedWheelTimer">图片链接</a>）：</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210302165947.png" alt="20210302165947"></p><ul><li>HashedWheelTimer 模拟了时间的流转，默认新建了一个长度为 512 的桶，每隔 tick 单位时间，指针向前移动。</li><li>HashedWheelTimer 新加入的任务，会放入 Queue<HashedWheelTimeout> timeouts 队列中。</li><li>HashedWheelTimer 内部使用一个线程，每隔 tick 单位时间处理一些逻辑，包括：<ul><li>处理指针当前指向桶的任务队列，如果任务到到延迟时间，就执行任务并在对应桶中删除。</li><li>将 timeouts 队列的任务放入对应的桶中，每次最多处理 10w 个。</li></ul></li></ul><h1 id="HashedWheelTimer-的特点"><a href="#HashedWheelTimer-的特点" class="headerlink" title="HashedWheelTimer 的特点"></a>HashedWheelTimer 的特点</h1><ul><li>从源码分析可以看出，其实 HashedWheelTimer 的时间精度并不高，误差能够在 100ms 左右，同时如果任务队列中的等待任务数量过多，可能会产生更大的误差。</li><li>但是 HashedWheelTimer 能够处理非常大量的定时任务，且每次定位到要处理任务的候选集合链表只需要 O(1) 的时间，而 Timer 等则需要调整堆，是 O(logN) 的时间复杂度。</li><li>HashedWheelTimer 本质上是<code>模拟了时间的轮盘</code>，将大量的任务拆分成了一个个的小任务列表，能够有效<code>节省 CPU 和线程资源</code>。</li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://www.javadoop.com/post/HashedWheelTimer">HashedWheelTimer 使用及源码分析</a></li><li><a href="https://albenw.github.io/posts/ec8df8c/">HashedWheelTimer 时间轮原理分析</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>组件&amp;中间件知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java Features from Java 8 to Java 17</title>
    <link href="/2021/12/06/Java%20Features%20from%20Java%208%20to%20Java%2017/"/>
    <url>/2021/12/06/Java%20Features%20from%20Java%208%20to%20Java%2017/</url>
    
    <content type="html"><![CDATA[<p>文章原文链接：<a href="https://reflectoring.io/java-release-notes/#diamond-syntax-with-inner-anonymous-classes">https://reflectoring.io/java-release-notes/#diamond-syntax-with-inner-anonymous-classes</a></p><p>A lot has changed in Java from its beginnings in 1995 until today. Java 8 was a revolutionary release that put Java back on the pedestal of the best programming languages.</p><p>We will go through most of the changes in the Java language that happened from Java 8 in 2014 until today. We will try to be as brief as possible on every feature. The intention is to have <strong>a reference for all features between Java 8 and Java 17 inclusively</strong>.</p><h2 id="Code-Example"><a href="#Code-Example" class="headerlink" title="Code Example"></a>Code Example</h2><p>This article is accompanied by a working code example <a href="https://github.com/thombergs/code-examples/tree/master/core-java/versions">on GitHub</a>.</p><h2 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a>Java 8</h2><p>The main changes of the Java 8 release were these:</p><ul><li><a href="https://reflectoring.io/java-release-notes/#lambda-expressions-and-stream-api">Lambda Expression and Stream API</a></li><li><a href="https://reflectoring.io/java-release-notes/#method-reference">Method Reference</a></li><li><a href="https://reflectoring.io/java-release-notes/#default-methods">Default Methods</a></li><li><a href="https://reflectoring.io/java-release-notes/#type-annotations">Type Annotations</a></li><li><a href="https://reflectoring.io/java-release-notes/#repeating-annotations">Repeating Annotations</a></li><li><a href="https://reflectoring.io/java-release-notes/#method-parameter-reflection">Method Parameter Reflection</a></li></ul><h3 id="Lambda-Expressions-and-Stream-API"><a href="#Lambda-Expressions-and-Stream-API" class="headerlink" title="Lambda Expressions and Stream API"></a>Lambda Expressions and Stream API</h3><p>Java was always known for having a lot of boilerplate code. With the release of Java 8, this statement became a little less valid. The stream API and lambda expressions are the new features that move us closer to functional programming.</p><p>In our examples, we will see how we use lambdas and streams in the different scenarios.</p><h4 id="The-World-Before-Lambda-Expressions"><a href="#The-World-Before-Lambda-Expressions" class="headerlink" title="The World Before Lambda Expressions"></a>The World Before Lambda Expressions</h4><p>We own a car dealership business. To discard all the paperwork, we want to create a piece of software that finds all currently available cars that have run less than 50,000 km.</p><p>Let us take a look at how we would implement a function for something like this in a naive way:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaExpressions</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Car&gt; <span class="hljs-title function_">findCarsOldWay</span><span class="hljs-params">(List&lt;Car&gt; cars)</span> &#123;<br>        List&lt;Car&gt; selectedCars = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Car car : cars) &#123;<br>            <span class="hljs-keyword">if</span> (car.kilometers &lt; <span class="hljs-number">50000</span>) &#123;<br>                selectedCars.add(car);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> selectedCars;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>To implement this, we are creating a static function that accepts a <code>List</code> of cars. It should return a filtered list according to a specified condition.</p><h4 id="Using-a-Stream-and-a-Lambda-Expression"><a href="#Using-a-Stream-and-a-Lambda-Expression" class="headerlink" title="Using a Stream and a Lambda Expression"></a>Using a Stream and a Lambda Expression</h4><p>We have the same problem as in the <a href="https://reflectoring.io/java-release-notes/#the-world-before-lambda-expressions">previous example</a>.</p><p>Our client wants to find all cars with the same criteria.</p><p>Let us see a solution where we used the stream API and lambda expression:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaExpressions</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Car&gt; <span class="hljs-title function_">findCarsUsingLambda</span><span class="hljs-params">(List&lt;Car&gt; cars)</span> &#123;<br>        <span class="hljs-keyword">return</span> cars.stream().filter(car -&gt; car.kilometers &lt; <span class="hljs-number">50000</span>)<br>                .collect(Collectors.toList());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>We need to transfer the list of cars into a stream by calling the <code>stream()</code> method. Inside the <code>filter()</code> method we are setting our condition. We are evaluating every entry against the desired condition. We are keeping only those entries that have less than 50,000 kilometers. The last thing that we need to do is to wrap it up into a list.</p><p>More about lambda expressions can be found in the <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">docs</a>.</p><h3 id="Method-Reference"><a href="#Method-Reference" class="headerlink" title="Method Reference"></a>Method Reference</h3><h4 id="Without-Method-Reference"><a href="#Without-Method-Reference" class="headerlink" title="Without Method Reference"></a>Without Method Reference</h4><p>We still own a car dealership shop, and we want to print out all the cars in the shop. For that, we will use a method reference.</p><p>A method reference allows us to call functions in classes using a special kind of syntax <code>::</code>. There are four kinds of method references:</p><ul><li>Reference to a static method</li><li>Reference to an instance method on a object</li><li>Reference to an instance method on a type</li><li>Reference to a constructor</li></ul><p>Let us see how to do it using the standard method call:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodReference</span> &#123;<br>    List&lt;String&gt; withoutMethodReference =<br>            cars.stream().map(car -&gt; car.toString())<br>                    .collect(Collectors.toList());<br>&#125;<br></code></pre></td></tr></table></figure><p>We are using a lambda expression to call the <code>toString()</code> method on each car.</p><h4 id="Using-a-Method-Reference"><a href="#Using-a-Method-Reference" class="headerlink" title="Using a Method Reference"></a>Using a Method Reference</h4><p>Now, let us see how to use a method reference in the same situation:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodReference</span> &#123;<br>    List&lt;String&gt; methodReference = cars.stream().map(Car::toString)<br>            .collect(Collectors.toList());<br>&#125;<br></code></pre></td></tr></table></figure><p>We are, again, using a lambda expression, but now we call the <code>toString()</code> method by method reference. We can see how it is more concise and easier to read.</p><p>To read more about method reference please look at the <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html">docs</a>.</p><h3 id="Default-Methods"><a href="#Default-Methods" class="headerlink" title="Default Methods"></a>Default Methods</h3><p>Let us imagine that we have a simple method <code>log(String message)</code> that prints log messages on invocation. We realized that we want to provide timestamps to messages so that logs are easily searchable. We don’t want our clients to break after we introduce this change. We will do this using a default method implementation on an interface.</p><p>Default method implementation is the feature that allows us to create a fallback implementation of an interface method.</p><h4 id="Use-Case"><a href="#Use-Case" class="headerlink" title="Use Case"></a>Use Case</h4><p>Let us see how our contract looks:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultMethods</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Logging</span> &#123;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String message)</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingImplementation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Logging</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String message)</span> &#123;<br>            System.out.println(message);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>We are creating a simple interface with just one method and implementing it in <code>LoggingImplementation</code> class.</p><h4 id="Adding-New-Method"><a href="#Adding-New-Method" class="headerlink" title="Adding New Method"></a>Adding New Method</h4><p>We will add new method inside the interface. The method accepts the second argument called date that represents timestamp.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultMethods</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Logging</span> &#123;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String message)</span>;<br>        <br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String message, Date date)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>We are adding a new method but not implementing it inside all client classes. The compiler will fail with exception:</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">Class</span> <span class="hljs-string">&#x27;LoggingImplementation&#x27;</span> must either be declared <span class="hljs-keyword">abstract</span> <br><span class="hljs-keyword">or</span> implement <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">method</span> &#x27;<span class="hljs-title function_">log</span><span class="hljs-params">(String, Date)</span>&#x27; <span class="hljs-title function_">in</span> &#x27;<span class="hljs-title function_">Logging</span>&#x27;`.<br></code></pre></td></tr></table></figure><h4 id="Using-Default-Methods"><a href="#Using-Default-Methods" class="headerlink" title="Using Default Methods"></a>Using Default Methods</h4><p>After adding a new method inside the interface, our compiler threw exceptions. We are going to solve this using default method implementation for the new method.</p><p>Let us look at how to create a default method implementation:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultMethods</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Logging</span> &#123;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String message)</span>;<br><br>        <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String message, Date date)</span> &#123;<br>            System.out.println(date.toString() + <span class="hljs-string">&quot;: &quot;</span> + message);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Putting the <code>default</code> keyword allows us to add the implementation of the method inside the interface. Now, our <code>LoggingImplementation</code> class does not fail with a compiler error even though we didn’t implement this new method inside of it.</p><p>To read more about default methods please refer to the <a href="https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html">docs</a>.</p><h3 id="Type-Annotations"><a href="#Type-Annotations" class="headerlink" title="Type Annotations"></a>Type Annotations</h3><p>Type annotations are one more feature introduced in Java 8. Even though we had annotations available before, now we can use them wherever we use a type. This means that we can use them on:</p><ul><li>a local variable definition</li><li>constructor calls</li><li>type casting</li><li>generics</li><li>throw clauses and more</li></ul><p>Tools like IDEs can then read these annotations and show warnings or errors based on the annotations.</p><h4 id="Local-Variable-Definition"><a href="#Local-Variable-Definition" class="headerlink" title="Local Variable Definition"></a>Local Variable Definition</h4><p>Let us see how to ensure that our local variable doesn’t end up as a <code>null</code> value:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeAnnotations</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-meta">@NotNull</span> <span class="hljs-type">String</span> <span class="hljs-variable">userName</span> <span class="hljs-operator">=</span> args[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>We are using annotation on the local variable definition here. A compile-time annotation processor could now read the <code>@NotNull</code> annotation and throw an error when the string is null.</p><h4 id="Constructor-Call"><a href="#Constructor-Call" class="headerlink" title="Constructor Call"></a>Constructor Call</h4><p>We want to make sure that we cannot create an empty <code>ArrayList</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeAnnotations</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; request =<br>                <span class="hljs-keyword">new</span> <span class="hljs-meta">@NotEmpty</span> ArrayList&lt;&gt;(Arrays.stream(args).collect(<br>                        Collectors.toList()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>This is the perfect example of how to use type annotations on a constructor. Again, an annotation processor can evaluate the annotation and check if the array list is not empty.</p><h4 id="Generic-Type"><a href="#Generic-Type" class="headerlink" title="Generic Type"></a>Generic Type</h4><p>One of our requirements is that each email has to be in a format <code>&lt;name&gt;@&lt;company&gt;.com</code>. If we use type annotations, we can do it easily:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeAnnotations</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;<span class="hljs-meta">@Email</span> String&gt; emails;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>This is a definition of a list of email addresses. We use <code>@Email</code> annotation that ensures that every record inside this list is in the desired format.</p><p>A tool could use reflection to evaluate the annotation and check that each of the elements in the list is a valid email address.</p><p>For more information about type annotations please refer to the <a href="https://docs.oracle.com/javase/tutorial/java/annotations/type_annotations.html">docs</a>.</p><h3 id="Repeating-Annotations"><a href="#Repeating-Annotations" class="headerlink" title="Repeating Annotations"></a>Repeating Annotations</h3><p>Let us imagine we have an application with fully implemented security. It has different levels of authorization. Even though we implemented everything carefully, we want to make sure that we log every unauthorized action. On each unauthorized action, we are sending an email to the owner of the company and our security admin group email. Repeating annotations are our way to go on this example.</p><p>Repeating annotations allows us to place multiple annotations on the same class.</p><h4 id="Creating-a-Repeating-Annotation"><a href="#Creating-a-Repeating-Annotation" class="headerlink" title="Creating a Repeating Annotation"></a>Creating a Repeating Annotation</h4><p>For the <a href="https://reflectoring.io/java-release-notes/#repeating-annotations">example</a>, we are going to create a repeating annotation called <code>@Notify</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RepeatingAnnotations</span> &#123;<br>    <br>    <span class="hljs-meta">@Repeatable(Notifications.class)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Notify &#123;<br>        String <span class="hljs-title function_">email</span><span class="hljs-params">()</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Notifications &#123;<br>        Notify[] value();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>We create <code>@Notify</code> as a regular annotation, but we add the <code>@Repeatable</code> (meta-)annotation to it. Additionally, we have to create a “container” annotation <code>Notifications</code> that contains an array of <code>Notify</code> objects. An annotation processor can now get access to all repeating <code>Notify</code> annotations through the container annotation <code>Noifications</code>.</p><p>Please note that this is a mock annotation just for demonstration purposes. This annotation will not send emails without an annotation processor that reads it and then sends emails.</p><h4 id="Using-Repeating-Annotations"><a href="#Using-Repeating-Annotations" class="headerlink" title="Using Repeating Annotations"></a>Using Repeating Annotations</h4><p>We can add a repating annotation multiple times to the same construct:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Notify(email = &quot;admin@company.com&quot;)</span><br><span class="hljs-meta">@Notify(email = &quot;owner@company.com&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserNotAllowedForThisActionException</span><br>        <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> &#123;<br>    <span class="hljs-keyword">final</span> String user;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserNotAllowedForThisActionException</span><span class="hljs-params">(String user)</span> &#123;<br>        <span class="hljs-built_in">this</span>.user = user;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>We have our custom exception class that we will throw whenever a user tries to do something that the user is not allowed. Our annotations to this class say that we want to notify two emails when code throws this exception.</p><p>To read more about repeating annotations please refer to the <a href="https://docs.oracle.com/javase/tutorial/java/annotations/repeating.html">docs</a>.</p><h2 id="Java-9"><a href="#Java-9" class="headerlink" title="Java 9"></a>Java 9</h2><p>Java 9 introduced these main features:</p><ul><li><a href="https://reflectoring.io/java-release-notes/#java-module-system">Java Module System</a></li><li><a href="https://reflectoring.io/java-release-notes/#try-with-resources">Try-with-resources</a></li><li><a href="https://reflectoring.io/java-release-notes/#diamond-syntax-with-inner-anonymous-classes">Diamond Syntax with Inner Anonymous Classes</a></li><li><a href="https://reflectoring.io/java-release-notes/#private-interface-methods">Private Interface Methods</a></li></ul><h3 id="Java-Module-System"><a href="#Java-Module-System" class="headerlink" title="Java Module System"></a>Java Module System</h3><p>A module is a group of packages, their dependencies, and resources. It provides a broader set of functionalities than packages.</p><p>When creating the new module, we need to provide several attributes:</p><ul><li>Name</li><li>Dependencies</li><li>Public Packages - by default, all packages are module private</li><li>Services Offered</li><li>Services Consumed</li><li>Reflection Permissions</li></ul><p>Without going into many details, let us create our first module. Inside our example, we will show several options and keywords that one can use when creating a module.</p><h4 id="Creating-Modules-Inside-IntelliJ"><a href="#Creating-Modules-Inside-IntelliJ" class="headerlink" title="Creating Modules Inside IntelliJ"></a>Creating Modules Inside IntelliJ</h4><p>First, we will go with a simple example. We will build a Hello World application where we print “Hello” from one module, and we call the second module to print “World!”.</p><p>Since I am working in the IntelliJ IDEA there is something that we need to understand first. IntelliJ IDEA has the concept of modules. For it to work, each Java module has to correspond to one IntelliJ module.</p><p><img src="/../assets/img/posts/java-release-notes/package-structure.png" alt="Package structure!" title="Package structure"></p><p>We have two modules: <code>hello.module</code> and <code>world.module</code>. They correspond to <code>hello</code> and <code>world</code> IntelliJ modules, respectively. Inside each of them, we have created the <code>module-info.java</code> file. This file defines our Java module. Inside, we declare which packages we need to export and on which modules we are dependent.</p><h4 id="Defining-our-First-Module"><a href="#Defining-our-First-Module" class="headerlink" title="Defining our First Module"></a>Defining our First Module</h4><p>We are using the <code>hello</code> module to print the word: “Hello”. Inside, we call the method inside the <code>world</code> module, which will print “World !”. The first thing that we need to do is to declare export of the package containing our <code>World.class</code> inside <code>module-info.java</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span> world.<span class="hljs-keyword">module</span> &#123;<br>    <span class="hljs-keyword">exports</span> com.reflectoring.io.app.world;<br>&#125;<br></code></pre></td></tr></table></figure><p>We use the keyword <code>module</code> with the module name to reference the module.</p><p>The next keyword that we use is <code>exports</code>. It tells the module system that we are making our <code>com.reflectoring.io.app.world</code> package visible outside of our module.</p><p>There are several other keywords can be used:</p><ul><li>requires</li><li>requires transitive</li><li>exports to</li><li>uses</li><li>provides with</li><li>open</li><li>opens</li><li>opens to</li></ul><p>Out of these we will show only <code>requires</code> declaration. Others can be found in the <a href="https://www.oracle.com/corporate/features/understanding-java-9-modules.html">docs</a>.</p><h4 id="Defining-our-Second-Module"><a href="#Defining-our-Second-Module" class="headerlink" title="Defining our Second Module"></a>Defining our Second Module</h4><p>After we created and exported the <code>world</code> module, we can proceed with creating the <code>hello</code> module:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span> hello.<span class="hljs-keyword">module</span> &#123;<br>    <span class="hljs-keyword">requires</span> world.<span class="hljs-keyword">module</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>We define dependencies using <code>requires</code> keyword. We are referencing our newly created, <code>hello.module</code>. Packages that are not exported are, by default, module private and cannot be seen from outside of the module.</p><p>To read more about the Java module system please refer to <a href="https://openjdk.java.net/jeps/261">the docs</a></p><h3 id="Try-with-resources"><a href="#Try-with-resources" class="headerlink" title="Try-with-resources"></a>Try-with-resources</h3><p>Try-with-resources is a feature that enables us to declare new autoclosable resources on a <code>try-catch</code> block. Declaring them inside a <code>try-catch</code> block tells the JVM to release them after the code has run. The only condition is that the declared resource implements an <code>Autoclosable</code> interface.</p><h4 id="Closing-a-Resource-Manually"><a href="#Closing-a-Resource-Manually" class="headerlink" title="Closing a Resource Manually"></a>Closing a Resource Manually</h4><p>We want to read text using <code>BufferedReader</code>. <code>BufferedReader</code> is a closable resource, so we need to make sure that it is properly closed after use. Before Java 8 we would do it like this:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TryWithResources</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringReader</span>(<span class="hljs-string">&quot;Hello world example!&quot;</span>));<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(br.readLine());<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                br.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>In <code>finally</code> block, we would call <code>close()</code>. The <code>finally</code> block ensures that the reader is always properly closed.</p><h4 id="Closing-a-Resource-with-try-with-resources"><a href="#Closing-a-Resource-with-try-with-resources" class="headerlink" title="Closing a Resource with try-with-resources"></a>Closing a Resource with <code>try-with-resources</code></h4><p>Java 8 introduced the try-with-resource feature that enables us to declare our resource inside <code>try</code> definition. This will ensure that our closable is closed without using <code>finally</code>. Let us take a look at some example of using the <code>BufferedReader</code> to read string:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TryWithResources</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringReader</span>(<span class="hljs-string">&quot;Hello world example3!&quot;</span>));<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> br3) &#123;<br>            System.out.println(reader.readLine());<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Error happened!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Inside the <code>try</code> definition, we are assigning our previously created reader to the new variable. Now we know that our reader will get closed every time.</p><p>To read more about the try-with-resources feature please refer to the <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html">docs</a>.</p><h3 id="Diamond-Syntax-with-Inner-Anonymous-Classes"><a href="#Diamond-Syntax-with-Inner-Anonymous-Classes" class="headerlink" title="Diamond Syntax with Inner Anonymous Classes"></a>Diamond Syntax with Inner Anonymous Classes</h3><p>Before Java 9 we couldn’t use a diamond operator inside the inner anonymous class.</p><p>For our example, we will create the abstract class, <code>StringAppender</code>. The class has only one method that appends two strings with <code>-</code> between them. We will use the anonymous class for providing the implementation for the <code>append()</code> method:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiamondOperator</span> &#123;<br><br>    StringAppender&lt;String&gt; appending = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringAppender</span>&lt;&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">append</span><span class="hljs-params">(String a, String b)</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(a).append(<span class="hljs-string">&quot;-&quot;</span>).append(b).toString();<br>        &#125;<br>    &#125;;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringAppender</span>&lt;T&gt; &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> T <span class="hljs-title function_">append</span><span class="hljs-params">(String a, String b)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>We use the diamond operator to omit type on the constructor call <code>new StringAppender&lt;&gt;()</code>. Since we are using Java 8, in this example we will get a compiler error:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">java: cannot <span class="hljs-keyword">infer</span> <span class="hljs-built_in">type</span> arguments <span class="hljs-keyword">for</span> <br>com.reflectoring.io.java9.DiamondOperator.StringAppender&lt;T&gt;<br><br>reason: <span class="hljs-string">&#x27;&lt;&gt;&#x27;</span> <span class="hljs-keyword">with</span> anonymous <span class="hljs-keyword">inner</span> classes <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> supported <span class="hljs-keyword">in</span> -source <span class="hljs-number">8</span><br>    (<span class="hljs-keyword">use</span> -source <span class="hljs-number">9</span> <span class="hljs-keyword">or</span> higher <span class="hljs-keyword">to</span> enable <span class="hljs-string">&#x27;&lt;&gt;&#x27;</span> <span class="hljs-keyword">with</span> anonymous <span class="hljs-keyword">inner</span> classes)<br></code></pre></td></tr></table></figure><p>In Java 9, this compiler error is no longer happening.</p><h3 id="Private-Interface-Methods"><a href="#Private-Interface-Methods" class="headerlink" title="Private Interface Methods"></a>Private Interface Methods</h3><p>We already mentioned how we use <a href="https://reflectoring.io/java-release-notes/#default-methods">default methods</a> in interfaces.</p><p>How do we split the implementation into several methods? When working with classes, we can achieve it using private methods. Could that be the solution in our case?</p><p>As of Java 9, yes. We can create private methods inside our interfaces.</p><h4 id="Usage-of-Private-Interface-Methods"><a href="#Usage-of-Private-Interface-Methods" class="headerlink" title="Usage of Private Interface Methods"></a>Usage of Private Interface Methods</h4><p>For our example, we want to print out a set of names.</p><p>Interface containing this functionality had default method defined. We decided that we should if the client doesn’t provide the implementation, provide a set of predefined names that we read from the resource folder:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrivateInterfaceMethods</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TestingNames</span> <span class="hljs-variable">names</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestingNames</span>();<br>        System.out.println(names.fetchInitialData());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestingNames</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NamesInterface</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestingNames</span><span class="hljs-params">()</span> &#123;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">NamesInterface</span> &#123;<br>        <span class="hljs-keyword">default</span> List&lt;String&gt; <span class="hljs-title function_">fetchInitialData</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-built_in">this</span>.getClass()<br>                            .getResourceAsStream(<span class="hljs-string">&quot;/names.txt&quot;</span>)))) &#123;<br>                <span class="hljs-keyword">return</span> readNames(br);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> List&lt;String&gt; <span class="hljs-title function_">readNames</span><span class="hljs-params">(BufferedReader br)</span><br>                <span class="hljs-keyword">throws</span> IOException &#123;<br>            ArrayList&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            String name;<br>            <span class="hljs-keyword">while</span> ((name = br.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                names.add(name);<br>            &#125;<br>            <span class="hljs-keyword">return</span> names;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>We are using <code>BufferedReader</code> to read the file containing default names that we share with the client. To encapsulate our code and, possibly, make it reusable in other methods, we decided to move code for reading and saving names into a <code>List</code> to the separate method. This method is private and, now, we can use it anywhere inside our interface.</p><p>As mentioned, the main benefit of this feature inside Java 9 is better encapsulation and reusability of the code.</p><h2 id="Java-10"><a href="#Java-10" class="headerlink" title="Java 10"></a>Java 10</h2><h3 id="Local-Variable-Type-Inference"><a href="#Local-Variable-Type-Inference" class="headerlink" title="Local Variable Type Inference"></a>Local Variable Type Inference</h3><p>Java always needed explicit types on local variables.</p><p>When writing and reading code, we always know which type we expect. On the other hand, a lot of the code is just types with no usability.</p><p>The <code>var</code> type allows us to omit type from the left-hand side of our statements.</p><h4 id="Old-Way"><a href="#Old-Way" class="headerlink" title="Old Way"></a>Old Way</h4><p>Let us look into the example here. We want to create small a set of people, put everything in one list and then go through that list in the for loop to print out their name and last name:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalTypeVar</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">explicitTypes</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">Roland</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Roland&quot;</span>, <span class="hljs-string">&quot;Deschain&quot;</span>);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">Susan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Susan&quot;</span>, <span class="hljs-string">&quot;Delgado&quot;</span>);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">Eddie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Eddie&quot;</span>, <span class="hljs-string">&quot;Dean&quot;</span>);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">Detta</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Detta&quot;</span>, <span class="hljs-string">&quot;Walker&quot;</span>);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">Jake</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Jake&quot;</span>, <span class="hljs-string">&quot;Chambers&quot;</span>);<br><br>        List&lt;Person&gt; persons =<br>                List.of(Roland, Susan, Eddie, Detta, Jake);<br><br>        <span class="hljs-keyword">for</span> (Person person : persons) &#123;<br>            System.out.println(person.name + <span class="hljs-string">&quot; - &quot;</span> + person.lastname);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>This is the type of code that we can see in most cases in Java. We use explicit types to make sure that we know what the method expects.</p><h4 id="Implicit-Typing-with-var"><a href="#Implicit-Typing-with-var" class="headerlink" title="Implicit Typing with var"></a>Implicit Typing with <code>var</code></h4><p>Now, we will look into the same example, but using the <code>var</code> keyword that Java 10 introduced. We still want to create several person objects and put them in a list. After that, we will go through that list and print out the name of each person:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalTypeVar</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">varTypes</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">Roland</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Roland&quot;</span>, <span class="hljs-string">&quot;Deschain&quot;</span>);<br>        <span class="hljs-type">var</span> <span class="hljs-variable">Susan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Susan&quot;</span>, <span class="hljs-string">&quot;Delgado&quot;</span>);<br>        <span class="hljs-type">var</span> <span class="hljs-variable">Eddie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Eddie&quot;</span>, <span class="hljs-string">&quot;Dean&quot;</span>);<br>        <span class="hljs-type">var</span> <span class="hljs-variable">Detta</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Detta&quot;</span>, <span class="hljs-string">&quot;Walker&quot;</span>);<br>        <span class="hljs-type">var</span> <span class="hljs-variable">Jake</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Jake&quot;</span>, <span class="hljs-string">&quot;Chambers&quot;</span>);<br><br>        <span class="hljs-type">var</span> <span class="hljs-variable">persons</span> <span class="hljs-operator">=</span> List.of(Roland, Susan, Eddie, Detta, Jake);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> person : persons) &#123;<br>            System.out.println(person.name + <span class="hljs-string">&quot; - &quot;</span> + person.lastname);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>We can see some of the most typical examples of using <code>var</code> type on local variables. First, we use them for defining local variables. It can be a standalone object or even a list with the diamond operator.</p><p>For more details about local type inference please visit <a href="https://docs.oracle.com/en/java/javase/17/language/local-variable-type-inference.html">the docs</a>.</p><h2 id="Java-11"><a href="#Java-11" class="headerlink" title="Java 11"></a>Java 11</h2><h3 id="Local-Variable-Type-in-Lambda-Expressions"><a href="#Local-Variable-Type-in-Lambda-Expressions" class="headerlink" title="Local Variable Type in Lambda Expressions"></a>Local Variable Type in Lambda Expressions</h3><p>Java 11 introduced an improvement to the previously mentioned <a href="https://reflectoring.io/java-release-notes/#local-variable-type-inference">local type inference</a>. This allows us to use <code>var</code> inside lambda expressions.</p><p>We will, again, create several persons, collect them into the list and filter out entries that don’t have an ‘a’ inside their name:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalTypeVarLambda</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">explicitTypes</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">Roland</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Roland&quot;</span>, <span class="hljs-string">&quot;Deschain&quot;</span>);<br>        <span class="hljs-type">var</span> <span class="hljs-variable">Susan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Susan&quot;</span>, <span class="hljs-string">&quot;Delgado&quot;</span>);<br>        <span class="hljs-type">var</span> <span class="hljs-variable">Eddie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Eddie&quot;</span>, <span class="hljs-string">&quot;Dean&quot;</span>);<br>        <span class="hljs-type">var</span> <span class="hljs-variable">Detta</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Detta&quot;</span>, <span class="hljs-string">&quot;Walker&quot;</span>);<br>        <span class="hljs-type">var</span> <span class="hljs-variable">Jake</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Jake&quot;</span>, <span class="hljs-string">&quot;Chambers&quot;</span>);<br><br>        <span class="hljs-type">var</span> <span class="hljs-variable">filteredPersons</span> <span class="hljs-operator">=</span><br>                List.of(Roland, Susan, Eddie, Detta, Jake)<br>                        .stream()<br>                        .filter((<span class="hljs-keyword">var</span> x) -&gt; x.name.contains(<span class="hljs-string">&quot;a&quot;</span>))<br>                        .collect(Collectors.toList());<br>        System.out.println(filteredPersons);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Inside the <code>filter()</code> method we are using <code>var</code> to infer the type instead of explicitly mentioning the type.</p><p>Please note that it doesn’t make a difference if we use <code>var</code> or type inference without it. It will work the same for both.</p><h2 id="Java-14"><a href="#Java-14" class="headerlink" title="Java 14"></a>Java 14</h2><h3 id="Switch-Expressions"><a href="#Switch-Expressions" class="headerlink" title="Switch Expressions"></a>Switch Expressions</h3><p>Switch expressions allowed us to omit <code>break</code> calls inside every <code>case</code> block. It helps with the readability of the code and better understanding.</p><p>In this section, we will see several ways of how to use switch expressions.</p><h4 id="Old-Way-of-Switch-Statements"><a href="#Old-Way-of-Switch-Statements" class="headerlink" title="Old Way of Switch Statements"></a>Old Way of Switch Statements</h4><p>We have a method where a client provides the desired month, and we return the number of days inside that month.</p><p>The first thing that comes to our mind is to build it with <code>switch-case</code> statements:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwitchExpression</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">days</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">Month</span> <span class="hljs-variable">month</span> <span class="hljs-operator">=</span> Month.APRIL;<br><br>        <span class="hljs-keyword">switch</span> (month) &#123;<br>            <span class="hljs-keyword">case</span> JANUARY, MARCH, MAY, JULY, AUGUST, OCTOBER, DECEMBER :<br>                days = <span class="hljs-number">31</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> FEBRUARY :<br>                days = <span class="hljs-number">28</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> APRIL, JUNE, SEPTEMBER, NOVEMBER :<br>                days = <span class="hljs-number">30</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>We need to make sure that we put a break statement inside our case code block. Failing it will result in checking on other conditions after we match the first one.</p><h4 id="Using-Switch-Expressions"><a href="#Using-Switch-Expressions" class="headerlink" title="Using Switch Expressions"></a>Using Switch Expressions</h4><p>We will look into the same method as before. The user wants to send the month and get the number of days in that month:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwitchExpression</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">days</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">Month</span> <span class="hljs-variable">month</span> <span class="hljs-operator">=</span> Month.APRIL;<br><br>        days = <span class="hljs-keyword">switch</span> (month) &#123;<br>            <span class="hljs-keyword">case</span> JANUARY, MARCH, MAY, JULY, AUGUST, OCTOBER, DECEMBER -&gt; <span class="hljs-number">31</span>;<br>            <span class="hljs-keyword">case</span> FEBRUARY -&gt; <span class="hljs-number">28</span>;<br>            <span class="hljs-keyword">case</span> APRIL, JUNE, SEPTEMBER, NOVEMBER -&gt; <span class="hljs-number">30</span>;<br>            <span class="hljs-keyword">default</span> -&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>We are using a bit different notation in the <code>case</code> block. We are using <code>-&gt;</code> instead of the colon. Even though we are not invoking the <code>break</code> statement, we will still jump out of the switch statement on the first valid condition.</p><p>This will do the same thing as the code shown in <a href="https://reflectoring.io/java-release-notes/#old-way-of-switch-statements">the previous example</a>.</p><h4 id="The-yield-Keyword"><a href="#The-yield-Keyword" class="headerlink" title="The yield Keyword"></a>The <code>yield</code> Keyword</h4><p>The logic inside the <code>case</code> block can be a bit more complicated than just returning a value. For example, we want to log which month the user sent us:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwitchExpression</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">days</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">Month</span> <span class="hljs-variable">month</span> <span class="hljs-operator">=</span> Month.APRIL;<br><br>        days = <span class="hljs-keyword">switch</span> (month) &#123;<br>            <span class="hljs-keyword">case</span> JANUARY, MARCH, MAY, JULY, AUGUST, OCTOBER, DECEMBER -&gt; &#123;<br>                System.out.println(month);<br>                <span class="hljs-keyword">yield</span> <span class="hljs-number">31</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> FEBRUARY -&gt; &#123;<br>                System.out.println(month);<br>                <span class="hljs-keyword">yield</span> <span class="hljs-number">28</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> APRIL, JUNE, SEPTEMBER, NOVEMBER -&gt; &#123;<br>                System.out.println(month);<br>                <span class="hljs-keyword">yield</span> <span class="hljs-number">30</span>;<br>            &#125;<br>            <span class="hljs-keyword">default</span> -&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>In a multi-line code block, we have to use the <code>yield</code> keyword to return a value from a <code>case</code> block.</p><p>To read more about using switch expressions please refer to the <a href="https://docs.oracle.com/en/java/javase/14/language/switch-expressions.html">docs</a>.</p><h2 id="Java-15"><a href="#Java-15" class="headerlink" title="Java 15"></a>Java 15</h2><h3 id="Text-Blocks"><a href="#Text-Blocks" class="headerlink" title="Text Blocks"></a>Text Blocks</h3><p>Text block is an improvement on formatting String variables. From Java 15, we can write a String that spans through several lines as regular text.</p><h4 id="Example-Without-Using-Text-Blocks"><a href="#Example-Without-Using-Text-Blocks" class="headerlink" title="Example Without Using Text Blocks"></a>Example Without Using Text Blocks</h4><p>We want to send an HTML document via email. We are storing the email template into a variable:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TextBlocks</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<br>        <span class="hljs-string">&quot;&lt;!DOCTYPE html&gt;\n&quot;</span> +<br>                <span class="hljs-string">&quot;&lt;html&gt;\n&quot;</span> +<br>                <span class="hljs-string">&quot;     &lt;head&gt;\n&quot;</span> +<br>                <span class="hljs-string">&quot;        &lt;title&gt;Example&lt;/title&gt;\n&quot;</span> +<br>                <span class="hljs-string">&quot;    &lt;/head&gt;\n&quot;</span> +<br>                <span class="hljs-string">&quot;    &lt;body&gt;\n&quot;</span> +<br>                <span class="hljs-string">&quot;        &lt;p&gt;This is an example of a simple HTML &quot;</span> +<br>                <span class="hljs-string">&quot;page with one paragraph.&lt;/p&gt;\n&quot;</span> +<br>                <span class="hljs-string">&quot;    &lt;/body&gt;\n&quot;</span> +<br>                <span class="hljs-string">&quot;&lt;/html&gt;\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>We are formatting our string like in the example above. We need to take care of new lines and append all the lines to a single string.</p><h4 id="Example-of-Using-Text-Blocks"><a href="#Example-of-Using-Text-Blocks" class="headerlink" title="Example of Using Text Blocks"></a>Example of Using Text Blocks</h4><p>Let us look into the same example of an HTML template for email. We want to send an example email with some straightforward HTML formatting. This time we will use a text block:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TextBlocks</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">                &lt;!DOCTYPE html&gt;</span><br><span class="hljs-string">                &lt;html&gt;</span><br><span class="hljs-string">                    &lt;head&gt;</span><br><span class="hljs-string">                        &lt;title&gt;Example&lt;/title&gt;</span><br><span class="hljs-string">                    &lt;/head&gt;</span><br><span class="hljs-string">                    &lt;body&gt;</span><br><span class="hljs-string">                        &lt;p&gt;This is an example of a simple HTML </span><br><span class="hljs-string">                        page with one paragraph.&lt;/p&gt;</span><br><span class="hljs-string">                    &lt;/body&gt;</span><br><span class="hljs-string">                &lt;/html&gt;      </span><br><span class="hljs-string">                &quot;&quot;&quot;</span><br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>We used special syntax for opening and closing quotes: <code>&quot;&quot;&quot;</code>. This allows us to treat our string as if we are writing it in a .txt file.</p><p>There are some rules that we need to abide by when using a text block. We need to make sure that we put a new line after our opening quotes, or our compiler will throw an error:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Illegal <span class="hljs-keyword">text</span> block <span class="hljs-built_in">start</span>: missing <span class="hljs-built_in">new</span> <span class="hljs-built_in">line</span> <span class="hljs-keyword">after</span> opening quotes.<br></code></pre></td></tr></table></figure><p>If we want to end our string with <code>\n</code> we can do it by putting new line before closing <code>&quot;&quot;&quot;</code> like in the example above.</p><p>To read more about text blocks please refer to the <a href="https://docs.oracle.com/en/java/javase/15/text-blocks/index.html">docs</a>.</p><h2 id="Java-16"><a href="#Java-16" class="headerlink" title="Java 16"></a>Java 16</h2><h3 id="Pattern-Matching-of-instanceof"><a href="#Pattern-Matching-of-instanceof" class="headerlink" title="Pattern Matching of instanceof"></a>Pattern Matching of instanceof</h3><p>Pattern matching on the <code>instanceof</code> allows us to cast our variable inline and use it inside the desired <code>if-else</code> block without explicitly casting it.</p><h4 id="Example-Without-Pattern-Matching"><a href="#Example-Without-Pattern-Matching" class="headerlink" title="Example Without Pattern Matching"></a>Example Without Pattern Matching</h4><p>We have a base class called <code>Vehicle</code> and two classes that extends it: <code>Car</code> and <code>Bicycle</code>. We omitted the code for this, and you can look it up in the <a href="https://github.com/thombergs/code-examples/tree/master/core-java/versions">GitHub repo</a>.</p><p>Our algorithm for calculating prices is depending on the instance of the vehicle that is sent to it:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PatternMatching</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">priceOld</span><span class="hljs-params">(Vehicle v)</span> &#123;<br>        <span class="hljs-keyword">if</span> (v <span class="hljs-keyword">instanceof</span> Car) &#123;<br>            <span class="hljs-type">Car</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (Car) v;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">10000</span> - c.kilomenters * <span class="hljs-number">0.01</span> -<br>                    (Calendar.getInstance().get(Calendar.YEAR) -<br>                            c.year) * <span class="hljs-number">100</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v <span class="hljs-keyword">instanceof</span> Bicycle) &#123;<br>            <span class="hljs-type">Bicycle</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (Bicycle) v;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1000</span> + b.wheelSize * <span class="hljs-number">10</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Since we are not using pattern matching, we need to cast the vehicle into the correct type inside each <code>if-else</code> block. As we can see, it is a typical example of boilerplate code for which Java is famous.</p><h4 id="Using-Pattern-Matching"><a href="#Using-Pattern-Matching" class="headerlink" title="Using Pattern Matching"></a>Using Pattern Matching</h4><p>Let’s see how can we can discard the boilerplate part from the example <a href="https://reflectoring.io/java-release-notes/#example-without-pattern-matching">above</a>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PatternMatching</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">price</span><span class="hljs-params">(Vehicle v)</span> &#123;<br>        <span class="hljs-keyword">if</span> (v <span class="hljs-keyword">instanceof</span> Car c) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">10000</span> - c.kilomenters * <span class="hljs-number">0.01</span> -<br>                    (Calendar.getInstance().get(Calendar.YEAR) -<br>                            c.year) * <span class="hljs-number">100</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v <span class="hljs-keyword">instanceof</span> Bicycle b) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1000</span> + b.wheelSize * <span class="hljs-number">10</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>One thing to note is the scope of the casted variable. It’s visible only within the if statement.</p><p>For more information about pattern matching in <code>instanceof</code> method please refer to the <a href="https://docs.oracle.com/en/java/javase/16/language/pattern-matching-instanceof-operator.html">docs</a>.</p><h3 id="Records"><a href="#Records" class="headerlink" title="Records"></a>Records</h3><p>How many POJOs (Plain Old Java Objects) have you written?</p><p>Well, I can answer for myself: “Too many!”.</p><p>Java has had a bad reputation for boilerplate code. Lombok allowed us to stop worrying about getters, setters, etc. Java 16 finally introduced records to remove a lot of boilerplate code.</p><p>A record class is nothing more than regular POJO, for which most of the code is generated from the definition.</p><h4 id="Plain-Old-Java-Object-definition"><a href="#Plain-Old-Java-Object-definition" class="headerlink" title="Plain Old Java Object definition"></a>Plain Old Java Object definition</h4><p>Let us look into the example of the POJO class before Java 16 introduced records:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    String code;<br>    String engineType;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> code;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCode</span><span class="hljs-params">(String code)</span> &#123;<br>        <span class="hljs-built_in">this</span>.code = code;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getEngineType</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> engineType;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEngineType</span><span class="hljs-params">(String engineType)</span> &#123;<br>        <span class="hljs-built_in">this</span>.engineType = engineType;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Vehicle</span><span class="hljs-params">(String code, String engineType)</span> &#123;<br>        <span class="hljs-built_in">this</span>.code = code;<br>        <span class="hljs-built_in">this</span>.engineType = engineType;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> ...<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> ...<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> ...<br>&#125;<br></code></pre></td></tr></table></figure><p>There are almost 50 lines of code for object that contains only two properties. The IDE generated this code, but still, it is there and has to be maintained.</p><h4 id="Record-Definition"><a href="#Record-Definition" class="headerlink" title="Record Definition"></a>Record Definition</h4><p>Definition of a vehicle record, with the same two properties, can be done in just one line:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title class_">VehicleRecord</span><span class="hljs-params">(String code, String engineType)</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>This one line has all the same getters, setters, constructors, etc. as from the example <a href="https://reflectoring.io/java-release-notes/#plain-old-java-object-definition">above</a>. One thing to note is that the record class is, by default, final, and we need to comply with that. That means we cannot extend a record class, but most other things are available for us.</p><p>To read more about record classes please refer to the <a href="https://docs.oracle.com/en/java/javase/16/language/records.html">docs</a>.</p><h2 id="Java-17"><a href="#Java-17" class="headerlink" title="Java 17"></a>Java 17</h2><h3 id="Sealed-Classes"><a href="#Sealed-Classes" class="headerlink" title="Sealed Classes"></a>Sealed Classes</h3><p>The <code>final</code> modifier on a class doesn’t allow anyone to extend it. What about when we want to extend a class but only allow it for some classes?</p><p>We are back at our car dealership business. We are so proud of our algorithm for calculating prices that we want to expose it. We don’t want anyone using our Vehicle representation, though. It is valid just for our business. We can see a bit of a problem here. We need to expose class but constrain it also.</p><p>This is where Java 17 comes into play with sealed classes. The sealed class allows us to make class effectively final for everyone except explicitly mentioned classes.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> <span class="hljs-keyword">permits</span> Bicycle, Car &#123;...&#125;<br></code></pre></td></tr></table></figure><p>We added a <code>sealed</code> modifier to our <code>Vehicle</code> class, and we had to add the <code>permits</code> keyword with a list of classes that we allow to extend it. After this change, we are still getting errors from the compiler.</p><p>There is one more thing that we need to do here.</p><p>We need to add <code>final</code>, <code>sealed</code>, or <code>non-sealed</code> modifiers to classes that will extend our class.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bicycle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Vehicle</span> &#123;...&#125;<br></code></pre></td></tr></table></figure><h4 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h4><p>Several constraints have to be met for the sealed class to work:</p><ul><li>Permitted subclasses must be accessible by the sealed class at compile time</li><li>Permitted subclasses must directly extend the sealed class</li><li>Permitted subclasses must have one of the following modifiers:<ul><li>final</li><li>sealed</li><li>non-sealed</li></ul></li><li>Permitted subclasses must be in the same Java module</li></ul><p>More details about sealed classes can be found in the <a href="https://docs.oracle.com/en/java/javase/17/language/sealed-classes-and-interfaces.html">docs</a>.</p><p>文章原文链接：<a href="https://reflectoring.io/java-release-notes/#diamond-syntax-with-inner-anonymous-classes">https://reflectoring.io/java-release-notes/#diamond-syntax-with-inner-anonymous-classes</a></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java Stream 源码分析</title>
    <link href="/2021/12/03/Java%20Stream%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2021/12/03/Java%20Stream%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 8 的 Stream 使得代码更加简洁易懂，本篇文章深入分析 Java Stream 的工作原理，并探讨 Steam 的性能问题。</p><hr><p>Java 8 集合中的 Stream 相当于高级版的 Iterator，它可以通过 Lambda 表达式对集合进行各种非常便利、高效的聚合操作（Aggregate Operation），或者大批量数据操作 (Bulk Data Operation)。</p><p>Stream 的聚合操作与数据库 SQL 的聚合操作 sorted、filter、map 等类似。我们在应用层就可以高效地实现类似数据库 SQL 的聚合操作了，而在数据操作方面，Stream 不仅可以通过串行的方式实现数据操作，还可以通过并行的方式处理大批量数据，提高数据的处理效率。</p><h1 id="操作分类"><a href="#操作分类" class="headerlink" title="操作分类"></a>操作分类</h1><p>官方将 Stream 中的操作分为两大类：</p><ul><li><code>中间操作（Intermediate operations）</code>，只对操作进行了记录，即只会返回一个流，不会进行计算操作。</li><li><code>终结操作（Terminal operations）</code>，实现了计算操作。</li></ul><p>中间操作又可以分为：</p><ul><li><code>无状态（Stateless）操作</code>，元素的处理不受之前元素的影响。</li><li><code>有状态（Stateful）操作</code>，指该操作只有拿到所有元素之后才能继续下去。</li></ul><p>终结操作又可以分为：</p><ul><li><code>短路（Short-circuiting）</code>操作，指遇到某些符合条件的元素就可以得到最终结果</li><li><code>非短路（Unshort-circuiting）</code>操作，指必须处理完所有元素才能得到最终结果。</li></ul><p>操作分类详情如下图所示：</p><p><img src="https://logflies.oss-cn-chengdu.aliyuncs.com/uPic/2020-12-03-030958.jpg"></p><h1 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h1><p>Stream 相关类和接口的继承关系如下图所示：</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-12-03-031525.jpg"></p><h2 id="BaseStream"><a href="#BaseStream" class="headerlink" title="BaseStream"></a>BaseStream</h2><p>最顶端的接口类，定义了流的基本接口方法，最主要的方法为 spliterator、isParallel。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-12-03-032745.png"></p><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>最顶端的接口类。定义了流的常用方法，例如 map、filter、sorted、limit、skip、collect 等。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-12-03-032941.png"></p><h2 id="ReferencePipeline"><a href="#ReferencePipeline" class="headerlink" title="ReferencePipeline"></a>ReferencePipeline</h2><p>ReferencePipeline 是一个结构类，定义内部类组装了各种操作流，定义了<code>Head</code>、<code>StatelessOp</code>、<code>StatefulOp</code>三个内部类，实现了 BaseStream 与 Stream 的接口方法。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-12-03-033157.png"></p><h2 id="Sink"><a href="#Sink" class="headerlink" title="Sink"></a>Sink</h2><p>Sink 接口定义了 Stream 之间的操作行为，包含 <code>begin()</code>、<code>end()</code>、<code>cancellationRequested()</code>、<code>accpt()</code>四个方法。ReferencePipeline 最终会将整个 Stream 流操作组装成一个调用链，而这条调用链上的各个 Stream 操作的上下关系就是通过 Sink 接口协议来定义实现的。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-12-03-033401.png"></p><h1 id="操作叠加"><a href="#操作叠加" class="headerlink" title="操作叠加"></a>操作叠加</h1><p>Stream 的基础用法就不再叙述了，这里从一段代码开始，分析 Stream 的工作原理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testStream</span><span class="hljs-params">()</span> &#123;<br>    List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">&quot;kotlin&quot;</span>, <span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;go&quot;</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxLength</span> <span class="hljs-operator">=</span> names.stream().filter(name -&gt; name.length() &lt;= <span class="hljs-number">4</span>).map(String::length)<br>            .max(Comparator.naturalOrder()).orElse(-<span class="hljs-number">1</span>);<br>    System.out.println(maxLength);<br>&#125;<br></code></pre></td></tr></table></figure><p>当使用 Stream 时，主要有 3 部分组成，下面一一讲解。</p><h2 id="加载数据源"><a href="#加载数据源" class="headerlink" title="加载数据源"></a>加载数据源</h2><p>调用 <code>names.stream()</code> 方法，会初次加载 ReferencePipeline 的 Head 对象，此时为加载数据源操作。</p><p>java.util.Collection#stream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> Stream&lt;E&gt; <span class="hljs-title function_">stream</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> StreamSupport.stream(spliterator(), <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>StreamSupport 类中的 stream 方法，初始化了一个 ReferencePipeline 的 Head 内部类对象。</p><p>java.util.stream.StreamSupport#stream(java.util.Spliterator<T>, boolean)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="hljs-title function_">stream</span><span class="hljs-params">(Spliterator&lt;T&gt; spliterator, <span class="hljs-type">boolean</span> parallel)</span> &#123;<br>    Objects.requireNonNull(spliterator);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferencePipeline</span>.Head&lt;&gt;(spliterator,<br>                                        StreamOpFlag.fromCharacteristics(spliterator),<br>                                        parallel);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h2><p>接着为 <code>filter(name -&gt; name.length() &lt;= 4).mapToInt(String::length)</code>，是中间操作，分为无状态中间操作 StatelessOp 对象和有状态操作 StatefulOp 对象，此时的 Stage 并没有执行，而是通过 AbstractPipeline 生成了一个中间操作 Stage 链表。</p><p>java.util.stream.ReferencePipeline#filter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Stream&lt;P_OUT&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> P_OUT&gt; predicate)</span> &#123;<br>    Objects.requireNonNull(predicate);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StatelessOp</span>&lt;P_OUT, P_OUT&gt;(<span class="hljs-built_in">this</span>, StreamShape.REFERENCE,<br>                                    StreamOpFlag.NOT_SIZED) &#123;<br>        <span class="hljs-meta">@Override</span><br>        Sink&lt;P_OUT&gt; <span class="hljs-title function_">opWrapSink</span><span class="hljs-params">(<span class="hljs-type">int</span> flags, Sink&lt;P_OUT&gt; sink)</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sink</span>.ChainedReference&lt;P_OUT, P_OUT&gt;(sink) &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">begin</span><span class="hljs-params">(<span class="hljs-type">long</span> size)</span> &#123;<br>                    downstream.begin(-<span class="hljs-number">1</span>);<br>                &#125;<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(P_OUT u)</span> &#123;<br>                    <span class="hljs-keyword">if</span> (predicate.test(u))<br>                        downstream.accept(u);<br>                &#125;<br>            &#125;;<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>java.util.stream.ReferencePipeline#map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> &lt;R&gt; Stream&lt;R&gt; <span class="hljs-title function_">map</span><span class="hljs-params">(Function&lt;? <span class="hljs-built_in">super</span> P_OUT, ? extends R&gt; mapper)</span> &#123;<br>    Objects.requireNonNull(mapper);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StatelessOp</span>&lt;P_OUT, R&gt;(<span class="hljs-built_in">this</span>, StreamShape.REFERENCE,<br>                                    StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) &#123;<br>        <span class="hljs-meta">@Override</span><br>        Sink&lt;P_OUT&gt; <span class="hljs-title function_">opWrapSink</span><span class="hljs-params">(<span class="hljs-type">int</span> flags, Sink&lt;R&gt; sink)</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sink</span>.ChainedReference&lt;P_OUT, R&gt;(sink) &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(P_OUT u)</span> &#123;<br>                    downstream.accept(mapper.apply(u));<br>                &#125;<br>            &#125;;<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 filter 和 map 方法都返回了一个新的 <code>StatelessOp</code> 对象。new StatelessOp 将会调用父类 AbstractPipeline 的构造函数，这个构造函数将前后的 Stage 联系起来，生成一个 Stage 链表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">AbstractPipeline(AbstractPipeline&lt;?, E_IN, ?&gt; previousStage, <span class="hljs-type">int</span> opFlags) &#123;<br>    <span class="hljs-keyword">if</span> (previousStage.linkedOrConsumed)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(MSG_STREAM_LINKED);<br>    previousStage.linkedOrConsumed = <span class="hljs-literal">true</span>;<br>    previousStage.nextStage = <span class="hljs-built_in">this</span>;<br><br>    <span class="hljs-built_in">this</span>.previousStage = previousStage;<br>    <span class="hljs-built_in">this</span>.sourceOrOpFlags = opFlags &amp; StreamOpFlag.OP_MASK;<br>    <span class="hljs-built_in">this</span>.combinedFlags = StreamOpFlag.combineOpFlags(opFlags, previousStage.combinedFlags);<br>    <span class="hljs-built_in">this</span>.sourceStage = previousStage.sourceStage;<br>    <span class="hljs-keyword">if</span> (opIsStateful())<br>        sourceStage.sourceAnyStateful = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">this</span>.depth = previousStage.depth + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="终结操作"><a href="#终结操作" class="headerlink" title="终结操作"></a>终结操作</h2><p>最后为 <code>max(Comparator.naturalOrder())</code>，是终结操作，会生成一个最终的 Stage，通过这个 Stage 触发之前的中间操作，从最后一个 Stage 开始，递归产生一个 Sink 链。</p><p>java.util.stream.ReferencePipeline#max</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Optional&lt;P_OUT&gt; <span class="hljs-title function_">max</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-built_in">super</span> P_OUT&gt; comparator)</span> &#123;<br>    <span class="hljs-keyword">return</span> reduce(BinaryOperator.maxBy(comparator));<br>&#125;<br></code></pre></td></tr></table></figure><p>最终调用到 java.util.stream.AbstractPipeline#wrapSink，这个方法会调用 opWrapSink 生成一个 Sink 链表，对应到本文的例子，就是 filter 和 map 操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">final</span> &lt;P_IN&gt; Sink&lt;P_IN&gt; <span class="hljs-title function_">wrapSink</span><span class="hljs-params">(Sink&lt;E_OUT&gt; sink)</span> &#123;<br>    Objects.requireNonNull(sink);<br><br>    <span class="hljs-keyword">for</span> ( <span class="hljs-meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> AbstractPipeline p=AbstractPipeline.<span class="hljs-built_in">this</span>; p.depth &gt; <span class="hljs-number">0</span>; p=p.previousStage) &#123;<br>        sink = p.opWrapSink(p.previousStage.combinedFlags, sink);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (Sink&lt;P_IN&gt;) sink;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面 opWrapSink 上断点调试，发现最终会调用到本例中的 filter 和 map 操作。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-12-03-065103.png"></p><p>wrapAndCopyInto 生成 Sink 链表后，会通过 copyInfo 方法执行 Sink 链表的具体操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">final</span> &lt;P_IN&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">copyInto</span><span class="hljs-params">(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator)</span> &#123;<br>    Objects.requireNonNull(wrappedSink);<br><br>    <span class="hljs-keyword">if</span> (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123;<br>        wrappedSink.begin(spliterator.getExactSizeIfKnown());<br>        spliterator.forEachRemaining(wrappedSink);<br>        wrappedSink.end();<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        copyIntoWithCancel(wrappedSink, spliterator);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的核心代码是：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">spliterator.forEachRemaining(wrappedSink)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>java.util.Spliterators.ArraySpliterator#forEachRemaining</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEachRemaining</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span> &#123;<br>    Object[] a; <span class="hljs-type">int</span> i, hi; <span class="hljs-comment">// hoist accesses and checks from loop</span><br>    <span class="hljs-keyword">if</span> (action == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-keyword">if</span> ((a = array).length &gt;= (hi = fence) &amp;&amp;<br>        (i = index) &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; (index = hi)) &#123;<br>        <span class="hljs-keyword">do</span> &#123; action.accept((T)a[i]); &#125; <span class="hljs-keyword">while</span> (++i &lt; hi);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>断点调试，可以发现首先进入了 filter 的 Sink，其中 accept 方法的入参是 list 中的第一个元素“kotlin”（代码中的 3 个元素是：”kotlin”, “java”, “go”）。filter 的传入是一个 Lambda 表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">filter(name -&gt; name.length() &lt;= <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>显然这个第一个元素“kotlin”的 predicate 是不会进入的。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-12-03-070838.png"></p><p>对于第二个元素“java”，predicate.test 会返回 true（字符串“java”的长度&lt;&#x3D;4），则会进入 map 的 accept 方法。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-12-03-071448.png"></p><p>本次调用 accept 方法时，empty 为 false，会将 map 后的结果（int 类型的 4）赋值给 t。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; TerminalOp&lt;T, Optional&lt;T&gt;&gt;<br><span class="hljs-title function_">makeRef</span><span class="hljs-params">(BinaryOperator&lt;T&gt; operator)</span> &#123;<br>    Objects.requireNonNull(operator);<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReducingSink</span><br>            <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AccumulatingSink</span>&lt;T, Optional&lt;T&gt;, ReducingSink&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> empty;<br>        <span class="hljs-keyword">private</span> T state;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">begin</span><span class="hljs-params">(<span class="hljs-type">long</span> size)</span> &#123;<br>            empty = <span class="hljs-literal">true</span>;<br>            state = <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(T t)</span> &#123;<br>            <span class="hljs-keyword">if</span> (empty) &#123;<br>                empty = <span class="hljs-literal">false</span>;<br>                state = t;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                state = operator.apply(state, t);<br>            &#125;<br>        &#125;<br><br>        ……<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于第三个元素“go”，也会进入 accept 方法，此时 empty 为 true, map 后的结果（int 类型的 2）会与上次的结果 4 通过自定义的比较器相比较，存入符合结果的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; BinaryOperator&lt;T&gt; <span class="hljs-title function_">maxBy</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-built_in">super</span> T&gt; comparator)</span> &#123;<br>    Objects.requireNonNull(comparator);<br>    <span class="hljs-keyword">return</span> (a, b) -&gt; comparator.compare(a, b) &gt;= <span class="hljs-number">0</span> ? a : b;<br>&#125;<br></code></pre></td></tr></table></figure><p>本文代码中的 max 传入的比较器为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">max(Comparator.naturalOrder())<br></code></pre></td></tr></table></figure><p>至此会返回 int 类型的 4。</p><h1 id="并行处理"><a href="#并行处理" class="headerlink" title="并行处理"></a>并行处理</h1><p>上面的例子是串行处理的，如果要改成并行也很简单，只需要在 stream() 方法后加上 <code>parallel()</code> 就可以了，并行代码可以写成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testStream</span><span class="hljs-params">()</span> &#123;<br>    List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">&quot;kotlin&quot;</span>, <span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;go&quot;</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxLength</span> <span class="hljs-operator">=</span> names.stream().parallel().filter(name -&gt; name.length() &lt;= <span class="hljs-number">4</span>)<br>            .map(String::length).max(Comparator.naturalOrder()).orElse(-<span class="hljs-number">1</span>);<br>    System.out.println(maxLength);<br>&#125;<br></code></pre></td></tr></table></figure><p>Stream 的并行处理在执行终结操作之前，跟串行处理的实现是一样的。而在调用终结方法之后，实现的方式就有点不太一样，会调用 TerminalOp 的 evaluateParallel 方法进行并行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> &lt;R&gt; R <span class="hljs-title function_">evaluate</span><span class="hljs-params">(TerminalOp&lt;E_OUT, R&gt; terminalOp)</span> &#123;<br>    <span class="hljs-keyword">assert</span> <span class="hljs-title function_">getOutputShape</span><span class="hljs-params">()</span> == terminalOp.inputShape();<br>    <span class="hljs-keyword">if</span> (linkedOrConsumed)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(MSG_STREAM_LINKED);<br>    linkedOrConsumed = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">return</span> isParallel()<br>            ? terminalOp.evaluateParallel(<span class="hljs-built_in">this</span>, sourceSpliterator(terminalOp.getOpFlags()))<br>            : terminalOp.evaluateSequential(<span class="hljs-built_in">this</span>, sourceSpliterator(terminalOp.getOpFlags()));<br>&#125;<br></code></pre></td></tr></table></figure><p>核心是使用了 ForkJoin 框架，对 Stream 处理进行分片，最终会调用下面的代码，这里就不展开分析了。</p><p>java.util.stream.AbstractTask#compute</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>    Spliterator&lt;P_IN&gt; rs = spliterator, ls; <span class="hljs-comment">// right, left spliterators</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">sizeEstimate</span> <span class="hljs-operator">=</span> rs.estimateSize();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">sizeThreshold</span> <span class="hljs-operator">=</span> getTargetSize(sizeEstimate);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">forkRight</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="hljs-type">K</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> (K) <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">while</span> (sizeEstimate &gt; sizeThreshold &amp;&amp; (ls = rs.trySplit()) != <span class="hljs-literal">null</span>) &#123;<br>        K leftChild, rightChild, taskToFork;<br>        task.leftChild  = leftChild = task.makeChild(ls);<br>        task.rightChild = rightChild = task.makeChild(rs);<br>        task.setPendingCount(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (forkRight) &#123;<br>            forkRight = <span class="hljs-literal">false</span>;<br>            rs = ls;<br>            task = leftChild;<br>            taskToFork = rightChild;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            forkRight = <span class="hljs-literal">true</span>;<br>            task = rightChild;<br>            taskToFork = leftChild;<br>        &#125;<br>        taskToFork.fork();<br>        sizeEstimate = rs.estimateSize();<br>    &#125;<br>    task.setLocalResult(task.doLeaf());<br>    task.tryComplete();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="并行错误的使用方法"><a href="#并行错误的使用方法" class="headerlink" title="并行错误的使用方法"></a>并行错误的使用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testParallelWrong</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Integer&gt; parallelList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    IntStream.range(<span class="hljs-number">0</span>, <span class="hljs-number">1000</span>).boxed().parallel().filter(i -&gt; i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>            .forEach(parallelList::add);<br>    System.out.println(parallelList.size());<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的输出结果会经常小于 500，这是因为 parallelList 的类型是 ArrayList，并不是线程安全的，在执行 add 操作时，可能正好赶上扩容或者线程被占用，会覆盖其他线程的赋好的值。</p><h2 id="并行正确的使用方法"><a href="#并行正确的使用方法" class="headerlink" title="并行正确的使用方法"></a>并行正确的使用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testParallelRight</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Integer&gt; parallelList = IntStream.range(<span class="hljs-number">0</span>, <span class="hljs-number">1000</span>).boxed().parallel()<br>            .filter(i -&gt; i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>).collect(Collectors.toList());<br>    System.out.println(parallelList.size());<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的输出结果是 500。</p><h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>下面的文章参考自：<a href="https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/8-Stream%20Performance.md">JavaLambdaInternals&#x2F;8-Stream Performance.md</a>，侵删。</p><p>为保证测试结果真实可信，我们将 JVM 运行在<code>-server</code>模式下，测试数据在 GB 量级，测试机器采用常见的商用服务器，配置如下：</p><table width="300px"><tr><td>OS</td><td>CentOS 6.7 x86_64</td></tr><tr><td>CPU</td><td>Intel Xeon X5675, 12M Cache 3.06 GHz, 6 Cores 12 Threads</td></tr><tr><td>内存</td><td>96GB</td></tr><tr><td>JDK</td><td>java version 1.8.0_91, Java HotSpot(TM) 64-Bit Server VM</td></tr></table><p>测试 <a href="./perf/StreamBenchmark/src/lee">所用代码在这里</a>，测试 <a href="./perf/Stream_performance.xlsx">结果汇总</a>.</p><h2 id="测试方法和测试数据"><a href="#测试方法和测试数据" class="headerlink" title="测试方法和测试数据"></a>测试方法和测试数据</h2><p>性能测试并不是容易的事，Java 性能测试更费劲，因为虚拟机对性能的影响很大，JVM 对性能的影响有两方面：</p><ol><li>GC 的影响。GC 的行为是 Java 中很不好控制的一块，为增加确定性，我们手动指定使用 CMS 收集器，并使用 10GB 固定大小的堆内存。具体到 JVM 参数就是<code>-XX:+UseConcMarkSweepGC -Xms10G -Xmx10G</code></li><li>JIT(Just-In-Time) 即时编译技术。即时编译技术会将热点代码在 JVM 运行的过程中编译成本地代码，测试时我们会先对程序预热，触发对测试函数的即时编译。相关的 JVM 参数是<code>-XX:CompileThreshold=10000</code>。</li></ol><p>Stream 并行执行时用到<code>ForkJoinPool.commonPool()</code>得到的线程池，为控制并行度我们使用 Linux 的<code>taskset</code>命令指定 JVM 可用的核数。</p><p>测试数据由程序随机生成。为防止一次测试带来的抖动，测试 4 次求出平均时间作为运行时间。</p><h2 id="实验一-基本类型迭代"><a href="#实验一-基本类型迭代" class="headerlink" title="实验一 基本类型迭代"></a>实验一 基本类型迭代</h2><p>测试内容：找出整型数组中的最小值。对比 for 循环外部迭代和 Stream API 内部迭代性能。</p><p>测试程序 <a href="./perf/StreamBenchmark/src/lee/IntTest.java">IntTest</a>，测试结果如下图：</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-12-03-074737.jpg"></p><p>图中展示的是 for 循环外部迭代耗时为基准的时间比值。分析如下：</p><ol><li>对于基本类型 Stream 串行迭代的性能开销明显高于外部迭代开销（两倍）；</li><li>Stream 并行迭代的性能比串行迭代和外部迭代都好。</li></ol><p>并行迭代性能跟可利用的核数有关，上图中的并行迭代使用了全部 12 个核，为考察使用核数对性能的影响，我们专门测试了不同核数下的 Stream 并行迭代效果：</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-12-03-074833.jpg"></p><p>分析，对于基本类型：</p><ol><li>使用 Stream 并行 API 在单核情况下性能很差，比 Stream 串行 API 的性能还差；</li><li>随着使用核数的增加，Stream 并行效果逐渐变好，比使用 for 循环外部迭代的性能还好。</li></ol><p>以上两个测试说明，对于基本类型的简单迭代，Stream 串行迭代性能更差，但多核情况下 Stream 迭代时性能较好。</p><h2 id="实验二-对象迭代"><a href="#实验二-对象迭代" class="headerlink" title="实验二 对象迭代"></a>实验二 对象迭代</h2><p>再来看对象的迭代效果。</p><p>测试内容：找出字符串列表中最小的元素（自然顺序），对比 for 循环外部迭代和 Stream API 内部迭代性能。</p><p>测试程序 <a href="./perf/StreamBenchmark/src/lee/StringTest.java">StringTest</a>，测试结果如下图：</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-12-03-074848.jpg"></p><p>结果分析如下：</p><ol><li>对于对象类型 Stream 串行迭代的性能开销仍然高于外部迭代开销（1.5 倍），但差距没有基本类型那么大。</li><li>Stream 并行迭代的性能比串行迭代和外部迭代都好。</li></ol><p>再来单独考察 Stream 并行迭代效果：</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-12-03-074906.jpg"></p><p>分析，对于对象类型：</p><ol><li>使用 Stream 并行 API 在单核情况下性能比 for 循环外部迭代差；</li><li>随着使用核数的增加，Stream 并行效果逐渐变好，多核带来的效果明显。</li></ol><p>以上两个测试说明，对于对象类型的简单迭代，Stream 串行迭代性能更差，但多核情况下 Stream 迭代时性能较好。</p><h2 id="实验三-复杂对象归约"><a href="#实验三-复杂对象归约" class="headerlink" title="实验三 复杂对象归约"></a>实验三 复杂对象归约</h2><p>从实验一、二的结果来看，Stream 串行执行的效果都比外部迭代差（很多），是不是说明 Stream 真的不行了？先别下结论，我们再来考察一下更复杂的操作。</p><p>测试内容：给定订单列表，统计每个用户的总交易额。对比使用外部迭代手动实现和 Stream API 之间的性能。</p><p>我们将订单简化为<code>&lt;userName, price, timeStamp&gt;</code>构成的元组，并用<code>Order</code>对象来表示。测试程序 <a href="./perf/StreamBenchmark/src/lee/ReductionTest.java">ReductionTest</a>，测试结果如下图：</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-12-03-074920.jpg"></p><p>分析，对于复杂的归约操作：</p><ol><li>Stream API 的性能普遍好于外部手动迭代，并行 Stream 效果更佳；</li></ol><p>再来考察并行度对并行效果的影响，测试结果如下：</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-12-03-074933.jpg"></p><p>分析，对于复杂的归约操作：</p><ol><li>使用 Stream 并行归约在单核情况下性能比串行归约以及手动归约都要差，简单说就是最差的；</li><li>随着使用核数的增加，Stream 并行效果逐渐变好，多核带来的效果明显。</li></ol><p>以上两个实验说明，对于复杂的归约操作，Stream 串行归约效果好于手动归约，在多核情况下，并行归约效果更佳。我们有理由相信，对于其他复杂的操作，Stream API 也能表现出相似的性能表现。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>上述三个实验的结果可以总结如下：</p><ol><li>对于<code>简单操作</code>，比如最简单的遍历，<code>Stream 串行 API 性能明显差于显式迭代</code>，但并行的 Stream API 能够发挥多核特性。</li><li>对于<code>复杂操作</code>，Stream 串行 API 性能可以和手动实现的效果匹敌，在<code>并行执行时 Stream API 效果远超手动实现</code>。</li></ol><p>所以，如果出于性能考虑：</p><ol><li>对于简单操作推荐使用外部迭代手动实现</li><li>对于复杂操作，推荐使用 Stream API</li><li>在多核情况下，推荐使用并行 Stream API 来发挥多核优势</li><li>单核情况下不建议使用并行 Stream API</li></ol><h2 id="为什么简单操作，Stream-API-不如迭代，而复杂操作性能差不多？"><a href="#为什么简单操作，Stream-API-不如迭代，而复杂操作性能差不多？" class="headerlink" title="为什么简单操作，Stream API 不如迭代，而复杂操作性能差不多？"></a>为什么简单操作，Stream API 不如迭代，而复杂操作性能差不多？</h2><p>其实根据上面 Stream 源码的分析，结合 Stream 的使用，可以看出如果是简单操作的话，Stream 也会包括加载数据源、中间操作、终结操作等，所以简单操作会慢于显式迭代。</p><p>但是如果是复杂操作，Stream 加载数据源、中间操作、终结操作相对来说就没有那么重要了，甚至还可以包括短路等优化，所以跟显式迭代的性能并没有什么差别。同时 Stream 还能增加可读性，很方便利用多核性能，这是显示迭代不能实现的。</p><p>（个人思考的结果，有问题欢迎留言交流 ^_^）</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol><li><a href="https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/6-Stream%20Pipelines.md">JavaLambdaInternals&#x2F;6-Stream Pipelines.md</a></li><li><a href="https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/8-Stream%20Performance.md">JavaLambdaInternals&#x2F;8-Stream Performance.md</a></li><li>极客时间-Java 性能调优实战&#x2F;06.Stream 如何提高遍历集合效率？</li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java String 演进全解析</title>
    <link href="/2021/11/29/Java%20String%20%E6%BC%94%E8%BF%9B%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <url>/2021/11/29/Java%20String%20%E6%BC%94%E8%BF%9B%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>String 是我们使用最频繁的对象，使用不当会对内存、程序的性能造成影响，本篇文章全面介绍一下 Java 的 String 是如何演进的，以及使用 String 的注意事项。</p><h1 id="下面的输出结果是什么？"><a href="#下面的输出结果是什么？" class="headerlink" title="下面的输出结果是什么？"></a>下面的输出结果是什么？</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> str2.intern();<br>    System.out.println(str1 == str2);<br>    System.out.println(str2 == str3);<br>    System.out.println(str1 == str3);<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码涉及了 Java 字符串的内存分配、新建对象和引用等方面的知识，输出结果是：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">false</span><br><span class="hljs-literal">false</span><br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h1 id="String-对象的实现方式"><a href="#String-对象的实现方式" class="headerlink" title="String 对象的实现方式"></a>String 对象的实现方式</h1><p>String 对象的实现方式，在 Java 6、Java 7&#x2F;8、Java 9 中都有很大的区别。下面是一张简要的对比图：</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-11-29-062856.png"></p><h2 id="Java-6-的实现方式"><a href="#Java-6-的实现方式" class="headerlink" title="Java 6 的实现方式"></a>Java 6 的实现方式</h2><p>String 对 char 数组进行了封装，主要有四个成员变量：</p><ul><li>char 数组</li><li>偏移量 offset</li><li>字符数量 count</li><li>哈希值 hash</li></ul><p>String 对象可以通过 offset 和 count 在 char[] 数组中获取对应的字符串，这样做可以高效、快速地共享数组对象，节省内存空间，但是这种方法经常导致<code>内存泄漏</code>。</p><p>这是因为，假如有一个非常大的字符串数组对象 a，后来有一个小的字符串引用仅引用其中很少的字符 b，那么会新建大的数组 char[]，当 a 被释放后，char[] 的引用并不能被 GC，因为 b 还在引用。</p><h2 id="Java-7-8-的实现方式"><a href="#Java-7-8-的实现方式" class="headerlink" title="Java 7&#x2F;8 的实现方式"></a>Java 7&#x2F;8 的实现方式</h2><p>String 类去掉了 offset 和 count，String.substring 方法也不再共享char[]，从而解决了内存泄漏问题。</p><h2 id="Java-9-的实现方式"><a href="#Java-9-的实现方式" class="headerlink" title="Java 9 的实现方式"></a>Java 9 的实现方式</h2><p><code>char[] → byte[]</code>，同时新增了<code>coder</code>属性，标识字符编码。这是因为 char 字符占 16 位（2个字节），如果仅存储单字节编码的字符就非常浪费空间。</p><p>coder 属性的作用是标识字符串是否为 Latin-1（单字节编码），0 标识是 Latin-1，1 代表是 UTF-16。</p><p>Java 11 中的 java.lang.String#substring(int, int) 方法如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-type">int</span> beginIndex, <span class="hljs-type">int</span> endIndex)</span> </span>&#123;<br>    <span class="hljs-type">int</span> length = <span class="hljs-built_in">length</span>();<br>    <span class="hljs-built_in">checkBoundsBeginEnd</span>(beginIndex, endIndex, length);<br>    <span class="hljs-type">int</span> subLen = endIndex - beginIndex;<br>    <span class="hljs-keyword">if</span> (beginIndex == <span class="hljs-number">0</span> &amp;&amp; endIndex == length) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isLatin1</span>() ? StringLatin<span class="hljs-number">1.</span><span class="hljs-built_in">newString</span>(value, beginIndex, subLen)<br>                        : StringUTF<span class="hljs-number">16.</span><span class="hljs-built_in">newString</span>(value, beginIndex, subLen);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="String-在-JVM-中是如何存储的？"><a href="#String-在-JVM-中是如何存储的？" class="headerlink" title="String 在 JVM 中是如何存储的？"></a>String 在 JVM 中是如何存储的？</h1><p>这是一个很重要的问题，相信大部分人都不能描述清楚，因为 JVM 的实现改了很多版……</p><p>在 JDK 1.7 之前，运行时常量池逻辑包含<code>字符串常量池</code>，都存在方法区中，方法区在 HotSpot 虚拟机的实现为<code>永久代</code>。</p><p>在 JDK 1.7 中，<code>字符串常量池</code> → 堆，运行时常量池仍然在方法区中。</p><p>在 JDK 1.8 中，HotSpot 移除了永久代，使用元空间（Metaspace）代替。这时候<code>字符串常量池</code>在堆中，运行时常量池在元空间（Metaspace）。</p><h2 id="永久代-VS-元空间（Metaspace）"><a href="#永久代-VS-元空间（Metaspace）" class="headerlink" title="永久代 VS 元空间（Metaspace）"></a>永久代 VS 元空间（Metaspace）</h2><p>元空间的本质和永久代类似，都是对 JVM 规范中<code>方法区的实现</code>。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用<code>本地内存</code>。</p><h2 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a>一句话总结</h2><p>在新版 JDK 实现（毕竟 Java 8 都已经是老古董，Java 15 都发布了）中，字符串常量池是在堆中。</p><h1 id="使用-String-intern-节省内存"><a href="#使用-String-intern-节省内存" class="headerlink" title="使用 String.intern 节省内存"></a>使用 String.intern 节省内存</h1><p>虽然我还没有在项目中实际应用过，不过这个函数应该还挺有用的，能够复用 Java 中的字符串常量。文章开头的代码中，<code>System.out.println(str1 == str3);</code> 返回 true，就是因为 <code>java.lang.String#intern</code> 方法检测到字符串常量池有这个对象时，能够直接复用字符串常量池的对象，不会额外创建字符串常量。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">String str1 <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span><span class="hljs-comment">;</span><br>String str2 <span class="hljs-operator">=</span> new String(<span class="hljs-string">&quot;abc&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>注意上面的代码中，<code>new String(&quot;abc&quot;)</code> 里面的字符串 <code>abc</code> 与 str1 的 <code>abc</code> 不同，是在字符串常量池新创建的 <code>abc</code>。</p><p>String.intern 的代码注释如下。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs applescript">/**<br>    * Returns a canonical representation <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">string</span> object.<br>    * &lt;p&gt;<br>    * A pool <span class="hljs-keyword">of</span> strings, initially empty, <span class="hljs-keyword">is</span> maintained privately <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span><br>    * <span class="hljs-built_in">class</span> &#123;@code String&#125;.<br>    * &lt;p&gt;<br>    * When <span class="hljs-keyword">the</span> intern method <span class="hljs-keyword">is</span> invoked, <span class="hljs-keyword">if</span> <span class="hljs-keyword">the</span> pool already <span class="hljs-keyword">contains</span> a<br>    * <span class="hljs-built_in">string</span> <span class="hljs-keyword">equal</span> <span class="hljs-keyword">to</span> this &#123;@code String&#125; object <span class="hljs-keyword">as</span> determined <span class="hljs-keyword">by</span><br>    * <span class="hljs-keyword">the</span> &#123;@link <span class="hljs-comment">#equals(Object)&#125; method, then the string from the pool is</span><br>    * returned. Otherwise, this &#123;@code String&#125; object <span class="hljs-keyword">is</span> added <span class="hljs-keyword">to</span> <span class="hljs-keyword">the</span><br>    * pool <span class="hljs-keyword">and</span> <span class="hljs-keyword">a reference</span> <span class="hljs-keyword">to</span> this &#123;@code String&#125; object <span class="hljs-keyword">is</span> returned.<br>    * &lt;p&gt;<br>    * It follows <span class="hljs-keyword">that</span> <span class="hljs-keyword">for</span> any two strings &#123;@code s&#125; <span class="hljs-keyword">and</span> &#123;@code t&#125;,<br>    * &#123;@code s.intern() == t.intern()&#125; <span class="hljs-keyword">is</span> &#123;@code <span class="hljs-literal">true</span>&#125;<br>    * <span class="hljs-keyword">if</span> <span class="hljs-keyword">and</span> only <span class="hljs-keyword">if</span> &#123;@code s.<span class="hljs-keyword">equals</span>(t)&#125; <span class="hljs-keyword">is</span> &#123;@code <span class="hljs-literal">true</span>&#125;.<br>    * &lt;p&gt;<br>    * All literal strings <span class="hljs-keyword">and</span> <span class="hljs-built_in">string</span>-valued <span class="hljs-built_in">constant</span> expressions are<br>    * interned. String literals are defined <span class="hljs-keyword">in</span> section <span class="hljs-number">3.10</span><span class="hljs-number">.5</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span><br>    * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.<br>    *<br>    * @<span class="hljs-literal">return</span>  a <span class="hljs-built_in">string</span> <span class="hljs-keyword">that</span> has <span class="hljs-keyword">the</span> same <span class="hljs-built_in">contents</span> <span class="hljs-keyword">as</span> this <span class="hljs-built_in">string</span>, <span class="hljs-keyword">but</span> <span class="hljs-keyword">is</span><br>    *          guaranteed <span class="hljs-keyword">to</span> be <span class="hljs-keyword">from</span> a pool <span class="hljs-keyword">of</span> unique strings.<br>    * @jls <span class="hljs-number">3.10</span><span class="hljs-number">.5</span> String Literals<br>    */<br>public native String intern();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java NIO、Channel、Selector 详解</title>
    <link href="/2021/10/14/Java%20NIO%E3%80%81Channel%E3%80%81Selector%20%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/10/14/Java%20NIO%E3%80%81Channel%E3%80%81Selector%20%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>Java NIO 有三大组件：</p><ol><li>Buffer</li><li>Channel</li><li>Selector</li></ol><h1 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h1><p>Buffer 是一个特定<strong>原始类型的容器</strong>。Buffer 是一个原始类型的线性的、有限序列，除了 Buffer 存储的内容外，关键属性还包括：capacity, limit 和 position。</p><ul><li><strong>capacity</strong>：Buffer 包含的元素的数量，capacity 永远不会为负，也不会改变。</li><li><strong>limit</strong>：Buffer 中第一个不能读取或写入的元素索引。limit 永远不会为负，且永远小于等于 capacity</li><li><strong>position</strong>：下一个待读取、写入的元素索引。position 永远不会为负，且永远小于等于 limit</li></ul><p>每个基本类型（布尔类型除外），都有一个 Buffer 的子类。Java NIO 中 Buffer 的一些实现，其中最重要的是 <strong>ByteBuffer</strong>，其余类如 IntBuffer 的实现类未画出。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2019-10-14-084412.png"></p><p>我个人理解，Buffer 就是一个内存数组，并通过 capacity, limit 和 position 三个变量对读写操作进行控制。</p><h2 id="position、limit、capacity"><a href="#position、limit、capacity" class="headerlink" title="position、limit、capacity"></a>position、limit、capacity</h2><p>Buffer 的属性主要有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 恒等式: mark &lt;= position &lt;= limit &lt;= capacity</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">mark</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">position</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> limit;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br><br><span class="hljs-comment">// 仅在 direct buffers 中使用</span><br><span class="hljs-type">long</span> address;<br></code></pre></td></tr></table></figure><p>ByteBuffer 中额外定义了字节数组（其余 Buffer 的子类同理）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 该字节数组仅在分配在堆上时才非空（参考下面的 Direct vs. non-direct buffers）</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] hb;<br></code></pre></td></tr></table></figure><p>Buffer 就是根据这 4 个 int 型字段来配合内存数组的读写。这 4 个属性分别为：</p><ul><li><strong>mark</strong>：临时保存 position 的值，每次调用 mark() 方法都会将 mark 设值为当前的 position</li><li><strong>capacity</strong>：Buffer 缓冲区容量，capacity 永远不会为负，也不会改变。</li><li><strong>limit</strong>：Buffer 中第一个不能读取或写入的元素索引。limit 永远不会为负，且永远小于等于 capacity。写模式下，limit 代表的是最大能写入的数据，limit &#x3D; capacity；读模式下，limit &#x3D; Buffer 实际写入的数据大小。</li><li><strong>position</strong>：下一个待读取、写入的元素索引。position 永远不会为负，且永远小于等于 limit。</li></ul><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2019-10-14-113021.jpg"></p><h2 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h2><p>从上图中我们可以看到，ByteBuffer 类有 2 个实现类：</p><ol><li><strong>MappedByteBuffer</strong>：DirectByteBuffer 的抽象类，JVM 会尽可能交给本地方法操作 I&#x2F;O，其内存不会分配在堆上，不会占用应用程序的内存。</li><li><strong>HeapByteBuffer</strong>：顾名思义是存储在堆上的 Buffer，我们直接调用 <code>ByteBuffer.allocate(1024);</code> 时会创建此类 Buffer。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title function_">allocate</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (capacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeapByteBuffer</span>(capacity, capacity);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Direct-vs-non-direct-buffers"><a href="#Direct-vs-non-direct-buffers" class="headerlink" title="Direct vs. non-direct buffers"></a>Direct vs. non-direct buffers</h2><p>一个 byte buffer 可以是 direct，也可以是非 direct 的。对于 direct byte buffer，JVM 将尽量在本机上执行 I&#x2F;O 操作。也就是说，JVM 尽量避免每次在调用操作系统 I&#x2F;O 操作前，将缓冲区内容复制到中间缓冲区。</p><p>可以通过类中的 allocateDirect 工厂方法创建 direct buffer，这个方法创建的 direct buffer 通常比 non-direct buffer 具有更高的分配和释放成本。Direct buffer 内存可能分配在 GC 堆的外部，所以对应用程序的内存占用影响并不明显。所以建议将 direct buffer 分配给大型、寿命长的、受底层操作系统 I&#x2F;O 操作约束的缓冲区。</p><p>可以通过调用 isDirect 方法判断 byte buffer 是否是 direct 的。</p><h2 id="Buffer-初始化"><a href="#Buffer-初始化" class="headerlink" title="Buffer 初始化"></a>Buffer 初始化</h2><p>Buffer 可以通过 allocation 方法创建，也可以通过字节数组的 wrapping 方法创建并填充。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ByteBuffer byteBuf <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> ByteBuffer <span class="hljs-title">wrap</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] array)</span> </span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="填充-Buffer"><a href="#填充-Buffer" class="headerlink" title="填充 Buffer"></a>填充 Buffer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 填充一个 byte</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> ByteBuffer <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">byte</span> b)</span>;<br><br><span class="hljs-comment">// 在指定位置填充一个 byte</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> ByteBuffer <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">byte</span> b)</span>;<br><br><span class="hljs-comment">// 批量将 src buffer 填充到本 buffer</span><br><span class="hljs-keyword">public</span> ByteBuffer <span class="hljs-title function_">put</span><span class="hljs-params">(ByteBuffer src)</span> &#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">// 批量将 src 数组的特定区间填充到本 buffer</span><br><span class="hljs-keyword">public</span> ByteBuffer <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] src, <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> length)</span> &#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">// 批量将 src 数组填充到本 buffer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ByteBuffer <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] src)</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>我们还可以将 Channel 的数据填充到 Buffer 中，数据是从外部（文件、网络）读到内存中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> channel.read(buffer);<br></code></pre></td></tr></table></figure><h2 id="读取-Buffer"><a href="#读取-Buffer" class="headerlink" title="读取 Buffer"></a>读取 Buffer</h2><p>对于前面的写操作，每写一个值，position 都会自增 1，所以 position 会指向最后写入位置的后面一位。</p><p>如果要读取 Buffer 的值，需要调用 <strong>flip()</strong> 方法，从<strong>写模式切换到读模式</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Buffer <span class="hljs-title function_">flip</span><span class="hljs-params">()</span> &#123;<br>    limit = position; <span class="hljs-comment">// 将 limit 设置为实际写入的数据数量</span><br>    position = <span class="hljs-number">0</span>; <span class="hljs-comment">// 重置 position</span><br>    mark = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 将 mark 设置为未标记</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>读操作的 get 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 读取当前 position 的字节，然后 position 自增 1</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">byte</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 读取 index 的字节（ position 不会自增！）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">byte</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>;<br><br><span class="hljs-comment">// 批量将缓冲区数据传递到 dst 数组中，position 自增 dst 的长度</span><br><span class="hljs-keyword">public</span> ByteBuffer <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] dst)</span> &#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">// 批量将缓冲区数据传递到 dst 数组中</span><br><span class="hljs-keyword">public</span> ByteBuffer <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] dst, <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> length)</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以将缓冲区的数据传输到 Channel 中：</p><ol><li>通过 FileChannel 将数据写到文件中</li><li>通过 SocketChannel 将数据写入网络，发送到远程机器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">write</span> <span class="hljs-operator">=</span> channel.write(buffer);<br></code></pre></td></tr></table></figure><h2 id="mark-reset"><a href="#mark-reset" class="headerlink" title="mark(), reset()"></a>mark(), reset()</h2><p>mark 用于临时保存 position 的值，每次调用 mark() 方法都会将 position 赋值给 mark。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Buffer <span class="hljs-title function_">mark</span><span class="hljs-params">()</span> &#123;<br>    mark = position;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>reset() 方法就是将 position 赋值到上次 mark 的位置上（也就是上一次调用 mark() 方法的时候），通过 mark(), reset() 两个方法的配合，我们可以重复读取某个区间的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Buffer <span class="hljs-title function_">reset</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> mark;<br>    <span class="hljs-keyword">if</span> (m &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidMarkException</span>();<br>    position = m;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意 mark 构造初始化时数值是 -1，如果 &gt;&#x3D; 0 则表示可以读取。</p><h2 id="rewind-clear-compact"><a href="#rewind-clear-compact" class="headerlink" title="rewind(), clear(), compact()"></a>rewind(), clear(), compact()</h2><p>rewind() 重置 position 为 0。通常在 channel-write 和 get 前调用此方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Buffer <span class="hljs-title function_">rewind</span><span class="hljs-params">()</span> &#123;<br>    position = <span class="hljs-number">0</span>;<br>    mark = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>clear() 会重置 position，将 limit 设置为最大值 capacity，并将 mark 置成 -1。通常在 channel-read 和填充此 buffer 时，会先调用此方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Buffer <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>    position = <span class="hljs-number">0</span>;<br>    limit = capacity;<br>    mark = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>compact() 方法并不常用，忽略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> ByteBuffer <span class="hljs-title function_">compact</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><h2 id="恒等式"><a href="#恒等式" class="headerlink" title="恒等式"></a>恒等式</h2><p>mark, position, limit和 capacity 永远遵循以下关系：</p><pre><code class="hljs">0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</code></pre><p>新创建的 buffer position &#x3D; 0，mark 是未定义的（-1）。limit 的初始值可能是 0，也可能是构造时传入的其他值。新分配的缓冲区元素都初始化为 0。</p><h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><p>Channel 是 I&#x2F;O 操作的「桥梁」。Channel 可以是对硬件设备、文件、网络套接字、程序组件等实体的连接，该实体能够执行不同的 I&#x2F;O 操作（读取或写入）。</p><p>Channel 只有 2 种状态：开启和关闭。在创建时就是开启的，一旦关闭就不会再回到打开状态。Channel 一旦关闭，任何对 Channel 调用的 I&#x2F;O 操作都会抛出 ClosedChannelException 异常，可以通过方法 isOpen() 来检测 Channel 是否开启。</p><p>Channel 接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Channel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Closeable</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOpen</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2019-10-14-114136.png"></p><ul><li>FileChannel：文件通道，用于文件读写</li><li>DatagramChannel：UDP 连接</li><li>SocketChannel：TCP 连接通道，TCP 客户端</li><li>ServerSocketChannel：TCP 对应的服务端，用于监听某个端口进来的请求</li></ul><p>读操作：将数据从 Channel 读取到 Buffer 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> channel.read(buffer);<br></code></pre></td></tr></table></figure><p>写操作：将数据从 Buffer 写入到 Channel 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">write</span> <span class="hljs-operator">=</span> channel.write(buffer);<br></code></pre></td></tr></table></figure><h2 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h2><p>读取文件内容，详细说明见注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFileChannelRead</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 获取文件的 FileChannel</span><br>    <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;/abc&quot;</span>);<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> fileInputStream.getChannel();<br><br>    <span class="hljs-comment">// 创建 ByteBuffer</span><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">30</span>);<br><br>    <span class="hljs-comment">// 将文件内容读取到 buffer 中</span><br>    channel.read(buffer);<br><br>    <span class="hljs-comment">// buffer 从写模式，切换到读模式</span><br>    buffer.flip();<br><br>    <span class="hljs-comment">// 打印 buffer（文件）的内容</span><br>    <span class="hljs-keyword">while</span> (buffer.hasRemaining()) &#123;<br>        System.out.print((<span class="hljs-type">char</span>)buffer.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>写入文件内容，详细说明见注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFileChannelWrite</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 获取文件的 FileChannel</span><br>    <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;/abc&quot;</span>);<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> fileOutputStream.getChannel();<br><br>    <span class="hljs-comment">// 创建 ByteBuffer</span><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">30</span>);<br>    buffer.put(<span class="hljs-string">&quot;123456&quot;</span>.getBytes());<br><br>    <span class="hljs-comment">// Buffer 切换为读模式</span><br>    buffer.flip();<br>    <span class="hljs-keyword">while</span>(buffer.hasRemaining()) &#123;<br>        <span class="hljs-comment">// 将 Buffer 中的内容写入文件</span><br>        channel.write(buffer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h2><p>SocketChannel 顾名思义，就是 Socket 的 Channel，能够读写 Socket。操作缓冲区同 FileChannel。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSocketChannel</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> SocketChannel.open(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">80</span>));<br><br>    <span class="hljs-comment">// 创建 ByteBuffer</span><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">30</span>);<br>    <span class="hljs-comment">// 读取数据</span><br>    socketChannel.read(buffer);<br><br>    <span class="hljs-comment">// 写入数据到网络连接中</span><br>    <span class="hljs-keyword">while</span>(buffer.hasRemaining()) &#123;<br>        socketChannel.write(buffer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h2><p>ServerSocketChannel 用于监听机器端口，管理从这个端口进来的 TCP 连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实例化</span><br><span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br><span class="hljs-comment">// 监听 8080 端口</span><br>serverSocketChannel.socket().bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 一旦有一个 TCP 连接进来，就对应创建一个 SocketChannel 进行处理</span><br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> serverSocketChannel.accept();<br>&#125;<br></code></pre></td></tr></table></figure><pre><code class="hljs">这里可以看到 SocketChannel 的另一种实例化方式，SocketChannel 可读可写，操作一个网络通道。</code></pre><p>ServerSocketChannel 不和 Buffer 打交道了，因为它并不实际处理数据，它一旦接收到请求后，实例化 SocketChannel，之后在这个连接通道上的数据传递它就不管了，因为它需要继续监听端口，等待下一个连接。</p><h2 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h2><p>处理 UDP 连接（面向无连接的，不需要握手，只要把数据丢出去就好了），操作字节数组，同 FileChannel，不作过多介绍。</p><h1 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h1><p>Selector 是非阻塞的，<strong>多路复用</strong>就是基于 Selector 的，Java 能通过 Selector 实现一个线程管理多个 Channel。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ol><li>开启一个 Selector（经常被翻译成选择器、多路复用器）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br></code></pre></td></tr></table></figure><ol start="2"><li>将 Channel 注册到 Selector 上。前面我们说了，Selector 建立在非阻塞模式之上，所以注册到 Selector 的 Channel 必须要支持非阻塞模式，<strong>FileChannel 不支持非阻塞</strong>，我们这里讨论最常见的 SocketChannel 和 ServerSocketChannel。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将通道设置为非阻塞模式，因为默认都是阻塞模式的</span><br>channel.configureBlocking(<span class="hljs-literal">false</span>);<br><span class="hljs-comment">// 注册</span><br><span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> channel.register(selector, SelectionKey.OP_READ);<br></code></pre></td></tr></table></figure><p>register 方法的第二个参数是 SelectionKey 中的常量，代表要监听感兴趣的事件，总共有以下 4 种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通道有数据可读</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OP_READ</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 可以向通道中写数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OP_WRITE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>;<br><span class="hljs-comment">// 成功建立 TCP 连接</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OP_CONNECT</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>;<br><span class="hljs-comment">// 接受 TCP 连接</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OP_ACCEPT</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><p>注册方法返回值是 SelectionKey 实例，它包含了 Channel 和 Selector 信息，也包括了一个叫做 Interest Set 的信息，即我们设置的我们感兴趣的正在监听的事件集合。</p><ol start="3"><li>调用 select() 方法获取通道信息。用于判断是否有我们感兴趣的事件已经发生了。</li></ol><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br><br>channel.configureBlocking(<span class="hljs-literal">false</span>);<br><br><span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> channel.register(selector, SelectionKey.OP_READ);<br><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-comment">// 判断是否有事件准备好</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">readyChannels</span> <span class="hljs-operator">=</span> selector.select();<br>  <span class="hljs-keyword">if</span>(readyChannels == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><br>  <span class="hljs-comment">// 遍历</span><br>  Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();<br>  Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();<br>  <span class="hljs-keyword">while</span>(keyIterator.hasNext()) &#123;<br>    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyIterator.next();<br><br>    <span class="hljs-keyword">if</span>(key.isAcceptable()) &#123;<br>        <span class="hljs-comment">// a connection was accepted by a ServerSocketChannel.</span><br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isConnectable()) &#123;<br>        <span class="hljs-comment">// a connection was established with a remote server.</span><br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>        <span class="hljs-comment">// a channel is ready for reading</span><br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isWritable()) &#123;<br>        <span class="hljs-comment">// a channel is ready for writing</span><br>    &#125;<br><br>    keyIterator.remove();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="I-O-多路复用原理"><a href="#I-O-多路复用原理" class="headerlink" title="I&#x2F;O 多路复用原理"></a>I&#x2F;O 多路复用原理</h2><p>这里放上一张原来总结的思维导图截图，具体原理需要另行写篇文章。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2019-10-14-123829.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>Buffer 和数组差不多，它有 position、limit、capacity 几个重要属性。put() 一下数据、flip() 切换到读模式、然后用 get() 获取数据、clear() 一下清空数据、重新回到 put() 写入数据。</p></li><li><p>Channel 基本上只和 Buffer 打交道，最重要的接口就是 channel.read(buffer) 和 channel.write(buffer)。</p></li><li><p>Selector 用于实现非阻塞 IO，这里仅仅介绍接口使用，后续请关注非阻塞 IO 的介绍。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java ClassLoader</title>
    <link href="/2021/09/13/Java%20ClassLoader/"/>
    <url>/2021/09/13/Java%20ClassLoader/</url>
    
    <content type="html"><![CDATA[<h1 id="ClassLoader-简介"><a href="#ClassLoader-简介" class="headerlink" title="ClassLoader 简介"></a>ClassLoader 简介</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>一个完整的 Java 应用程序由若干个 Java Class 文件组成，当程序在运行时，会通过一个入口函数来调用系统的各个功能，这些功能都被存放在不同的 Class 文件中。</p><p>因此，系统在运行时经常会调用不同 Class 文件中被定义的方法，如果某个 Class 文件不存在，则系统会抛出 ClassNotFoundException 异常。</p><p>系统程序在启动时，不会一次性加载所有程序要使用的 Class 文件到内存中，而是根据程序需要，通过 Java 的类加载机制动态将需要使用的 Class 文件加载到内存中；只有当某个 Class 文件被加载到内存后，该文件才能被其他 Class 文件调用。</p><p>这个 “类加载机制“ 就是 ClassLoader , 他的作用是动态加载 Java Class 文件到 JVM 的内存空间中，让 JVM 能够调用并执行 Class 文件中的字节码。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210913104947.png?x-oss-process=style/yano"></p><p>上面的流程图即为 ClassLoaderTest.java 是如何被动态加载到 JVM 内存空间的，类加载的过程主要由 5 步组成。</p><ul><li><code>加载阶段</code> ：该阶段是类加载过程的第一个阶段，会通过一个类的完全限定名称来查找类的字节码文件，并利用字节码文件来创建一个 Class 对象。</li><li><code>验证阶段</code> ：该阶段是类加载过程的第二个阶段，其目的在于确保 Class 文件中包含的字节流信息符合当前 Java 虚拟机的要求。</li><li><code>准备阶段</code> ： 该阶段会为类变量在方法区中分配内存空间并设定初始值 ( 这里 “类变量” 为 static 修饰符修饰的字段变量 )<ul><li>不会分配并初始化用 final 修饰符修饰的 static 变量，因为该类变量在编译时就会被分配内存空间。</li><li>不会分配并初始化实例变量，因为实例变量会随对象一起分配到 Java 堆中，而不是 Java 方法区。</li></ul></li><li><code>解析阶段</code> ：该阶段会将常量池中的符号引用替换为直接引用。</li><li><code>初始化阶段</code> ：该阶段是类加载的最后阶段，如果当前类具有父类，则对其进行初始化，同时为类变量赋予正确的值。</li></ul><h2 id="ClassLoader-官方文档"><a href="#ClassLoader-官方文档" class="headerlink" title="ClassLoader 官方文档"></a>ClassLoader 官方文档</h2><p><a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/ClassLoader.html">Class ClassLoader(Java SE 15 &amp; JDK 15)</a></p><p>A class loader is an object that is responsible for loading classes. The class ClassLoader is an abstract class. Given the binary name of a class, a class loader should attempt to locate or generate data that constitutes a definition for the class. A typical strategy is to transform the name into a file name and then read a “class file” of that name from a file system.<br>Every Class object contains a reference to the ClassLoader that defined it.</p><p>Class objects for array classes are not created by class loaders, but are created automatically as required by the Java runtime. The class loader for an array class, as returned by Class.getClassLoader() is the same as the class loader for its element type; if the element type is a primitive type, then the array class has no class loader.</p><p>Applications implement subclasses of ClassLoader in order to extend the manner in which the Java virtual machine dynamically loads classes.</p><h2 id="加载器的类型"><a href="#加载器的类型" class="headerlink" title="加载器的类型"></a>加载器的类型</h2><ul><li>启动类加载器 BootstrapClassLoader：用于加载启动的基础模块类，JDK 核心类</li><li>平台类加载器 ( jdk8 以上） PlatformClassLoader：平台相关的模块</li><li>启动类加载器 AppClassLoader：应用级别的模块</li></ul><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210913105430.png?x-oss-process=style/yano"></p><h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><p>使用组合，除了启动类加载器外，其余的类加载器都应该有自己的父加载器。我们知道了 JVM 默认使用了三种类加载器，分别加载不同目录下的 Java 类库。当程序需要某个类时，JVM 会按需将生成的 Class 文件加载到内存中，生成对应实例对象。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210913105543.png?x-oss-process=style/yano"></p><p>顾名思义，该机制的实现分为两个阶段，即上图中的 “委托阶段” 与 “派发阶段”。java.lang.ClassLoader#loadClass 流程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve)<br>    <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// First, check if the class has already been loaded</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>                    c = parent.loadClass(name, <span class="hljs-literal">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">// from the non-null parent class loader</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// If still not found, then invoke findClass in order</span><br>                <span class="hljs-comment">// to find the class.</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.nanoTime();<br>                c = findClass(name);<br><br>                <span class="hljs-comment">// this is the defining class loader; record the stats</span><br>                PerfCounter.getParentDelegationTime().addTime(t1 - t0);<br>                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>                PerfCounter.getFindClasses().increment();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul><li><code>避免类被重复加载</code>，父加载器加载某个类之后，子加载器不会重复加载</li><li><code>保证 Java 核心库的安全</code>。比如 java.lang 包下的核心 API，不会被类加载器重复加载，肯定是被<code>启动类加载器</code>加载。（当然自定义的类加载器能够重写 loadClass 方法，不过还是不能加载核心 API，具体在本文后面部分分析）</li></ul><h1 id="自定义-ClassLoader-类加载器"><a href="#自定义-ClassLoader-类加载器" class="headerlink" title="自定义 ClassLoader 类加载器"></a>自定义 ClassLoader 类加载器</h1><p>自定义类加载器，一共需要 2 个步骤：</p><ol><li>自定义类加载器继承 java.lang.ClassLoader.class</li><li>重写 findClass() 方法</li></ol><h2 id="自定义一个从磁盘加载的-DiskClassLoader"><a href="#自定义一个从磁盘加载的-DiskClassLoader" class="headerlink" title="自定义一个从磁盘加载的 DiskClassLoader"></a>自定义一个从磁盘加载的 DiskClassLoader</h2><p>DiskClassLoader 类中有一个 path 变量，标识应该从哪个路径加载 class。然后就是继承了 ClassLoader，重写了其中的 findClass 方法，从 path 中读取 class 文件的字节数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiskClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String path;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DiskClassLoader</span><span class="hljs-params">(String path)</span> &#123;<br>        <span class="hljs-built_in">this</span>.path = path;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getFileName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> name.lastIndexOf(<span class="hljs-string">&#x27;.&#x27;</span>);<br>        <span class="hljs-keyword">if</span> (index == -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> name + <span class="hljs-string">&quot;.class&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> name.substring(index + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;.class&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> getFileName(name);<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path, fileName);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">byte</span>[] data = FileUtils.readFileToByteArray(file);<br>            <span class="hljs-keyword">return</span> defineClass(name, data, <span class="hljs-number">0</span>, data.length);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.findClass(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后在本机的 &#x2F;Users&#x2F;yano&#x2F;tmp 目录下，新建 DiskClass 类，里面只有一个 test 方法。注意这里不能在自己的工程项目里新建文件，因为是有包名的，单独拿出 class 文件是没有办法直接使用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiskClass</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello Yano!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后 <code>javac DiskClass.java</code>，编译成字节码文件。使用 javap 命令来查看字节码：<code>javap -p DiskClass</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Compiled from <span class="hljs-string">&quot;DiskClass.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiskClass</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">DiskClass</span><span class="hljs-params">()</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>写一个测试用例，用 DiskClassLoader 去加载 &#x2F;Users&#x2F;yano&#x2F;tmp&#x2F;DiskClass.class 字节码文件，并通过反射去调用该文件的 test 方法。测试用例的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">load</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">DiskClassLoader</span> <span class="hljs-variable">diskClassLoader</span> <span class="hljs-operator">=</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">DiskClassLoader</span>(<span class="hljs-string">&quot;/Users/yano/tmp&quot;</span>);<br><br>    Class&lt;?&gt; c = diskClassLoader.loadClass(<span class="hljs-string">&quot;DiskClass&quot;</span>);<br><br>    Method[] methods = c.getDeclaredMethods();<br>    <span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>        System.out.println(<span class="hljs-string">&quot;methods: &quot;</span> + method.getName());<br>    &#125;<br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> c.newInstance();<br>    <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-literal">null</span>);<br>    method.invoke(o, <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果如下，我们可以看到 class 字节码已经加载成功，并且能够通过反射调用 test 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">methods: test<br>Hello Yano!<br></code></pre></td></tr></table></figure><h2 id="自定义一个加解密的字节码类加载器"><a href="#自定义一个加解密的字节码类加载器" class="headerlink" title="自定义一个加解密的字节码类加载器"></a>自定义一个加解密的字节码类加载器</h2><p>自定义类加载器的一个好处，是我们可以自由操作要加载的字节码。比如第三方 jar 包或者比较机密核心的 API，我们都可以提供加密后的字节码，然后自定义类加载器解密字节码。</p><p>我们使用文中上一小节中的 DiskClass.class，对齐进行加密，然后输出到&#x2F;Users&#x2F;yano&#x2F;tmp 目录下，并把加密后的字节码保存到 EncryptDiskClass.class 文件中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EncryptClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/Users/yano/tmp/DiskClass.class&quot;</span>);<br>        <span class="hljs-type">File</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/Users/yano/tmp/EncryptDiskClass.class&quot;</span>);<br>        encrypt(in, out);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">encrypt</span><span class="hljs-params">(File in, File out)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">byte</span>[] bytes = FileUtils.readFileToByteArray(in);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bytes.length; i++) &#123;<br>            bytes[i] = (<span class="hljs-type">byte</span>) (bytes[i] ^ <span class="hljs-number">0XFF</span>);<br>        &#125;<br>        FileUtils.writeByteArrayToFile(out, bytes);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>核心加密代码就是<code> bytes[i] = (byte) (bytes[i] ^ 0XFF)</code>，对字节码的每一位进行异或。我们使用 javap 命令，查看生成的字节码文件，发现已经无法正常解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">javap -p EncryptDiskClass<br>错误：读取 EncryptDiskClass 的常量池时出错：unexpected tag at #<span class="hljs-number">1</span>: <span class="hljs-number">245</span><br></code></pre></td></tr></table></figure><p>DecryptClassLoader 代码如下，思路就是读取加密的 class 字节码，然后解密。解密的方法还是 <code>bytes[i] = (byte) (decryptBytes[i] ^ 0XFF)</code>，同时 defineClass 方法的 name 传参需要去掉前面的 Encrypt。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DecryptClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br>    <span class="hljs-keyword">private</span> String path;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DecryptClassLoader</span><span class="hljs-params">(String path)</span> &#123;<br>        <span class="hljs-built_in">this</span>.path = path;<br>    &#125;<br><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) &#123;<br>        <span class="hljs-type">byte</span>[] classData = getClassData(name);<br>        <span class="hljs-keyword">return</span> defineClass(<span class="hljs-string">&quot;DiskClass&quot;</span>, classData, <span class="hljs-number">0</span>, classData.length);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] getClassData(String className) <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">decryptFilePath</span> <span class="hljs-operator">=</span> path + className + <span class="hljs-string">&quot;.class&quot;</span>;<br>        <span class="hljs-type">byte</span>[] decryptBytes = FileUtils.readFileToByteArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(decryptFilePath));<br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[decryptBytes.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; decryptBytes.length; i++) &#123;<br>            bytes[i] = (<span class="hljs-type">byte</span>) (decryptBytes[i] ^ <span class="hljs-number">0XFF</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> bytes;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试用例跟上面的没有太大区别，就是换了下 ClassLoader 和需要加载的字节码文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrypt</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">DecryptClassLoader</span> <span class="hljs-variable">decryptClassLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DecryptClassLoader</span>(<span class="hljs-string">&quot;/Users/yano/tmp/&quot;</span>);<br>    Class&lt;?&gt; c = decryptClassLoader.loadClass(<span class="hljs-string">&quot;EncryptDiskClass&quot;</span>);<br><br>    Method[] methods = c.getDeclaredMethods();<br>    <span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>        System.out.println(<span class="hljs-string">&quot;methods: &quot;</span> + method.getName());<br>    &#125;<br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> c.newInstance();<br>    <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-literal">null</span>);<br>    method.invoke(o, <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>查看输出结果符合预期，正确加载了加密的字节码文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">methods: test<br>Hello Yano!<br></code></pre></td></tr></table></figure><h1 id="自定义的类加载器，能加载-java-lang-包的核心-API-吗？"><a href="#自定义的类加载器，能加载-java-lang-包的核心-API-吗？" class="headerlink" title="自定义的类加载器，能加载 java.lang 包的核心 API 吗？"></a>自定义的类加载器，能加载 java.lang 包的核心 API 吗？</h1><p>有一个灵魂拷问：我们能自定义一个 String 类，然后去加载这个类吗？</p><p>从 JVM 的安全性和常理来说，肯定是不能的。但是这个问题要怎么验证呢？里面的原理究竟是什么样的？</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>我们可以在项目中，新建 <code>java.lang</code> 包，写一个 String 方法：</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210913172156.png?x-oss-process=style/yano"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>javac 这个自定义的 String 类，我们发现会报下面的错误：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">javac </span>String.<span class="hljs-keyword">java</span><br><span class="hljs-keyword"></span><span class="hljs-symbol">String.java:</span><span class="hljs-number">1</span>: 错误：程序包已存在于另一个模块中：<span class="hljs-keyword">java.base</span><br><span class="hljs-keyword"></span>package <span class="hljs-keyword">java.lang;</span><br><span class="hljs-keyword"></span>^<br><span class="hljs-number">1</span> 个错误<br></code></pre></td></tr></table></figure><p>发现根本就没法把自定义的 String 类编译成 class 文件。随便执行一个测试用例，发现在 build 阶段就会报错：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">java: 通过 javax<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.model</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.Elements</span><span class="hljs-selector-class">.getTypeElement</span> 在模块 <span class="hljs-string">&#x27;java.base, 未命名模块&#x27;</span> 中找到了多个名为 <span class="hljs-string">&#x27;java.lang.String&#x27;</span> 的元素。<br></code></pre></td></tr></table></figure><p>参考网络上的文章 <a href="https://blog.csdn.net/liubenlong007/article/details/88574544?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-1.no_search_link&spm=1001.2101.3001.4242">java 类加载机制：到底能不能自己自定义 java.lang.String 类</a>，说是 JDK 8 及以前版本能编译，但是 JDK 11 无法编译。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>（结论有些仓促，等有时间再补充）</p><ul><li>JVM 不允许用户自定义 java.lang 包</li><li>JDK 11 开始，用户自定义 java.lang 包后，直接会编译不通过</li><li>如果想打破双亲委派模型，重写 loadClass 方法，但是即使重写了，也无法覆盖加载 JDK 的核心 API</li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java Lambda 表达式源码分析</title>
    <link href="/2021/08/18/Java%20Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2021/08/18/Java%20Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>Lambda 表达式是什么？JVM 内部究竟是如何实现 Lambda 表达式的？为什么要这样实现？</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>下面的例子中，<code>() -&gt; System.out.println(&quot;1&quot;)</code> 就是一个 Lambda 表达式。Java 8 中每一个 Lambda 表达式必须有一个函数式接口与之对应。Lambda 表达式就是函数式接口的一个实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test0</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<br>    runnable.run();<br><br>    ToIntBiFunction&lt;Integer, Integer&gt; function = (n1, n2) -&gt; n1 + n2;<br>    System.out.println(function.applyAsInt(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br><br>    ToIntBiFunction&lt;Integer, Integer&gt; function2 = Integer::sum;<br>    System.out.println(function2.applyAsInt(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>大致形式就是 <code>(param1, param2, param3, param4…) -&gt; &#123; doing…… &#125;;</code></p><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>首先要从 FunctionalInterface 注解讲起，详情见 <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/FunctionalInterface.html">Annotation Type FunctionalInterface</a>。</p><blockquote><p>An informative annotation type used to indicate that an interface type declaration is intended to be a functional interface as defined by the Java Language Specification. Conceptually, a functional interface has exactly one abstract method. Since default methods have an implementation, they are not abstract. If an interface declares an abstract method overriding one of the public methods of java.lang.Object, that also does not count toward the interface’s abstract method count since any implementation of the interface will have an implementation from java.lang.Object or elsewhere.</p></blockquote><p>简单总结一下函数式接口的特征：</p><ul><li>FunctionalInterface 注解标注一个函数式接口，不能标注类，方法，枚举，属性这些。</li><li>如果接口被标注了 @FunctionalInterface，这个类就必须符合函数式接口的规范。</li><li>即使一个接口没有标注 @FunctionalInterface，如果这个接口满足函数式接口规则，依旧可以被当作函数式接口。</li></ul><p>注意：interface 中重写 Object 类中的抽象方法，不会增加接口的方法数，因为接口的实现类都是 Object 的子类。</p><p>我们可以看到 Runnable 接口，里面只有一个抽象方法 <code>run()</code>，则这个接口就是一个函数式接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>所谓方法引用，是指如果某个方法签名和接口恰好一致，就可以直接传入方法引用。文章开头的示例中，下面这块代码就是方法引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ToIntBiFunction&lt;Integer, Integer&gt; function2 = Integer::sum;<br></code></pre></td></tr></table></figure><p>java.lang.Integer#sum 的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p>比如我们计算一个 Stream 的和，可以直接传入 <code>Integer::sum</code> 这个方法引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> IntStream.range(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>).boxed().reduce(Integer::sum).get();<br>    System.out.println(sum);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码中，为什么可以直接在 reduce 方法中传入 <code>Integer::sum</code> 这个方法引用呢？这是因为 reduce 方法的入参就是 <code>BinaryOperator</code> 的函数式接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;T&gt; <span class="hljs-title function_">reduce</span><span class="hljs-params">(BinaryOperator&lt;T&gt; accumulator)</span>;<br></code></pre></td></tr></table></figure><p><code>BinaryOperator</code> 是继承自 <code>BiFunction</code>，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BiFunction</span>&lt;T, U, R&gt; &#123;<br><br>    R <span class="hljs-title function_">apply</span><span class="hljs-params">(T t, U u)</span>;<br><br>    <span class="hljs-keyword">default</span> &lt;V&gt; BiFunction&lt;T, U, V&gt; <span class="hljs-title function_">andThen</span><span class="hljs-params">(Function&lt;? <span class="hljs-built_in">super</span> R, ? extends V&gt; after)</span> &#123;<br>        Objects.requireNonNull(after);<br>        <span class="hljs-keyword">return</span> (T t, U u) -&gt; after.apply(apply(t, u));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，只要是符合 <code>R apply(T t, U u);</code> 的方法引用，都可以传入 reduce 中。可以是上面代码中的 <code>Integer::sum</code>，也可以是 <code>Integer::max</code>。</p><h1 id="深入实现原理"><a href="#深入实现原理" class="headerlink" title="深入实现原理"></a>深入实现原理</h1><h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><p>首先写 2 个 Lambda 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaMain</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; System.out.println(<span class="hljs-string">&quot;1&quot;</span>)).start();<br>        IntStream.range(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>).boxed().filter(i -&gt; i &lt; <span class="hljs-number">3</span>).map(i -&gt; i + <span class="hljs-string">&quot;&quot;</span>).collect(Collectors.toList());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后 <code>javac LambdaMain.java</code> 编译成字节码文件，再通过 <code>javap -p LambdaMain</code> 输出 class 文件的所有类和成员，得到输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Compiled from <span class="hljs-string">&quot;LambdaMain.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>.jdk.LambdaMain &#123;<br>  <span class="hljs-keyword">public</span> test.jdk.LambdaMain();<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(java.lang.String[])</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> java.lang.String lambda$main$<span class="hljs-number">2</span>(java.lang.Integer);<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> lambda$main$<span class="hljs-number">1</span>(java.lang.Integer);<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> lambda$main$<span class="hljs-number">0</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>输出的 <code>void lambda$main$0()</code> 对应的是 <code>() -&gt; System.out.println(&quot;1&quot;)</code></li><li>输出的 <code>boolean lambda$main$1(java.lang.Integer)</code> 对应的是 <code>i -&gt; i &lt; 3</code></li><li>输出的 <code>java.lang.String lambda$main$2(java.lang.Integer)</code> 对应的是 <code>i -&gt; i + &quot;&quot;</code></li></ul><p>我们可以看出 Lambda 表达式在 Java 8 中首先会生成一个<code>私有的静态函数</code>。</p><h2 id="为什么不使用匿名内部类？"><a href="#为什么不使用匿名内部类？" class="headerlink" title="为什么不使用匿名内部类？"></a>为什么不使用匿名内部类？</h2><p>如果要在 Java 语言中实现 lambda 表达式，生成匿名内部类就可以轻松实现。但是 JDK 为什么没有这么实现呢？这是因为匿名内部类有一些缺点。</p><ol><li>每个匿名内部类都会在<code>编译时</code>创建一个对应的<code>class 文件</code>，在<code>运行时</code>不可避免的会有加载、验证、准备、解析、初始化等<code>类加载</code>过程。</li><li>每次调用都会创建一个这个<code>匿名内部类 class 的实例对象</code>，无论是有状态的（使用到了外部的变量）还是无状态（没有使用外部变量）的内部类。</li></ol><h2 id="invokedynamic"><a href="#invokedynamic" class="headerlink" title="invokedynamic"></a>invokedynamic</h2><p>本来要写文字的，但是俺发现俺总结的思维导图还挺清晰的，直接提出来吧，囧。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210820085524.png?x-oss-process=style/yano"></p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210820085748.png?x-oss-process=style/yano"></p><p>详情见 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/LambdaMetafactory.html">Class LambdaMetafactory 官方文档</a>，java.lang.invoke.LambdaMetafactory#metafactory 的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CallSite <span class="hljs-title function_">metafactory</span><span class="hljs-params">(MethodHandles.Lookup caller,</span><br><span class="hljs-params">                                    String invokedName,</span><br><span class="hljs-params">                                    MethodType invokedType,</span><br><span class="hljs-params">                                    MethodType samMethodType,</span><br><span class="hljs-params">                                    MethodHandle implMethod,</span><br><span class="hljs-params">                                    MethodType instantiatedMethodType)</span><br>        <span class="hljs-keyword">throws</span> LambdaConversionException &#123;<br>    AbstractValidatingLambdaMetafactory mf;<br>    mf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerClassLambdaMetafactory</span>(caller, invokedType,<br>                                            invokedName, samMethodType,<br>                                            implMethod, instantiatedMethodType,<br>                                            <span class="hljs-literal">false</span>, EMPTY_CLASS_ARRAY, EMPTY_MT_ARRAY);<br>    mf.validateMetafactoryArgs();<br>    <span class="hljs-keyword">return</span> mf.buildCallSite();<br>&#125;<br></code></pre></td></tr></table></figure><p>其主要的概念有如下几个：</p><ul><li>invokedynamic 字节码指令：运行时 JVM 第一次到某个地方的这个指令的时候会进行 linkage，会调用用户指定的 Bootstrap Method 来决定要执行什么方法，之后便不需要这个步骤。</li><li>Bootstrap Method: 用户可以自己编写的方法，最终需要返回一个 CallSite 对象。</li><li>CallSite: 保存 MethodHandle 的容器，里面有一个 target MethodHandle。<br>MethodHandle: 真正要执行的方法的指针。</li></ul><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210820090707.png?x-oss-process=style/yano"></p><p>测试一下 Lambda 函数生成的字节码，为了方便起见，java 代码改成如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaMain</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; System.out.println(<span class="hljs-string">&quot;1&quot;</span>)).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先编译成 class 文件，之后再反汇编 <code>javap -c -p LambdaMain</code> 看下输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">Compiled from <span class="hljs-string">&quot;LambdaMain.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>.jdk.LambdaMain &#123;<br>  <span class="hljs-keyword">public</span> test.jdk.LambdaMain();<br>    Code:<br>       <span class="hljs-number">0</span>: aload_0<br>       <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>       <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(java.lang.String[])</span>;<br>    Code:<br>       <span class="hljs-number">0</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// class java/lang/Thread</span><br>       <span class="hljs-number">3</span>: dup<br>       <span class="hljs-number">4</span>: invokedynamic #<span class="hljs-number">3</span>,  <span class="hljs-number">0</span>              <span class="hljs-comment">// InvokeDynamic #0:run:()Ljava/lang/Runnable;</span><br>       <span class="hljs-number">9</span>: invokespecial #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Method java/lang/Thread.&quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V</span><br>      <span class="hljs-number">12</span>: invokevirtual #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method java/lang/Thread.start:()V</span><br>      <span class="hljs-number">15</span>: <span class="hljs-keyword">return</span><br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> lambda$main$<span class="hljs-number">0</span>();<br>    Code:<br>       <span class="hljs-number">0</span>: getstatic     #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>       <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">7</span>                  <span class="hljs-comment">// String 1</span><br>       <span class="hljs-number">5</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>       <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 Thread 里的 Runnable 实现是通过 invokedynamic 调用的。详细情况 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.23">JVM 虚拟机规范</a>，等有时间再补充吧~~~</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Lambda 表达式在 Java 中最终编译成<code>私有的静态函数</code>，JDK 最终使用 invokedynamic 字节码指令调用。</li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://juejin.cn/post/6931614095124725773">Java–浅析函数式接口&amp;Lambda 表达式&amp;方法引用&amp;Stream API</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一文看懂Java 对象的内存</title>
    <link href="/2021/08/17/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82Java%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98/"/>
    <url>/2021/08/17/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82Java%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>本文绝大多数内容，都是直接摘自 <a href="https://www.cnblogs.com/rickiyang/p/14206724.html#:~:text=%E5%AF%B9%E8%B1%A1%E5%A4%B4%E4%BF%A1%E6%81%AF%EF%BC%9A64%20%E4%BD%8D,%E5%8E%8B%E7%BC%A9%E5%90%8E16%20%E5%AD%97%E8%8A%82%E3%80%82">高端面试必备：一个 Java 对象占用多大内存</a>，因为这篇文章写得太好了，我觉得没有必要重新写一遍了 0_o</p><h1 id="Java-对象模型"><a href="#Java-对象模型" class="headerlink" title="Java 对象模型"></a>Java 对象模型</h1><p>HotSpot JVM 使用名为 <code>oops (Ordinary Object Pointers)</code> 的数据结构来表示对象。这些 oops 等同于本地 C 指针。 <code>instanceOops</code> 是一种特殊的 oop，表示 Java 中的<code>对象实例</code>。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210817110242.png?x-oss-process=style/yano"></p><p>在 Hotspot VM 中，对象在内存中的存储布局分为 3 块区域：</p><ul><li>对象头（Header）</li><li>实例数据（Instance Data）</li><li>对齐填充（Padding）</li></ul><p>对象头又包括三部分：MarkWord、元数据指针、数组长度。</p><ul><li><code>MarkWord</code>：用于存储对象运行时的数据，好比 HashCode、锁状态标志、GC 分代年龄等。这部分在 64 位操作系统下占 8 字节，32 位操作系统下占 4 字节。</li><li><code>指针</code>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪一个类的实例。<br>这部分就涉及到指针压缩的概念，在开启指针压缩的状况下占 4 字节，未开启状况下占 8 字节。</li><li><code>数组长度</code>：这部分只有是数组对象才有，若是是非数组对象就没这部分。这部分占 4 字节。</li></ul><p>实例数据就不用说了，用于存储对象中的各类类型的字段信息（包括从父类继承来的）。</p><p>关于<code>对齐填充</code>，Java 对象的大小默认是<code>按照 8 字节对齐</code>，也就是说 Java 对象的大小必须是 8 字节的倍数。若是算到最后不够 8 字节的话，那么就会进行对齐填充。</p><p>那么为何非要进行 8 字节对齐呢？这样岂不是浪费了空间资源？</p><p>其实不然，由于 <code>CPU 进行内存访问</code>时，<code>一次寻址</code>的指针大小是 8 字节，正好也是 L1 缓存行的大小。如果不进行内存对齐，则可能出现跨缓存行的情况，这叫做 <code>缓存行污染</code>。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210817111611.png?x-oss-process=style/yano"></p><p>由于当 obj1 对象的字段被修改后，那么 CPU 在访问 obj2 对象时，必须将其重新加载到缓存行，因此影响了程序执行效率。</p><p>也就说，8 字节对齐，是为了效率的提高，以<code>空间换时间</code>的一种方案。固然你还能够 16 字节对齐，可是 8 字节是最优选择。</p><p>正如我们之前看到的，JVM 为对象进行填充，使其大小变为 8 个字节的倍数。使用这些填充后，oops 中的<code>最后三位始终为零</code>。这是因为在二进制中 8 的倍数的数字总是以 000 结尾。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210817111736.png?x-oss-process=style/yano"></p><p>由于 JVM 已经知道最后三位始终为零，因此在堆中存储那些零是没有意义的。相反假设它们存在并存储 3 个其他更重要的位，以此来模拟 35 位的内存地址。现在我们有一个带有 3 个右移零的 32 位地址，所以我们将 35 位指针压缩成 32 位指针。这意味着我们可以在不使用 64 位引用的情况下使用最多 <code>32 GB</code>。</p><h1 id="基本类型占用存储空间和指针压缩"><a href="#基本类型占用存储空间和指针压缩" class="headerlink" title="基本类型占用存储空间和指针压缩"></a>基本类型占用存储空间和指针压缩</h1><h2 id="基础对象占用存储空间"><a href="#基础对象占用存储空间" class="headerlink" title="基础对象占用存储空间"></a>基础对象占用存储空间</h2><p>Java 基础对象在内存中占用的空间如下：</p><table><thead><tr><th>类型</th><th>占用空间 (byte)</th></tr></thead><tbody><tr><td>boolean</td><td>1</td></tr><tr><td>byte</td><td>1</td></tr><tr><td>short</td><td>2</td></tr><tr><td>char</td><td>2</td></tr><tr><td>int</td><td>4</td></tr><tr><td>float</td><td>4</td></tr><tr><td>long</td><td>8</td></tr><tr><td>double</td><td>8</td></tr></tbody></table><p>另外，<code>引用类型</code>在 32 位系统上每个引用对象占用 4 byte，在 64 位系统上每个引用对象占用 8 byte。</p><h2 id="Java-中基础数据类型是在栈上分配还是在堆上分配？"><a href="#Java-中基础数据类型是在栈上分配还是在堆上分配？" class="headerlink" title="Java 中基础数据类型是在栈上分配还是在堆上分配？"></a>Java 中基础数据类型是在栈上分配还是在堆上分配？</h2><p>我们继续深究一下，基本数据类占用内存大小是固定的，那具体是在哪分配的呢，是在堆还是栈还是方法区？大家不妨想想看！ 要解答这个问题，首先要看这个数据类型在哪里定义的，有以下三种情况。</p><ul><li>如果在<code>方法体内</code>定义的，这时候就是在<code>栈</code>上分配的</li><li>如果是<code>类的成员变量</code>，这时候就是在<code>堆</code>上分配的</li><li>如果是<code>类的静态成员变量</code>，在<code>方法区</code>上分配的</li></ul><h2 id="指针压缩"><a href="#指针压缩" class="headerlink" title="指针压缩"></a>指针压缩</h2><p>引用类型在 64 位系统上占用 8 个字节，虽然一个并不大，但是耐不住多。</p><p>所以为了解决这个问题，JDK 1.6 开始 64 bit JVM 正式支持了 <code>-XX:+UseCompressedOops</code> （需要 jdk1.6.0_14) ，这个参数可以压缩指针。</p><p>启用 CompressOops 后，会压缩的对象包括：</p><ul><li>对象的全局静态变量（即类属性）；</li><li>对象头信息：64 位系统下，原生对象头大小为 16 字节，压缩后为 12 字节；</li><li>对象的引用类型：64 位系统下，引用类型本身大小为 8 字节，压缩后为 4 字节；</li><li>对象数组类型：64 位平台下，数组类型本身大小为 24 字节，压缩后 16 字节。</li></ul><p>当然压缩也不是万能的，针对一些特殊类型的指针 JVM 是不会优化的。 比如：</p><ul><li>指向非 Heap 的对象指针</li><li>局部变量、传参、返回值、NULL 指针。</li></ul><h2 id="CompressedOops-工作原理"><a href="#CompressedOops-工作原理" class="headerlink" title="CompressedOops 工作原理"></a>CompressedOops 工作原理</h2><p>32 位内最多可以表示 4GB，64 位地址为 堆的基地址 + 偏移量，当堆内存 &lt; 32GB 时候，在压缩过程中，把 偏移量 &#x2F; 8 后保存到 32 位地址。在解压再把 32 位地址放大 8 倍，所以启用 CompressedOops 的条件是堆内存要在 4GB * 8&#x3D;32GB 以内。</p><h1 id="Java-对象到底占用多大内存"><a href="#Java-对象到底占用多大内存" class="headerlink" title="Java 对象到底占用多大内存"></a>Java 对象到底占用多大内存</h1><p>前面我们分析了 Java 对象到底都包含哪些东西，所以现在我们可以开始剖析一个 Java 对象到底占用多大内存。</p><p>由于现在基本都是 64 位的虚拟机，所以后面的讨论都是基于 64 位虚拟机。 首先记住公式，对象由 对象头 + 实例数据 + padding 填充字节组成，虚拟机规范要求对象所占内存必须是 8 的倍数，padding 就是干这个的。</p><p>上面说过对象头由 Markword + 类指针 kclass（该指针指向该类型在方法区的元类型） 组成。</p><h2 id="JDK-分析-JVM-对象布局工具"><a href="#JDK-分析-JVM-对象布局工具" class="headerlink" title="JDK 分析 JVM 对象布局工具"></a>JDK 分析 JVM 对象布局工具</h2><p>JDK 提供了一个工具，<code>JOL</code> 全称为 <code>Java Object Layout</code>，是分析 JVM 中对象布局的工具，该工具大量使用了 Unsafe、JVMTI 来解码布局情况。下面我们就使用这个工具来获取一个 Java 对象的大小。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.openjdk.jol<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jol-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="测试空对象"><a href="#测试空对象" class="headerlink" title="测试空对象"></a>测试空对象</h2><p>创建一个空的对象 A，里面什么都没有。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testEmptyClass</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ClassLayout</span> <span class="hljs-variable">classLayout</span> <span class="hljs-operator">=</span> ClassLayout.parseInstance(<span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>());<br>    System.out.println(classLayout.toPrintable());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="启用-oop"><a href="#启用-oop" class="headerlink" title="启用 oop"></a>启用 oop</h3><p>首先看一下启用了 oop 的内存分布，我们在单元测试的启动参数中，加入<code>-XX:+UseCompressedOops</code>：</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210817142450.png?x-oss-process=style/yano"></p><p>执行单元测试，输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">test.jdk.ClassSizeTest$A object internals:<br>OFF  SZ   TYPE DESCRIPTION               VALUE<br>  <span class="hljs-number">0</span>   <span class="hljs-number">8</span>        (object header: mark)     <span class="hljs-number">0x0000000000000005</span> (biasable; age: <span class="hljs-number">0</span>)<br>  <span class="hljs-number">8</span>   <span class="hljs-number">4</span>        (object header: class)    <span class="hljs-number">0x08014b4f</span><br> <span class="hljs-number">12</span>   <span class="hljs-number">4</span>        (object alignment gap)    <br>Instance size: <span class="hljs-number">16</span> bytes<br>Space losses: <span class="hljs-number">0</span> bytes internal + <span class="hljs-number">4</span> <span class="hljs-type">bytes</span> <span class="hljs-variable">external</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span> bytes total<br></code></pre></td></tr></table></figure><p>可以看出 class A 的对象实例，object header: mark 是 8 个字节，object header: class 是 4 个字节，由于两个加起来是 12 个字节，并不是 8 的整数倍，所以填充了 4 个字节，最终对象实例占用了 16 个字节。</p><h3 id="禁用-oop"><a href="#禁用-oop" class="headerlink" title="禁用 oop"></a>禁用 oop</h3><p>接着看一下禁用 oop 的内存分布，单元测试的启动参数中，加入<code>-XX:-UseCompressedOops</code>（注意中间是减号，不是加号）：</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210817142804.png?x-oss-process=style/yano"></p><p>执行单元测试，输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">test.jdk.ClassSizeTest$A object internals:<br>OFF  SZ   TYPE DESCRIPTION               VALUE<br>  <span class="hljs-number">0</span>   <span class="hljs-number">8</span>        (object header: mark)     <span class="hljs-number">0x000000000000000d</span> (biasable; age: <span class="hljs-number">1</span>)<br>  <span class="hljs-number">8</span>   <span class="hljs-number">8</span>        (object header: class)    <span class="hljs-number">0x0000000232b9b0e0</span><br>Instance size: <span class="hljs-number">16</span> bytes<br>Space losses: <span class="hljs-number">0</span> bytes internal + <span class="hljs-number">0</span> <span class="hljs-type">bytes</span> <span class="hljs-variable">external</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> bytes total<br></code></pre></td></tr></table></figure><p>可以看出 class A 的对象实例，object header: mark 是 8 个字节，object header: class 也是 8 个字节，由于两个加起来是 16 个字节，是 8 的整数倍，所以没有填充，最终对象实例占用了 16 个字节，没有空间损失。</p><h2 id="测试复杂对象"><a href="#测试复杂对象" class="headerlink" title="测试复杂对象"></a>测试复杂对象</h2><p>这次对象复杂一点，里面有 4 个变量：占 4 字节的 int 型，占 1 个字节的布尔型，占 8 个字节的 double 型，占 1 个字节的布尔型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">boolean</span> b;<br>    <span class="hljs-type">double</span> c;<br>    <span class="hljs-type">boolean</span> d;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试的单元方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testClass</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ClassLayout</span> <span class="hljs-variable">classLayout</span> <span class="hljs-operator">=</span> ClassLayout.parseInstance(<span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>());<br>    System.out.println(classLayout.toPrintable());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="启用-oop-1"><a href="#启用-oop-1" class="headerlink" title="启用 oop"></a>启用 oop</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">test.jdk.ClassSizeTest$B object internals:<br>OFF  SZ      TYPE DESCRIPTION               VALUE<br>  <span class="hljs-number">0</span>   <span class="hljs-number">8</span>           (object header: mark)     <span class="hljs-number">0x0000000000000005</span> (biasable; age: <span class="hljs-number">0</span>)<br>  <span class="hljs-number">8</span>   <span class="hljs-number">4</span>           (object header: class)    <span class="hljs-number">0x08016f76</span><br> <span class="hljs-number">12</span>   <span class="hljs-number">4</span>       <span class="hljs-type">int</span> B.a                       <span class="hljs-number">0</span><br> <span class="hljs-number">16</span>   <span class="hljs-number">8</span>    <span class="hljs-type">double</span> B.c                       <span class="hljs-number">0.0</span><br> <span class="hljs-number">24</span>   <span class="hljs-number">1</span>   <span class="hljs-type">boolean</span> B.b                       <span class="hljs-literal">false</span><br> <span class="hljs-number">25</span>   <span class="hljs-number">1</span>   <span class="hljs-type">boolean</span> B.d                       <span class="hljs-literal">false</span><br> <span class="hljs-number">26</span>   <span class="hljs-number">6</span>           (object alignment gap)    <br>Instance size: <span class="hljs-number">32</span> bytes<br>Space losses: <span class="hljs-number">0</span> bytes internal + <span class="hljs-number">6</span> <span class="hljs-type">bytes</span> <span class="hljs-variable">external</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span> bytes total<br></code></pre></td></tr></table></figure><p>首先可以看到，class B 对象实例内部并没有按照代码里的声明顺序，B 中有 2 个布尔值，每个都占 1 个字节，实例变量中这 2 个变量是分配在了对象的最后，这样能够节省空间。最终这个对象只浪费了 6 个字节作地址对齐。</p><h3 id="禁用-oop-1"><a href="#禁用-oop-1" class="headerlink" title="禁用 oop"></a>禁用 oop</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">test.jdk.ClassSizeTest$B object internals:<br>OFF  SZ      TYPE DESCRIPTION               VALUE<br>  <span class="hljs-number">0</span>   <span class="hljs-number">8</span>           (object header: mark)     <span class="hljs-number">0x0000000000000005</span> (biasable; age: <span class="hljs-number">0</span>)<br>  <span class="hljs-number">8</span>   <span class="hljs-number">8</span>           (object header: class)    <span class="hljs-number">0x000000023b87aac8</span><br> <span class="hljs-number">16</span>   <span class="hljs-number">8</span>    <span class="hljs-type">double</span> B.c                       <span class="hljs-number">0.0</span><br> <span class="hljs-number">24</span>   <span class="hljs-number">4</span>       <span class="hljs-type">int</span> B.a                       <span class="hljs-number">0</span><br> <span class="hljs-number">28</span>   <span class="hljs-number">1</span>   <span class="hljs-type">boolean</span> B.b                       <span class="hljs-literal">false</span><br> <span class="hljs-number">29</span>   <span class="hljs-number">1</span>   <span class="hljs-type">boolean</span> B.d                       <span class="hljs-literal">false</span><br> <span class="hljs-number">30</span>   <span class="hljs-number">2</span>           (object alignment gap)    <br>Instance size: <span class="hljs-number">32</span> bytes<br>Space losses: <span class="hljs-number">0</span> bytes internal + <span class="hljs-number">2</span> <span class="hljs-type">bytes</span> <span class="hljs-variable">external</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> bytes total<br></code></pre></td></tr></table></figure><p>写不动了，不分析了……</p><h2 id="包含对象引用的对象"><a href="#包含对象引用的对象" class="headerlink" title="包含对象引用的对象"></a>包含对象引用的对象</h2><p>在上面 class B 的基础上，再加一个引用类型~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">boolean</span> b;<br>    <span class="hljs-type">double</span> c;<br>    <span class="hljs-type">boolean</span> d;<br>    Integer e;<br>&#125;<br></code></pre></td></tr></table></figure><p>单元测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testClass2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ClassLayout</span> <span class="hljs-variable">classLayout</span> <span class="hljs-operator">=</span> ClassLayout.parseInstance(<span class="hljs-keyword">new</span> <span class="hljs-title class_">C</span>());<br>    System.out.println(classLayout.toPrintable());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="启用-oop-2"><a href="#启用-oop-2" class="headerlink" title="启用 oop"></a>启用 oop</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">test.jdk.ClassSizeTest$C object internals:<br>OFF  SZ                TYPE DESCRIPTION               VALUE<br>  <span class="hljs-number">0</span>   <span class="hljs-number">8</span>                     (object header: mark)     <span class="hljs-number">0x0000000000000005</span> (biasable; age: <span class="hljs-number">0</span>)<br>  <span class="hljs-number">8</span>   <span class="hljs-number">4</span>                     (object header: class)    <span class="hljs-number">0x08014b91</span><br> <span class="hljs-number">12</span>   <span class="hljs-number">4</span>                 <span class="hljs-type">int</span> C.a                       <span class="hljs-number">0</span><br> <span class="hljs-number">16</span>   <span class="hljs-number">8</span>              <span class="hljs-type">double</span> C.c                       <span class="hljs-number">0.0</span><br> <span class="hljs-number">24</span>   <span class="hljs-number">1</span>             <span class="hljs-type">boolean</span> C.b                       <span class="hljs-literal">false</span><br> <span class="hljs-number">25</span>   <span class="hljs-number">1</span>             <span class="hljs-type">boolean</span> C.d                       <span class="hljs-literal">false</span><br> <span class="hljs-number">26</span>   <span class="hljs-number">2</span>                     (alignment/padding gap)   <br> <span class="hljs-number">28</span>   <span class="hljs-number">4</span>   java.lang.Integer C.e                       <span class="hljs-literal">null</span><br>Instance size: <span class="hljs-number">32</span> bytes<br>Space losses: <span class="hljs-number">2</span> bytes internal + <span class="hljs-number">0</span> <span class="hljs-type">bytes</span> <span class="hljs-variable">external</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> bytes total<br></code></pre></td></tr></table></figure><p>和上面示例的区别，主要在下面这 2 行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">26</span>   <span class="hljs-number">2</span>                     (alignment/padding gap)   <br><span class="hljs-number">28</span>   <span class="hljs-number">4</span>   java.lang.Integer C.e                       <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>C 的实例对象总共占用了 32 个字节，其中内部因为对齐损失了 2 个字节，外部没有损失。Integer 对象的引用是占 4 个字节的。</p><h3 id="禁用-oop-2"><a href="#禁用-oop-2" class="headerlink" title="禁用 oop"></a>禁用 oop</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">test.jdk.ClassSizeTest$C object internals:<br>OFF  SZ                TYPE DESCRIPTION               VALUE<br>  <span class="hljs-number">0</span>   <span class="hljs-number">8</span>                     (object header: mark)     <span class="hljs-number">0x000000000000000d</span> (biasable; age: <span class="hljs-number">1</span>)<br>  <span class="hljs-number">8</span>   <span class="hljs-number">8</span>                     (object header: class)    <span class="hljs-number">0x000000023537aae8</span><br> <span class="hljs-number">16</span>   <span class="hljs-number">8</span>              <span class="hljs-type">double</span> C.c                       <span class="hljs-number">0.0</span><br> <span class="hljs-number">24</span>   <span class="hljs-number">4</span>                 <span class="hljs-type">int</span> C.a                       <span class="hljs-number">0</span><br> <span class="hljs-number">28</span>   <span class="hljs-number">1</span>             <span class="hljs-type">boolean</span> C.b                       <span class="hljs-literal">false</span><br> <span class="hljs-number">29</span>   <span class="hljs-number">1</span>             <span class="hljs-type">boolean</span> C.d                       <span class="hljs-literal">false</span><br> <span class="hljs-number">30</span>   <span class="hljs-number">2</span>                     (alignment/padding gap)   <br> <span class="hljs-number">32</span>   <span class="hljs-number">8</span>   java.lang.Integer C.e                       <span class="hljs-literal">null</span><br>Instance size: <span class="hljs-number">40</span> bytes<br>Space losses: <span class="hljs-number">2</span> bytes internal + <span class="hljs-number">0</span> <span class="hljs-type">bytes</span> <span class="hljs-variable">external</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> bytes total<br></code></pre></td></tr></table></figure><p>C 的实例对象总共占用了 40 个字节，其中内部因为对齐损失了 2 个字节，外部没有损失。Integer 对象的引用是占 8 个字节的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>引用类型大小</code>：在 64 位系统上占用 8 字节，开启指针压缩 oop 后占用 4 字节；在 32 位系统上占用 4 字节。</li><li><code>对象占用大小</code>：对象头+实例数据+padding 填充字节，对象所占字节必须是 8 的整数倍。</li><li><code>对象头大小</code>：在 64 位系统上占用 16 字节，开启指针压缩 oop 后占用 12 个字节。</li><li><code>指针压缩的对象（64 位系统）</code>：<ul><li>对象的全局静态变量</li><li>对象头信息（由 16 字节→12 字节）</li><li>对象的引用类型（由 8 字节→4 字节）</li><li>对象数组类型（由 24 字节→16 字节）</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java Agent 使用指南</title>
    <link href="/2021/07/31/Java%20Agent%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%20-%20%E7%A0%B4%E8%A7%A3%20IDEA/"/>
    <url>/2021/07/31/Java%20Agent%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%20-%20%E7%A0%B4%E8%A7%A3%20IDEA/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-Agent-是什么？"><a href="#Java-Agent-是什么？" class="headerlink" title="Java Agent 是什么？"></a>Java Agent 是什么？</h1><p>Java Agent 是一个特殊的 jar 文件，利用 JVM 的 Instrumentation API 来更改加载到 JVM 中的字节码。一共有 2 种方式：</p><ul><li>premain：使用 -javaagent 参数在 JVM 启动时静态加载代理</li><li>agentmain：使用 Java Attach API 将代理动态加载到 JVM 中</li></ul><p>需要说明的是，Oracle、OpenJDK 等 JVM 都提供了动态开启代理的机制，但是这个机制并不是强制的。本文首先介绍 Instrument 的原理，再从零到一介绍如何使用 premain 和 agentmain 更改字节码，最后再讲解通过 Java Agent 能够做什么（破解）。</p><h2 id="修改字节码的工具"><a href="#修改字节码的工具" class="headerlink" title="修改字节码的工具"></a>修改字节码的工具</h2><p><img src="https://i.loli.net/2021/07/31/1wjALliFzh8J32B.png?x-oss-process=style/yano"></p><h1 id="Instrumentation-原理"><a href="#Instrumentation-原理" class="headerlink" title="Instrumentation 原理"></a>Instrumentation 原理</h1><p>具体可参考：<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/package-summary.html">Package java.lang.instrument</a>。</p><p>instrument 的底层实现依赖于 JVMTI(JVM Tool Interface)，它是 JVM 暴露出来的一些供用户扩展的接口集合，JVMTI 是基于事件驱动的，JVM 每执行到一定的逻辑就会调用一些事件的回调接口（如果有的话），这些接口可以供开发者去扩展自己的逻辑。JVMTIAgent 是一个利用 JVMTI 暴露出来的接口提供了代理启动时加载 (agent on load)、代理通过 attach 形式加载 (agent on attach) 和代理卸载 (agent on unload) 功能的动态库。而 instrument agent 可以理解为一类 JVMTIAgent 动态库，别名是 JPLISAgent(Java Programming Language Instrumentation Services Agent)，也就是专门为 java 语言编写的插桩服务提供支持的代理。</p><h3 id="启动时加载-instrument-agent-过程"><a href="#启动时加载-instrument-agent-过程" class="headerlink" title="启动时加载 instrument agent 过程"></a><strong>启动时加载 instrument agent 过程</strong></h3><ol><li>创建并初始化 JPLISAgent；</li><li>监听 <code>VMInit</code> 事件，在 JVM 初始化完成之后做下面的事情：<ol><li>创建 InstrumentationImpl 对象 ；</li><li>监听 ClassFileLoadHook 事件 ；</li><li>调用 InstrumentationImpl 的<code>loadClassAndCallPremain</code>方法，在这个方法里会去调用 javaagent 中 MANIFEST.MF 里指定的 Premain-Class 类的 premain 方法 ；</li></ol></li><li>解析 javaagent 中 MANIFEST.MF 文件的参数，并根据这些参数来设置 JPLISAgent 里的一些内容。</li></ol><h3 id="运行时加载-instrument-agent-过程"><a href="#运行时加载-instrument-agent-过程" class="headerlink" title="运行时加载 instrument agent 过程"></a><strong>运行时加载 instrument agent 过程</strong></h3><p>通过 JVM 的 attach 机制来请求目标 JVM 加载对应的 agent，过程大致如下：</p><ol><li>创建并初始化 JPLISAgent；</li><li>解析 javaagent 里 MANIFEST.MF 里的参数；</li><li>创建 InstrumentationImpl 对象；</li><li>监听 ClassFileLoadHook 事件；</li><li>调用 InstrumentationImpl 的<code>loadClassAndCallAgentmain</code>方法，在这个方法里会去调用 javaagent 里 MANIFEST.MF 里指定的<code>Agent-Class</code>类的<code>agentmain</code>方法。</li></ol><h2 id="VirtualMachine-attach"><a href="#VirtualMachine-attach" class="headerlink" title="VirtualMachine#attach"></a>VirtualMachine#attach</h2><ol><li><p><code>VirtualMachine</code> 字面意义表示一个 Java 虚拟机，也就是程序需要监控的目标虚拟机，提供了获取系统信息（比如获取内存 dump、线程 dump，类信息统计（比如已加载的类以及实例个数等）， loadAgent，Attach 和 Detach （Attach 动作的相反行为，从 JVM 上面解除一个代理）等方法，可以实现的功能可以说非常之强大 。该类允许我们通过给 attach 方法传入一个 jvm 的 pid（进程 id)，远程连接到 jvm 上 。</p><p> 代理类注入操作只是它众多功能中的一个，通过<code>loadAgent</code>方法向 jvm 注册一个代理程序 agent，在该 agent 的代理程序中会得到一个 Instrumentation 实例，该实例可以 在 class 加载前改变 class 的字节码，也可以在 class 加载后重新加载。在调用 Instrumentation 实例的方法时，这些方法会使用 ClassFileTransformer 接口中提供的方法进行处理。</p></li><li><p><code>VirtualMachineDescriptor</code> 则是一个描述虚拟机的容器类，配合 VirtualMachine 类完成各种功能。</p></li></ol><p>attach 实现动态注入的原理如下：</p><p>通过 VirtualMachine 类的<code>attach(pid)</code>方法，便可以 attach 到一个运行中的 java 进程上，之后便可以通过<code>loadAgent(agentJarPath)</code>来将 agent 的 jar 包注入到对应的进程，然后对应的进程会调用 agentmain 方法。</p><p><img src="https://i.loli.net/2021/07/31/iXGcfU4uDSCr3AL.png?x-oss-process=style/yano"></p><p>具体使用可参考：<a href="https://docs.oracle.com/en/java/javase/11/docs/api/jdk.attach/com/sun/tools/attach/VirtualMachine.html">Class VirtualMachine</a>。基本使用方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// attach to target VM</span><br><span class="hljs-type">VirtualMachine</span> <span class="hljs-variable">vm</span> <span class="hljs-operator">=</span> VirtualMachine.attach(<span class="hljs-string">&quot;2177&quot;</span>);<br><br><span class="hljs-comment">// start management agent</span><br><span class="hljs-type">Properties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>props.put(<span class="hljs-string">&quot;com.sun.management.jmxremote.port&quot;</span>, <span class="hljs-string">&quot;5000&quot;</span>);<br>vm.startManagementAgent(props);<br><br><span class="hljs-comment">// detach</span><br>vm.detach();<br></code></pre></td></tr></table></figure><p>attach 最终会调用到 com.sun.tools.attach.spi.AttachProvider#attachVirtualMachine(java.lang.String)，实现为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> VirtualMachine <span class="hljs-title function_">attachVirtualMachine</span><span class="hljs-params">(String vmid)</span><br>    <span class="hljs-keyword">throws</span> AttachNotSupportedException, IOException<br>&#123;<br>    checkAttachPermission();<br><br>    <span class="hljs-comment">// AttachNotSupportedException will be thrown if the target VM can be determined</span><br>    <span class="hljs-comment">// to be not attachable.</span><br>    testAttachable(vmid);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VirtualMachineImpl</span>(<span class="hljs-built_in">this</span>, vmid);<br>&#125;<br></code></pre></td></tr></table></figure><p>VirtualMachineImpl 构造函数如下，核心是在两个进程之间建立一个 socket 连接进行通信，接收方 target VM 会针对不同的传入数据来做不同的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java">VirtualMachineImpl(AttachProvider provider, String vmid)<br>    <span class="hljs-keyword">throws</span> AttachNotSupportedException, IOException<br>&#123;<br>    <span class="hljs-built_in">super</span>(provider, vmid);<br><br>    <span class="hljs-comment">// This provider only understands pids</span><br>    <span class="hljs-type">int</span> pid;<br>    <span class="hljs-keyword">try</span> &#123;<br>        pid = Integer.parseInt(vmid);<br>    &#125; <span class="hljs-keyword">catch</span> (NumberFormatException x) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AttachNotSupportedException</span>(<span class="hljs-string">&quot;Invalid process identifier&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Find the socket file. If not found then we attempt to start the</span><br>    <span class="hljs-comment">// attach mechanism in the target VM by sending it a QUIT signal.</span><br>    <span class="hljs-comment">// Then we attempt to find the socket file again.</span><br>    <span class="hljs-type">File</span> <span class="hljs-variable">socket_file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(tmpdir, <span class="hljs-string">&quot;.java_pid&quot;</span> + pid);<br>    socket_path = socket_file.getPath();<br>    <span class="hljs-keyword">if</span> (!socket_file.exists()) &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> createAttachFile(pid);<br>        <span class="hljs-keyword">try</span> &#123;<br>            sendQuitTo(pid);<br><br>            <span class="hljs-comment">// give the target VM time to start the attach mechanism</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">delay_step</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">timeout</span> <span class="hljs-operator">=</span> attachTimeout();<br>            <span class="hljs-type">long</span> <span class="hljs-variable">time_spend</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>            <span class="hljs-comment">// 省略……</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            f.delete();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Check that the file owner/permission to avoid attaching to</span><br>    <span class="hljs-comment">// bogus process</span><br>    checkPermissions(socket_path);<br><br>    <span class="hljs-comment">// Check that we can connect to the process</span><br>    <span class="hljs-comment">// - this ensures we throw the permission denied error now rather than</span><br>    <span class="hljs-comment">// later when we attempt to enqueue a command.</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> socket();<br>    <span class="hljs-keyword">try</span> &#123;<br>        connect(s, socket_path);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        close(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="JVM-启动前静态-Instrument"><a href="#JVM-启动前静态-Instrument" class="headerlink" title="JVM 启动前静态 Instrument"></a>JVM 启动前静态 Instrument</h1><p>分为两步：</p><ul><li>在某个类中实现 premain 静态方法</li><li>在 META-INF&#x2F;MANIFEST.MF 中指定 Premain-Class</li></ul><p>所谓 premain，就是运行在 main 函数之前的类。在 JVM 虚拟机启动之后，main 方法执行之前，JVM 会运行 -javaagent 所指定 jar 包内 Premain-Class 内的 premain 静态方法。</p><p>直接在命令行中输入 java，可以看到命令行提示中关于 javaagent 的使用说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">-javaagent:&lt;jar 路径&gt;[=&lt;选项&gt;]<br>                  加载 Java 编程语言代理，请参阅 java.lang.instrument<br></code></pre></td></tr></table></figure><h2 id="Premain-类"><a href="#Premain-类" class="headerlink" title="Premain 类"></a>Premain 类</h2><p>编写 com.yano.Premain 类，其功能是在 test.jvm.AttachTest 类的 attachTest 方法前后分别打印一条语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Premain</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">premain</span><span class="hljs-params">(String agentArgs, Instrumentation inst)</span> &#123;<br>        inst.addTransformer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleTransformer</span>(), <span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleTransformer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ClassFileTransformer</span> &#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,<br>                ProtectionDomain protectionDomain, <span class="hljs-type">byte</span>[] classfileBuffer) <span class="hljs-keyword">throws</span> IllegalClassFormatException &#123;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;test/jvm/AttachTest&quot;</span>.equals(className)) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>                    <span class="hljs-type">CtClass</span> <span class="hljs-variable">cc</span> <span class="hljs-operator">=</span> pool.get(<span class="hljs-string">&quot;test.jvm.AttachTest&quot;</span>);<br>                    <span class="hljs-type">CtMethod</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> cc.getDeclaredMethod(<span class="hljs-string">&quot;attachTest&quot;</span>);<br><br>                    <span class="hljs-comment">// 在方法前后增加 2 行 print 语句</span><br>                    method.insertBefore(<span class="hljs-string">&quot;System.out.println(\&quot;simple agent before\&quot;);&quot;</span>);<br>                    method.insertAfter(<span class="hljs-string">&quot;System.out.println(\&quot;simple agent after\&quot;);&quot;</span>);<br><br>                    <span class="hljs-type">byte</span>[] byteCode = cc.toBytecode();<br>                    <span class="hljs-comment">// 将内存中曾经被 javassist 过的 className 对象移除</span><br>                    cc.detach();<br>                    <span class="hljs-keyword">return</span> byteCode;<br>                &#125; <span class="hljs-keyword">catch</span> (NotFoundException | CannotCompileException | IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>CtMethod 类中有各种对于方法的操作，比较常用的是 insertBefore 和 insertAfter，能够在方法体重前后增加语句（注意语句中使用到的类使用全路径名，因为我们并没有修改原类的 import）。</p><h2 id="META-INF-MANIFEST-MF-设置"><a href="#META-INF-MANIFEST-MF-设置" class="headerlink" title="META-INF&#x2F;MANIFEST.MF 设置"></a>META-INF&#x2F;MANIFEST.MF 设置</h2><p>本例直接在 maven 编译时生成 META-INF&#x2F;MANIFEST.MF，同时本例的 javaagent 需要依赖 javassist。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.yano<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>simple-agent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven-jar-plugin.version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">maven-jar-plugin.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javassist<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javassist<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.27.0-GA<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-jar-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;maven-jar-plugin.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">archive</span>&gt;</span><br>                        <span class="hljs-comment">&lt;!--自动添加 META-INF/MANIFEST.MF --&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">manifest</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">addClasspath</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">addClasspath</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">manifestEntries</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">Premain-Class</span>&gt;</span>com.yano.Premain<span class="hljs-tag">&lt;/<span class="hljs-name">Premain-Class</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">Can-Redefine-Classes</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">Can-Redefine-Classes</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">Can-Retransform-Classes</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">Can-Retransform-Classes</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">manifestEntries</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">archive</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>打包后 jar 包路径为：&#x2F;Users&#x2F;yano&#x2F;code&#x2F;simple-agent&#x2F;target&#x2F;simple-agent-1.0-SNAPSHOT.jar</p><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>启动一个 AttachTest 类，全路径为：test.jvm.AttachTest。上面编写的 SimpleTransformer 能够在 attachTest 方法前后增加两条打印语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AttachTest</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attachTest</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;attachTest start&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">10</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-comment">// ignore</span><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;attachTest end&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 VM options 中加入 javaagent 参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">-javaagent:/Users/yano/code/simple-agent/target/simple-agent-<span class="hljs-number">1.0</span>-SNAPSHOT.jar<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/07/31/YtJlPBKTZOumqIM.png?x-oss-process=style/yano"></p><h2 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h2><p>运行单元测试后的输出结果如下，可以看到在方法前后增加了 simple agent before 和 simple agent after 两条日志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">simple agent before<br>attachTest start<br>attachTest end<br>simple agent after<br></code></pre></td></tr></table></figure><h1 id="JVM-启动后动态-Instrument"><a href="#JVM-启动后动态-Instrument" class="headerlink" title="JVM 启动后动态 Instrument"></a>JVM 启动后动态 Instrument</h1><h2 id="META-INF-MANIFEST-MF-设置-1"><a href="#META-INF-MANIFEST-MF-设置-1" class="headerlink" title="META-INF&#x2F;MANIFEST.MF 设置"></a>META-INF&#x2F;MANIFEST.MF 设置</h2><p>pom 文件跟上面的设置唯一的区别在于：manifestEntries 里 Premain-Class 属性改成 Agent-Class。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-jar-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;maven-jar-plugin.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">archive</span>&gt;</span><br>                    <span class="hljs-comment">&lt;!--自动添加 META-INF/MANIFEST.MF --&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">manifest</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">addClasspath</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">addClasspath</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">manifestEntries</span>&gt;</span><br>                    <span class="hljs-comment">&lt;!-- 改动在这里！ --&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">Agent-Class</span>&gt;</span>com.yano.AgentMain<span class="hljs-tag">&lt;/<span class="hljs-name">Agent-Class</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">Can-Redefine-Classes</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">Can-Redefine-Classes</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">Can-Retransform-Classes</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">Can-Retransform-Classes</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">manifestEntries</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">archive</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="AgentMain-类"><a href="#AgentMain-类" class="headerlink" title="AgentMain 类"></a>AgentMain 类</h2><p>agentmain 的实现和 premain 有所区别，因为此时 agentmain 是动态加载的，我们想改变 test.jvm.AttachTest 类的时候，test.jvm.AttachTest 类已经被 JVM 加载并运行了。</p><p>注意点：</p><ul><li>采用 attach 机制，被代理的目标程序 VM 有可能很早之前已经启动，当然其所有类已经被加载完成，这个时候需要借助 Instrumentation#retransformClasses(Class&lt;?&gt;… classes) 让对应的类可以重新转换，从而激活重新转换的类执行 ClassFileTransformer 列表中的回调。</li><li>在 transform 方法中，需要增加 pool.appendClassPath(new LoaderClassPath(loader)); 否则会报 javassist.NotFoundException 异常。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgentMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">agentmain</span><span class="hljs-params">(String agentArgs, Instrumentation instrumentation)</span> &#123;<br>        instrumentation.addTransformer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DynamicTransformer</span>(), <span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            instrumentation.retransformClasses(Class.forName(<span class="hljs-string">&quot;test.jvm.AttachTest&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicTransformer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ClassFileTransformer</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,<br>                ProtectionDomain protectionDomain, <span class="hljs-type">byte</span>[] classfileBuffer) <span class="hljs-keyword">throws</span> IllegalClassFormatException &#123;<br>            <span class="hljs-keyword">if</span> (className.contains(<span class="hljs-string">&quot;test/jvm/AttachTest&quot;</span>)) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>                    pool.appendClassPath(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoaderClassPath</span>(loader));<br>                    <span class="hljs-type">CtClass</span> <span class="hljs-variable">cc</span> <span class="hljs-operator">=</span> pool.get(<span class="hljs-string">&quot;test.jvm.AttachTest&quot;</span>);<br>                    <span class="hljs-type">CtMethod</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> cc.getDeclaredMethod(<span class="hljs-string">&quot;simplePrint&quot;</span>);<br><br>                    <span class="hljs-comment">// 在方法前后增加 2 行 print 语句</span><br>                    method.insertBefore(<span class="hljs-string">&quot;System.out.println(\&quot;simple agent before\&quot;);&quot;</span>);<br>                    method.insertAfter(<span class="hljs-string">&quot;System.out.println(\&quot;simple agent after\&quot;);&quot;</span>);<br><br>                    <span class="hljs-keyword">return</span> cc.toBytecode();<br>                &#125; <span class="hljs-keyword">catch</span> (NotFoundException | CannotCompileException | IOException  e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> classfileBuffer;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="测试类-1"><a href="#测试类-1" class="headerlink" title="测试类"></a>测试类</h2><p>启动一个程序，每间隔 5 秒打印一个数字，5 次后结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attachDynamic</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;attachDynamic start&quot;</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">5</span>) &#123;<br>        simplePrint(i++);<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-comment">// ignore</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">simplePrint</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的 attachDynamic 单元测试启动后，启动下面的 agentMain 单元测试。列出系统所有正在运行的 VM，并过滤找到 attachDynamic 的 VM，并 attach 上去动态加载 agent jar 包；之后再 detach 释放连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">agentMain</span><span class="hljs-params">()</span> &#123;<br>    VirtualMachine.list().stream()<br>            .filter(vm -&gt; vm.displayName().contains(<span class="hljs-string">&quot;test.jvm.AttachTest,attachDynamic&quot;</span>))<br>            .findFirst().ifPresent(vmd -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">VirtualMachine</span> <span class="hljs-variable">virtualMachine</span> <span class="hljs-operator">=</span> VirtualMachine.attach(vmd.id());<br>            virtualMachine<br>                    .loadAgent(<span class="hljs-string">&quot;/Users/yano/code/simple-agent-main/target/simple-agent-main-1.0-SNAPSHOT.jar&quot;</span>);<br>            virtualMachine.detach();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="输出结果-1"><a href="#输出结果-1" class="headerlink" title="输出结果"></a>输出结果</h2><p>最终输出的结果（是在 attachDynamic 打印 0 之后，才启动的 agentMain），我们可以看到其动态更改了 simplePrint 函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">attachDynamic start<br><span class="hljs-number">0</span><br>simple agent before<br><span class="hljs-number">1</span><br>simple agent after<br>simple agent before<br><span class="hljs-number">2</span><br>simple agent after<br>simple agent before<br><span class="hljs-number">3</span><br>simple agent after<br>simple agent before<br><span class="hljs-number">4</span><br>simple agent after<br></code></pre></td></tr></table></figure><h1 id="Java-Agent-的应用"><a href="#Java-Agent-的应用" class="headerlink" title="Java Agent 的应用"></a>Java Agent 的应用</h1><p>说了这么多，Java Agent 有哪些应用呢？</p><ol><li>应用性能监控组件</li><li>Java 代码热更新工具</li><li>IDEA 破解</li><li>Arthas</li><li>各种代码增强</li></ol><h2 id="应用性能监控组件"><a href="#应用性能监控组件" class="headerlink" title="应用性能监控组件"></a>应用性能监控组件</h2><p>主要可以实现：</p><ul><li>自动捕捉所有 error 级别异常，上报 Sentry</li><li>监控服务提供的所有 Http 接口、Redis 耗时操作（细化到每一种操作命令）、HBASE 操作耗时等</li></ul><p>特点是业务代码无需关心上述逻辑，代码无侵入。</p><h2 id="Java-代码热更新工具"><a href="#Java-代码热更新工具" class="headerlink" title="Java 代码热更新工具"></a>Java 代码热更新工具</h2><p>主要可以实现 Java 代码的热更新，避免 Java 工程在 debug 阶段提交代码、编译、部署等流程（往往需要 10 分钟的时间）。</p><h2 id="IDEA-破解"><a href="#IDEA-破解" class="headerlink" title="IDEA 破解"></a>IDEA 破解</h2><p>详情见 <a href="https://juejin.cn/post/6844904039516209160">源码分析 | 咋嘞？你的 IDEA 过期了吧！加个 Jar 包就破解了，为什么？</a>。主要可以破解 IDEA，使用非社区版的功能。主要是代理 com&#x2F;jetbrains&#x2F;ls&#x2F;newLicenses&#x2F;DecodeCertificates 类，直接通过就对了。（IDEA 大版本都不一样，请支持正版）</p><p>在编写（下载）对应的 jetbrains-agent.jar 后，只需要在 IDEA 的 Help → Edit Custom VM Options 加入 java agent 代理即可。</p><p><img src="https://i.loli.net/2021/07/31/GPmlQ4SOheEu8DU.png?x-oss-process=style/yano"></p><p><img src="https://i.loli.net/2021/07/31/EUToZn54NasbR1y.png?x-oss-process=style/yano"></p><h2 id="Arthas"><a href="#Arthas" class="headerlink" title="Arthas"></a>Arthas</h2><p>详情见 <a href="https://juejin.cn/post/6904280021632974856">Arthas 原理系列（四）：字节码插装让一切变得有可能</a>。Java 程序员对 Arthas 肯定不会感到陌生，Arthas 底层当然也是 Java Agent、Instrumentation 这一套。强大之处已经有好多文章讲述了，略。</p><h2 id="各种代码增强"><a href="#各种代码增强" class="headerlink" title="各种代码增强"></a>各种代码增强</h2><p>水平有限，略。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.cnblogs.com/rickiyang/p/11368932.html">javaagent 使用指南</a></li><li><a href="https://juejin.cn/post/6844904039516209160">源码分析 | 咋嘞？你的 IDEA 过期了吧！加个 Jar 包就破解了，为什么？</a></li><li><a href="https://easyboot.xyz/posts/34402/">IDEA 通过 java-agent 实现永久破解</a></li><li><a href="https://www.baeldung.com/java-instrumentation">Guide to Java Instrumentation</a></li><li><a href="https://kstack.corp.kuaishou.com/tech/web/article/info/3429">可配置、无侵入的应用性能监控组件设计</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java资源大全中文版</title>
    <link href="/2021/07/27/Java%E8%B5%84%E6%BA%90%E5%A4%A7%E5%85%A8%E4%B8%AD%E6%96%87%E7%89%88/"/>
    <url>/2021/07/27/Java%E8%B5%84%E6%BA%90%E5%A4%A7%E5%85%A8%E4%B8%AD%E6%96%87%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>GitHub项目地址：<a href="https://github.com/jobbole/awesome-java-cn">https://github.com/jobbole/awesome-java-cn</a></p><h1 id="Java资源大全中文版"><a href="#Java资源大全中文版" class="headerlink" title="Java资源大全中文版"></a>Java资源大全中文版</h1><p>我想很多程序员应该记得 GitHub 上有一个 Awesome - XXX 系列的资源整理。<a href="https://github.com/akullpp/awesome-java">awesome-java</a> 就是 akullpp 发起维护的 Java 资源列表，内容包括：构建工具、数据库、框架、模板、安全、代码分析、日志、第三方库、书籍、Java 站点等等。伯乐在线已经把 awesome-java 资源列表翻成中文后发布于 <a href="http://www.importnew.com/14429.html">ImportNew</a>。</p><p>Awesome 系列虽然挺全，但基本只对收录的资源做了极为简要的介绍，如果有更详细的中文介绍，对相应开发者的帮助会更大。这也是我们发起这个开源项目的初衷。</p><hr><h3 id="我们要做什么？"><a href="#我们要做什么？" class="headerlink" title="我们要做什么？"></a>我们要做什么？</h3><ul><li>基于 awesome-java 资源列表，我们将对各个资源项进行编译整理。</li><li>整理后的内容，将收录在<a href="http://www.importnew.com/">伯乐在线资源频道</a>。可参考已整理的内容：<ul><li>《<a href="http://www.importnew.com/owner/">OWNER：Java配置文件解决方案</a>》</li><li>《<a href="http://www.importnew.com/spring-boot/">Spring Boot：简化Spring应用初始搭建以及开发过程</a>》</li><li>《<a href="http://www.importnew.com/sonarqube/">SonarQube：开源的代码质量管理工具</a>》</li></ul></li></ul><hr><h3 id="如何参与本项目？"><a href="#如何参与本项目？" class="headerlink" title="如何参与本项目？"></a>如何参与本项目？</h3><!-- 从下面的目录来看，本项目的工作量小不了，所以非常期待能有更多程序员一起来参与。不过加入前，有几个小要求：* 英文还不错，能读懂英文并用自己的话复述；* 在用 Java；如有兴趣，请加 QQ：50872495。加 Q 时请注明「Java大全」 --><hr><h3 id="如何为列表贡献新资源？"><a href="#如何为列表贡献新资源？" class="headerlink" title="如何为列表贡献新资源？"></a>如何为列表贡献新资源？</h3><p>欢迎大家为列表贡献高质量的新资源，提交PR时请参照以下要求：</p><ul><li>请确保推荐的资源自己使用过</li><li>提交PR时请注明推荐理由</li></ul><p>资源列表管理收到PR请求后，会定期（每周）在微博转发本周提交的PR列表，并在微博上面听取使用过这些资源的意见。确认通过后，会加入资源大全。</p><p>感谢您的贡献！</p><hr><h3 id="本项目的参与者"><a href="#本项目的参与者" class="headerlink" title="本项目的参与者"></a>本项目的参与者</h3><ul><li><p>维护者：<a href="https://github.com/tangyouhua">tangyouhua</a></p></li><li><p>贡献者：<a href="https://github.com/tangyouhua">tangyouhua</a>、<a href="https://github.com/kingzone">kingzone</a>、<a href="https://github.com/llhua2329">llhua2329</a>、<a href="https://github.com/BadCoderChou">BadCoderChou</a>、<a href="http://www.importnew.com/members/anankun/">anankun</a>、<a href="http://www.importnew.com/members/jianghehe/">贺贺</a>、<a href="http://www.importnew.com/members/petra/">大彭</a>、<a href="https://github.com/wing00yf/">superXiaoFan</a>、<a href="http://www.importnew.com/members/3951356/">javayrf</a>、<a href="http://www.importnew.com/members/John%20Smith/">John Smith</a>、<a href="http://www.importnew.com/members/jaler/">Jaler</a>、<a href="http://www.importnew.com/members/fdconan/">JM</a>、<a href="http://www.importnew.com/members/zy124348985/">dreamkidd</a>、<a href="http://www.importnew.com/members/cheenlie">cheenlie</a>、<a href="http://www.importnew.com/members/zhangQian1991">zhangQian1991</a>、<a href="http://www.importnew.com/members/wt726553124/">王涛</a>、<a href="http://www.importnew.com/members/xun_cui">马</a>、<a href="http://www.importnew.com/members/xuhf_1988/">vvkee</a>、<a href="http://www.importnew.com/members/yangxy81118">凝枫</a>、<a href="https://github.com/luhaixun">haixunlu</a>、<a href="http://www.importnew.com/members/milly/">milly</a>、<a href="http://www.importnew.com/members/xuhf_1988/">Hodur</a>、<a href="http://www.importnew.com/members/FakeHank">FakeHank</a>、<a href="http://www.importnew.com/members/%E8%BF%9E%E4%B9%90/">连乐</a>、<a href="http://www.importnew.com/members/UncleTim/">UncleTim</a>、<a href="http://www.importnew.com/members/sunbiaobiao">sunbiaobiao</a>、<a href="http://www.importnew.com/members/wx2702327993/">zhiguo</a>、<a href="http://www.importnew.com/members/zhongjianno1/">光光头去打酱油</a>、<a href="http://www.importnew.com/members/TonyAaron/">云中游</a>、<a href="http://www.importnew.com/members/zemo/">Zemo</a>、<a href="https://github.com/sdcuike">sdcuike</a>、<a href="https://github.com/danielwii">danielwii</a>、<a href="http://www.importnew.com/members/q1118024125/">oneDay</a>、<a href="https://github.com/dfghj44444">邢敏</a>、<a href="https://github.com/heikehuan">heikehuan</a>、<a href="https://github.com/fgcui1204">fgcui1204</a>、<a href="https://github.com/wenxueliu">wenxueliu</a>、<a href="https://github.com/node">Gentle Yang</a>、<a href="http://www.importnew.com/author/huangxiaofei/">黄小非</a>、<a href="http://www.importnew.com/members/wtgn1m1/">wangtg</a>、<a href="http://www.importnew.com/members/2937134480/">百焱</a>、<a href="http://www.importnew.com/members/2480130384/">胡不GUI</a>、<a href="http://www.importnew.com/members/mtHzm/">Another_mt</a>、<a href="http://www.importnew.com/members/adonis/">Rainbow</a>、<a href="http://www.importnew.com/members/menghuanqiqi">super^糖</a>、<a href="http://www.importnew.com/members/huangyuliang/">黄余粮</a>、<a href="http://www.importnew.com/members/sunbojian100/">Sun</a>、<a href="https://github.com/SoberChina">李伟高</a>、<a href="https://github.com/q977734161">lixiaobao</a>、<a href="https://github.com/XuZhongCN">許中</a>、You</p></li></ul><p>注：名单不分排名，不定期补充更新</p><hr><!-- ### 奖励计划虽然奖励可能并不是你加入的主要原因，但还是有必要提一下：* 整理超过 20 个资源后，可在伯乐在线上开通打赏；* 每整理 20 个资源，有机会获得技术书籍或各种有意思的创意、极客产品；* [奖励详情](http://www.importnew.com/rewards/)* * * --><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li><a href="#awesome-java-cn">Java资源大全中文版</a><ul><li><a href="#ancients">古董级工具</a></li><li><a href="#build">构建工具</a></li><li><a href="#bytecode-manipulation">字节码操作</a></li><li><a href="#cluster-management">集群管理</a></li><li><a href="#code-analysis">代码分析</a></li><li><a href="#compiler-compiler">编译器生成工具</a></li><li><a href="#configuration">外部配置工具</a></li><li><a href="#constraint-satisfaction-problem-solver">约束满足问题求解程序</a></li><li><a href="#continuous-integration">持续集成</a></li><li><a href="#csv">CSV解析</a></li><li><a href="#data-structures">数据结构</a></li><li><a href="#database">数据库</a></li><li><a href="#date-and-time">时间日期工具库</a></li><li><a href="#dependency-injection">依赖注入</a></li><li><a href="#development">开发流程增强工具</a></li><li><a href="#distributed-applications">分布式应用</a></li><li><a href="#distributed-databases">分布式数据库</a></li><li><a href="#distribution">发布</a></li><li><a href="#document-processing">文档处理工具</a></li><li><a href="#functional-programming">函数式编程</a></li><li><a href="#game-development">游戏开发</a></li><li><a href="#gui">GUI</a></li><li><a href="#high-performance">高性能计算</a></li><li><a href="#ide">IDE</a></li><li><a href="#imagery">图像处理</a></li><li><a href="#json">JSON</a></li><li><a href="#jvm-and-jdk">JVM与JDK</a></li><li><a href="#languages">基于JVM的语言</a></li><li><a href="#logging">日志</a></li><li><a href="#machine-learning">机器学习</a></li><li><a href="#messaging">消息传递</a></li><li><a href="#miscellaneous">杂项</a></li><li><a href="#monitoring">应用监控工具</a></li><li><a href="#native">原生开发库</a></li><li><a href="#natural-language-processing">自然语言处理</a></li><li><a href="#networking">网络</a></li><li><a href="#orm">ORM</a></li><li><a href="#pdf">PDF</a></li><li><a href="#performance-analysis">性能分析</a></li><li><a href="#reactive-libraries">响应式开发库</a></li><li><a href="#rest-frameworks">REST框架</a></li><li><a href="#science">科学计算与分析</a></li><li><a href="#search">搜索引擎</a></li><li><a href="#security">安全</a></li><li><a href="#serialization">序列化</a></li><li><a href="#server">应用服务器</a></li><li><a href="#template-engine">模板引擎</a></li><li><a href="#testing">测试</a></li><li><a href="#utility">通用工具库</a></li><li><a href="#web-crawling">网络爬虫</a></li><li><a href="#web-frameworks">Web框架</a></li><li><a href="#Business-Process-Management">业务流程管理套件</a></li></ul></li><li><a href="#resources">资源</a><ul><li><a href="#communities">社区</a></li><li><a href="#influential-books">有影响力的书</a></li><li><a href="#podcasts">播客</a></li><li><a href="#weibo-weixin">微博、微信公众号</a></li><li><a href="#twitter">Twitter</a></li><li><a href="#websites">知名网站</a></li></ul></li></ul><h2 id="ancients">古董级工具</h2><p><em>这些工具伴随着Java一起出现，在各自辉煌之后还在一直使用。</em></p><ul><li><a href="http://www.importnew.com/apache-ant/">Apache Ant</a>：基于XML的构建管理工具。<a href="http://ant.apache.org/">官网</a></li><li><a href="http://www.importnew.com/cglib/">cglib</a>：字节码生成库。<a href="https://github.com/cglib/cglib">官网</a></li><li><a href="http://www.importnew.com/glassfish/">GlassFish</a>：应用服务器，由Oracle赞助支持的Java EE参考实现。<a href="https://glassfish.java.net/">官网</a></li><li><a href="http://www.importnew.com/hudson/">Hudson</a>：持续集成服务器，目前仍在活跃开发。<a href="http://hudson-ci.org/">官网</a></li><li><a href="http://www.importnew.com/javaserver-faces/">JavaServer Faces</a>：Mojarra是JSF标准的一个开源实现，由Oracle开发。<a href="https://javaserverfaces.java.net/">官网</a></li><li><a href="http://www.importnew.com/javaserver-pages/">JavaServer Pages</a>：支持自定义标签库的网站通用模板库。<a href="https://jsp.java.net/">官网</a></li><li><a href="http://www.importnew.com/liquibase/">Liquibase</a>：与具体数据库独立的追踪、管理和应用数据库Scheme变化的工具。<a href="http://www.liquibase.org/">官网</a></li></ul><h3 id="build">构建工具</h3><p><em>构建及应用依赖关系处理工具。</em></p><ul><li><a href="http://www.importnew.com/maven/">Apache Maven</a>：Maven是一款声明式构建及依赖管理工具，采用约定优于配置方式进行管理。相对Apache Ant更推荐使用Maven，前者采用了过程式管理，维护相对困难。<a href="http://maven.apache.org/">官网</a></li><li><a href="http://www.importnew.com/bazel/">Bazel</a>：来自Google的构建工具，可以快速、可靠地构建代码。<a href="http://bazel.io/">官网</a></li><li><a href="http://www.importnew.com/gradle/">Gradle</a>：使用Groovy（非XML）进行增量构建，可以很好地与Maven依赖管理配合工作。<a href="http://gradle.org/">官网</a></li><li><a href="http://www.importnew.com/buck/">Buck</a>：Facebook构建工具。<a href="https://buckbuild.com/">官网</a></li></ul><h3 id="bytecode-manipulation">字节码操作</h3><p><em>编程方式操作字节码的开发库。</em></p><ul><li><a href="http://www.importnew.com/asm/">ASM</a>：通用底层字节码操作和分析开发库。<a href="http://asm.ow2.org/">官网</a></li><li><a href="http://www.importnew.com/byte-buddy/">Byte Buddy</a>：使用流式API进一步简化字节码生成。<a href="http://bytebuddy.net/">官网</a></li><li><a href="http://www.importnew.com/byteman/">Byteman</a>：在运行时通过DSL（规则）操作字节码进行测试和故障排除。<a href="http://byteman.jboss.org/">官网</a></li><li><a href="http://www.importnew.com/javassist/">Javassist</a>：一个简化字节码编辑尝试。<a href="http://jboss-javassist.github.io/javassist">官网</a></li></ul><h3 id="cluster-management">集群管理</h3><p><em>在集群内动态管理应用程序的框架。</em></p><ul><li><a href="http://www.importnew.com/apache-aurora/">Apache Aurora</a>：Apache Aurora是一个Mesos框架，用于长时间运行服务和定时任务（cron job）。<a href="http://aurora.apache.org/">官网</a></li><li><a href="http://www.importnew.com/singularity/">Singularity</a>：Singularity是一个Mesos框架，方便部署和操作。它支持Web Service、后台运行、调度作业和一次性任务。<a href="http://getsingularity.com/">官网</a></li></ul><h3 id="code-analysis">代码分析</h3><p><em>测量代码指标和质量工具。</em></p><ul><li><a href="http://www.importnew.com/checkstyle/">Checkstyle</a>：代码编写规范和标准静态分析工具。<a href="https://github.com/checkstyle/checkstyle">官网</a></li><li><a href="http://www.importnew.com/error-prone/">Error Prone</a>：将常见编程错误作为运行时错误报告。<a href="https://github.com/google/error-prone">官网</a></li><li>FindBugs：通过字节码静态分析查找隐藏bug。<a href="http://findbugs.sourceforge.net/">官网</a></li><li><a href="http://www.importnew.com/jqassistant/">jQAssistant</a>：使用基于Neo4J查询语言进行代码静态分析。<a href="http://jqassistant.org/">官网</a></li><li><a href="http://www.importnew.com/pmd/">PMD</a>：对源代码分析查找不良的编程习惯。<a href="https://github.com/pmd/pmd">官网</a></li><li><a href="http://www.importnew.com/sonarqube/">SonarQube</a>：通过插件集成其它分析组件，对过去一段时间内的数据进行统计。<a href="http://www.sonarqube.org/">官网</a></li></ul><h3 id="compiler-compiler">编译器生成工具</h3><p><em>用来创建解析器、解释器或编译器的框架。</em></p><ul><li><a href="http://www.importnew.com/antlr/">ANTLR</a>：复杂的全功能自顶向下解析框架。<a href="http://www.antlr.org/">官网</a></li><li><a href="http://www.importnew.com/javacc/">JavaCC</a>：JavaCC是更加专门的轻量级工具，易于上手且支持语法超前预测。<a href="https://javacc.org/">官网</a></li></ul><h3 id="configuration">外部配置工具</h3><p><em>支持外部配置的开发库。</em></p><ul><li><a href="http://www.importnew.com/config/">config</a>：针对JVM语言的配置库。<a href="https://github.com/typesafehub/config">官网</a></li><li><a href="http://www.importnew.com/owner/">owner</a>：减少冗余配置属性。<a href="https://github.com/lviggiano/owner">官网</a></li></ul><h3 id="constraint-satisfaction-problem-solver">约束满足问题求解程序</h3><p><em>帮助解决约束满足问题的开发库。</em></p><ul><li><a href="http://www.importnew.com/choco/">Choco</a>：可直接使用的约束满足问题求解程序，使用了约束规划技术。<a href="http://choco-solver.org/">官网</a></li><li><a href="http://www.importnew.com/jacop/">JaCoP</a>：为FlatZinc语言提供了一个接口，可以执行MiniZinc模型。<a href="https://github.com/radsz/jacop/">官网</a></li><li><a href="http://www.importnew.com/optaplanner/">OptaPlanner</a>：业务规划与资源调度优化求解程序。<a href="http://www.optaplanner.org/">官网</a></li><li><a href="http://www.importnew.com/sat4j/">Sat4J</a>：逻辑代数与优化问题最先进的求解程序。<a href="http://www.sat4j.org/">官网</a></li></ul><h3 id="continuous-integration">持续集成</h3><ul><li><a href="http://www.importnew.com/bamboo/">Bamboo</a>：Atlassian解决方案，可以很好地集成Atlassian的其他产品。可以选择开源许可，也可以购买商业版。<a href="https://www.atlassian.com/software/bamboo">官网</a></li><li>CircleCI：提供托管服务，可以免费试用。<a href="https://circleci.com/">官网</a></li><li><a href="http://www.importnew.com/codeship/">Codeship</a>：提供托管服务，提供有限的免费模式。<a href="https://codeship.com/features">官网</a></li><li><a href="hao.importnew.com/fabric8/">fabric8</a>：容器集成平台。<a href="http://fabric8.io/">官网</a></li><li><a href="http://www.importnew.com/go/">Go</a>：ThoughtWork开源解决方案。<a href="https://www.gocd.io/">官网</a></li><li><a href="http://www.importnew.com/jenkins/">Jenkins</a>：支持基于服务器的部署服务。<a href="http://jenkins-ci.org/">官网</a></li><li><a href="http://www.importnew.com/teamcity/">TeamCity</a>：JetBrain的持续集成解决方案，有免费版。<a href="http://www.jetbrains.com/teamcity/">官网</a></li><li><a href="http://www.importnew.com/travis/">Travis</a>：通常用作开源项目的托管服务。<a href="https://travis-ci.org/">官网</a></li><li><a href="http://www.importnew.com/buildkite/">Buildkite</a>: 持续集成工具，用简单的脚本就能设置pipeline，而且能快速构建，可以免费试用。<a href="https://buildkite.com/">官网</a></li></ul><h3 id="csv">CSV解析</h3><p><em>简化CSV数据读写的框架与开发库</em></p><ul><li><a href="http://www.importnew.com/univocity-parsers/">uniVocity-parsers</a>：速度最快功能最全的CSV开发库之一，同时支持TSV与固定宽度记录的读写。<a href="https://github.com/uniVocity/univocity-parsers">官网</a></li></ul><h3 id="database">数据库</h3><p><em>简化数据库交互的相关工具。</em></p><ul><li><a href="http://www.importnew.com/apache-phoenix/">Apache Phoenix</a>：HBase针对低延时应用程序的高性能关系数据库层。<a href="http://phoenix.apache.org/">官网</a></li><li><a href="http://www.importnew.com/crate/">Crate</a>：实现了数据同步、分片、缩放、复制的分布式数据存储。除此之外还可以使用基于SQL的语法跨集群查询。<a href="https://crate.io/">官网</a></li><li><a href="http://www.importnew.com/flyway/">Flyway</a>：简单的数据库迁移工具。<a href="http://flywaydb.org/">官网</a></li><li><a href="http://www.importnew.com/h2/">H2</a>：小型SQL数据库，以可以作为内存数据库使用著称。<a href="http://h2database.com/">官网</a></li><li><a href="http://www.importnew.com/hikaricp/">HikariCP</a>：高性能JDBC连接工具。<a href="https://github.com/brettwooldridge/HikariCP">官网</a></li><li><a href="http://www.importnew.com/jdbi/">JDBI</a>：便捷的JDBC抽象。<a href="http://jdbi.org/">官网</a></li><li><a href="http://www.importnew.com/jooq/">jOOQ</a>：为SQL schema生成typesafe代码。<a href="http://www.jooq.org/">官网</a></li><li><a href="http://www.importnew.com/mapdb/">MapDB</a>：以磁盘或堆内存中并发集合为基础的嵌入式数据库引擎。<a href="http://www.mapdb.org/">官网</a></li><li><a href="http://www.importnew.com/presto/">Presto</a>：针对大数据的分布式SQL查询引擎。<a href="https://github.com/facebook/presto">官网</a></li><li><a href="http://www.importnew.com/querydsl/">Querydsl</a>：Typesafe统一查询。<a href="http://www.querydsl.com/">官网</a></li></ul><h3 id="data-structures">数据结构</h3><ul><li><a href="http://www.importnew.com/apache-parquet/">Apache Parquet</a>：Google Dremel论文中发布的基于组装算法的列式（Columnar）存储格式。<a href="http://parquet.apache.org/">官网</a></li><li><a href="http://www.importnew.com/protobuf/">Protobuf</a>：Google数据交换格式。<a href="https://github.com/google/protobuf">官网</a></li><li><a href="http://www.importnew.com/sbe/">SBE</a>：简单二进制编码，是最快速的消息格式之一。<a href="https://github.com/real-logic/simple-binary-encoding">官网</a></li><li><a href="http://www.importnew.com/wire/">Wire</a>：整洁轻量级协议缓存。<a href="https://github.com/square/wire">官网</a></li></ul><h3 id="date-and-time">时间日期工具库</h3><p><em>处理时间和日期的开发库。</em></p><ul><li><a href="http://www.importnew.com/joda-time/">Joda-Time</a>：在Java 8发布前，Joda-Time是实际使用的时间日期库标准。<a href="http://www.joda.org/joda-time/">官网</a></li><li><a href="http://www.importnew.com/time4j/">Time4J</a>：高级时间和日期库。<a href="https://github.com/MenoData/Time4J">官网</a></li><li><a href="http://www.importnew.com/ThreeTen/">ThreeTen</a>：JSR-310实现，为JDK提供更具特点的时间和日期API。<a href="http://www.threeten.org/">官网</a></li></ul><h3 id="dependency-injection">依赖注入</h3><p><em>帮实现依赖翻转范式的开发库。</em> <a href="https://en.wikipedia.org/wiki/Inversion_of_control">官网</a></p><ul><li><a href="http://www.importnew.com/apache-deltaspike/">Apache DeltaSpike</a>：CDI扩展框架。<a href="https://deltaspike.apache.org/">官网</a></li><li><a href="http://www.importnew.com/dagger2/">Dagger2</a>：编译时注入框架，不需要使用反射。<a href="http://google.github.io/dagger/">官网</a></li><li><a href="http://www.importnew.com/guice/">Guice</a>：可以匹敌Dagger的轻量级注入框架。<a href="https://github.com/google/guice">官网</a></li><li><a href="http://www.importnew.com/hk2/">HK2</a>：轻量级动态依赖注入框架。<a href="https://hk2.java.net/">官网</a></li></ul><h3 id="development">开发流程增强工具</h3><p><em>从最基本的层面增强开发流程。</em></p><ul><li><a href="http://www.importnew.com/adt4j/">ADT4J</a>：针对代数数据类型的JSR-269代码生成器。<a href="https://github.com/sviperll/adt4j">官网</a></li><li><a href="http://www.importnew.com/aspectj/">AspectJ</a>：面向切面编程（AOP）的无缝扩展。<a href="https://eclipse.org/aspectj/">官网</a></li><li><a href="http://www.importnew.com/auto/">Auto</a>：源代码生成器集合。<a href="https://github.com/google/auto">官网</a></li><li><a href="http://www.importnew.com/dcevm/">DCEVM</a>：通过修改JVM在运行时支持对已加载的类进行无限次重定义。<a href="http://dcevm.github.io/">官网</a></li><li>HotswapAgent：支持无限次重定义运行时类与资源。<a href="https://github.com/HotswapProjects/HotswapAgent">官网</a></li><li>Immutables：类似Scala的条件类。<a href="http://immutables.github.io/">官网</a></li><li>JHipster：基于Spring Boot与AngularJS应用程序的Yeoman源代码生成器。<a href="https://github.com/jhipster/generator-jhipster">官网</a></li><li><a href="http://www.importnew.com/jrebel/">JRebel</a>：无需重新部署，可以即时重新加载代码与配置的商业软件。<a href="http://zeroturnaround.com/software/jrebel/">官网</a></li><li>Lombok：减少冗余的代码生成器。<a href="https://projectlombok.org/">官网</a></li><li>Spring Loaded：类重载代理。<a href="https://github.com/spring-projects/spring-loaded">官网</a></li><li><a href="http://www.importnew.com/vert-x/">vert.x</a>：多语言事件驱动应用框架。<a href="http://vertx.io/">官网</a></li></ul><h3 id="distributed-applications">分布式应用</h3><p><em>用来编写分布式容错应用的开发库和框架。</em></p><ul><li><a href="http://www.importnew.com/akka/">Akka</a>：用来编写分布式容错并发事件驱动应用程序的工具和运行时。<a href="http://akka.io/">官网</a></li><li><a href="http://www.importnew.com/storm/">Apache Storm</a>：实时计算系统。<a href="http://storm.apache.org/">官网</a></li><li><a href="http://www.importnew.com/zookeeper/">Apache ZooKeeper</a>：针对大型分布式系统的协调服务，支持分布式配置、同步和名称注册。<a href="http://zookeeper.apache.org/">官网</a></li><li><a href="http://www.importnew.com/Hazelcast/">Hazelcast</a>：高可扩展内存数据网格。<a href="http://hazelcast.org/">官网</a></li><li><a href="http://www.importnew.com/hystrix/">Hystrix</a>：提供延迟和容错。<a href="https://github.com/Netflix/Hystrix">官网</a></li><li><a href="http://www.importnew.com/jgroups/">JGroups</a>：提供可靠的消息传递和集群创建的工具。<a href="http://www.jgroups.org/">官网</a></li><li><a href="http://www.importnew.com/orbit/">Orbit</a>：支持虚拟角色（Actor），在传统角色的基础上增加了另外一层抽象。<a href="http://orbit.bioware.com/">官网</a></li><li><a href="http://www.importnew.com/quasar/">Quasar</a>：为JVM提供轻量级线程和角色。<a href="http://www.paralleluniverse.co/quasar/">官网</a></li></ul><h3 id="distributed-databases">分布式数据库</h3><p><em>对应用程序而言，在分布式系统中的数据库看起来就像是只有一个数据源。</em></p><ul><li><a href="http://www.importnew.com/cassandra/">Apache Cassandra</a>：列式数据库，可用性高且没有单点故障。<a href="http://cassandra.apache.org/">官网</a></li><li><a href="http://www.importnew.com/hbase/">Apache HBase</a>：针对大数据的Hadoop数据库。<a href="http://hbase.apache.org/">官网</a></li><li><a href="http://www.importnew.com/druid/">Druid</a>：实时和历史OLAP数据存储，在聚集查询和近似查询方面表现不俗。<a href="http://druid.io/">官网</a></li><li><a href="http://www.importnew.com/infinispan/">Infinispan</a>：针对缓存的高并发键值对数据存储。<a href="http://infinispan.org/">官网</a></li><li><a href="">TiDB</a>：开源分布式HTAP数据库，结合了传统的RDBMS和NoSQL的最佳特性。<a href="https://pingcap.com/">官网</a></li></ul><h3 id="distribution">发布</h3><p><em>以本机格式发布应用程序的工具。</em></p><ul><li>Bintray：发布二进制文件版本控制工具。可以于Maven或Gradle一起配合使用。提供开源免费版本和几种商业收费版本。<a href="https://bintray.com/">官网</a></li><li><a href="http://www.importnew.com/central-repository/">Central Repository</a>：最大的二进制组件仓库，面向开源社区提供免费服务。Apache Maven默认使用Central <a href="http://search.maven.org/">官网</a>Repository，也可以在所有其他构建工具中使用。</li><li>IzPack：为跨平台部署建立创作工具（Authoring Tool）。<a href="http://izpack.org/">官网</a></li><li>JitPack：打包GitHub仓库的便捷工具。可根据需要构建Maven、Gradle项目，发布可立即使用的组件。<a href="https://jitpack.io/">官网</a></li><li>Launch4j：将JAR包装为轻量级本机Windows可执行程序。<a href="http://launch4j.sourceforge.net/">官网</a></li><li>Nexus：支持代理和缓存功能的二进制管理工具。<a href="http://www.sonatype.com/nexus">官网</a></li><li>packr：将JAR、资源和JVM打包成Windows、Linux和Mac OS X本地发布文件。<a href="https://github.com/libgdx/packr/">官网</a></li></ul><h3 id="document-processing">文档处理工具</h3><p><em>处理Office文档的开发库。</em></p><ul><li><a href="http://www.importnew.com/poi/">Apache POI</a>：支持OOXML规范（XLSX、DOCX、PPTX）以及OLE2规范（XLS、DOC、PPT）。<a href="http://poi.apache.org/">官网</a></li><li><a href="http://www.importnew.com/documents4j/">documents4j</a>：使用第三方转换器进行文档格式转换，转成类似MS Word这样的格式。<a href="http://documents4j.com/">官网</a></li><li><a href="http://www.importnew.com/jopendocument/">jOpenDocument</a>：处理OpenDocument格式（由Sun公司提出基于XML的文档格式）。<a href="http://www.jopendocument.org/">官网</a></li></ul><h3 id="functional-programming">函数式编程</h3><p><em>函数式编程支持库。</em></p><ul><li>Cyclops：支持一元（Monad）操作和流操作工具类、comprehension（List语法）、模式匹配、trampoline等特性。<a href="https://github.com/aol/cyclops">官网</a></li><li>Fugue：Guava的函数式编程扩展。<a href="https://bitbucket.org/atlassian/fugue">官网</a></li><li>Functional Java：实现了多种基础和高级编程抽象，用来辅助面向组合开发（composition-oriented development）。<a href="http://www.functionaljava.org/">官网</a></li><li>Javaslang：一个函数式组件库，提供持久化数据类型和函数式控制结构。<a href="http://javaslang.com/">官网</a></li><li>jOOλ：旨在填补Java 8 lambda差距的扩展，提供了众多缺失的类型和一组丰富的顺序流API。<a href="https://github.com/jOOQ/jOOL">官网</a></li></ul><h3 id="game-development">游戏开发</h3><p><em>游戏开发框架。</em></p><ul><li><a href="http://www.importnew.com/jmonkeyengine/">jMonkeyEngine</a>：现代3D游戏开发引擎。<a href="http://jmonkeyengine.org/">官网</a></li><li><a href="http://www.importnew.com/libgdx/">libGDX</a>：全面的跨平台高级框架。<a href="https://libgdx.badlogicgames.com/">官网</a></li><li><a href="http://www.importnew.com/lwjgl/">LWJGL</a>：对OpenGL&#x2F;CL&#x2F;AL等技术进行抽象的健壮框架。<a href="https://www.lwjgl.org/">官网</a></li><li>jPCT：基于OpenGL技术开发的3D图形引擎。纯Java的3D引擎。<a href="http://www.jpct.net/">官网</a></li></ul><h3 id="gui">GUI</h3><p><em>现代图形化用户界面开发库。</em></p><ul><li><a href="http://www.importnew.com/javafx/">JavaFX</a>：Swing的后继者。<a href="http://www.oracle.com/technetwork/java/javase/overview/javafx-overview-2158620.html">官网</a></li><li><a href="http://www.importnew.com/scene_builder/">Scene Builder</a>：开发JavaFX应用的可视化布局工具。<a href="http://docs.oracle.com/javase/8/scene-builder-2/get-started-tutorial/overview.htm#JSBGS164">官网</a></li></ul><h3 id="high-performance">高性能计算</h3><p><em>涵盖了从集合到特定开发库的高性能计算相关工具。</em></p><ul><li>Agrona：高性能应用中常见的数据结构和工具方法。<a href="https://github.com/real-logic/Agrona">官网</a></li><li>Disruptor：线程间消息传递开发库。<a href="http://lmax-exchange.github.io/disruptor/">官网</a></li><li>fastutil：快速紧凑的特定类型集合（Collection）。<a href="http://fastutil.di.unimi.it/">官网</a></li><li>GS Collections：受Smalltalk启发的集合框架。<a href="https://github.com/goldmansachs/gs-collections">官网</a></li><li><a href="http://www.importnew.com/hppc/">HPPC</a>：基础类型集合。<a href="http://labs.carrotsearch.com/hppc.html">官网</a></li><li>Javolution：实时和嵌入式系统的开发库。<a href="http://javolution.org/">官网</a></li><li><a href="http://www.importnew.com/jctools/">JCTools</a>：JDK中缺失的并发工具。<a href="https://github.com/JCTools/JCTools">官网</a></li><li><a href="http://www.importnew.com/koloboke/">Koloboke</a>：Hash set和hash map。<a href="https://github.com/OpenHFT/Koloboke">官网</a></li><li>Trove：基础类型集合。<a href="http://trove.starlight-systems.com/">官网</a></li><li>High-scale-lib:Cliff Click 个人开发的高性能并发库<a href="https://github.com/stephenc/high-scale-lib">官网</a></li></ul><h3 id="ide">IDE</h3><p><em>简化开发的集成开发环境。</em></p><ul><li><a href="http://www.importnew.com/eclipse/">Eclipse</a>：老牌开源项目，支持多种插件和编程语言。<a href="http://www.eclipse.org/">官网</a></li><li><a href="http://www.importnew.com/intellij-idea/">IntelliJ IDEA</a>：支持众多JVM语言，是安卓开发者好的选择。商业版主要针对企业客户。<a href="http://www.jetbrains.com/idea/">官网</a></li><li><a href="http://www.importnew.com/netbeans/">NetBeans</a>：为多种技术提供集成化支持，包括Java SE、Java EE、数据库访问、HTML5等。<a href="https://netbeans.org/">官网</a></li><li><a href="http://www.importnew.com/scala-ide/">Scala IDE</a>：一款基于Eclipse开源平台打造的Scala集成开发环境。<a href="http://scala-ide.org/">官网</a></li><li><a href="http://www.importnew.com/springsource-tool-suite/">SpringSource Tool Suite（STS）</a>:一款基于Eclipse开源平台打造的Spring应用开发环境。<a href="http://spring.io/tools/sts/">官网</a></li></ul><h3 id="imagery">图像处理</h3><p><em>创建、评价和操作图片的支持库。</em></p><ul><li><a href="http://www.importnew.com/imgscalr/">Imgscalr</a>：纯Java 2D实现，简单、高效、支持硬件加速的图像缩放开发库。<a href="https://github.com/thebuzzmedia/imgscalr">官网</a></li><li><a href="http://www.importnew.com/picasso/">Picasso</a>：安卓图片下载和图片缓存开发库。<a href="http://square.github.io/picasso/">官网</a></li><li><a href="http://www.importnew.com/thumbnailator/">Thumbnailator</a>：Thumbnailator是一个高质量Java缩略图开发库。<a href="https://github.com/coobird/thumbnailator">官网</a></li><li><a href="http://www.importnew.com/zxing/">ZXing</a>：支持多种格式的一维、二维条形码图片处理开发库。<a href="https://github.com/zxing/zxing">官网</a></li><li><a href="http://www.importnew.com/im4java/">im4java</a>: 基于ImageMagick或GraphicsMagick命令行的图片处理开发库，基本上ImageMagick能够支持的图片格式和处理方式都能够处理。<a href="http://im4java.sourceforge.net/">官网</a></li><li>Apache Batik：在Java应用中程序以SVG格式显示、生成及处理图像的工具集，包括SVG解析器、SVG生成器、SVG DOM等模块，可以集成使用也可以单独使用，还可以扩展自定义的SVG标签。<a href="http://xmlgraphics.apache.org/batik/">官网</a></li></ul><h3 id="json">JSON</h3><p><em>简化JSON处理的开发库。</em></p><ul><li><a href="http://www.importnew.com/genson/">Genson</a>：强大且易于使用的Java到JSON转换开发库。<a href="http://owlike.github.io/genson">官网</a></li><li><a href="http://www.importnew.com/gson/">Gson</a>：谷歌官方推出的JSON处理库，支持在对象与JSON之间双向序列化，性能良好且可以实时调用。<a href="https://github.com/google/gson">官网</a></li><li><a href="http://www.importnew.com/jackson/">Jackson</a>：与GSON类似，在频繁使用时性能更佳。<a href="http://wiki.fasterxml.com/JacksonHome">官网</a></li><li><a href="http://www.importnew.com/logansquare/">LoganSquare</a>：基于Jackson流式API，提供对JSON解析和序列化。比GSON与Jackson组合方式效果更好。<a href="https://github.com/bluelinelabs/LoganSquare">官网</a></li><li><a href="http://www.importnew.com/fastjson/">Fastjson</a>：一个Java语言编写的高性能功能完善的JSON库。<a href="https://github.com/Alibaba/fastjson">官网</a></li><li>Kyro：快速、高效、自动化的Java对象序列化和克隆库。<a href="https://github.com/EsotericSoftware/kryo">官网</a></li></ul><h3 id="jvm-and-jdk">JVM与JDK</h3><p><em>目前的JVM和JDK实现。</em></p><ul><li><a href="http://www.importnew.com/jdk-9/">JDK 9</a>：JDK 9的早期访问版本。<a href="https://jdk9.java.net/">官网</a></li><li><a href="http://www.importnew.com/openjdk/">OpenJDK</a>：JDK开源实现。<a href="http://openjdk.java.net/">官网</a></li></ul><h3 id="languages">基于JVM的语言</h3><p><em>除Java外，可以用来编写JVM应用程序的编程语言。</em></p><ul><li>Scala：融合了面向对象和函数式编程思想的静态类型编程语言。<a href="http://www.scala-lang.org/">官网</a></li><li><a href="http://www.importnew.com/groovy/">Groovy</a>：类型可选（Optionally typed）的动态语言，支持静态类型和静态编译。目前是一个Apache孵化器项目。<a href="http://www.groovy-lang.org/">官网</a></li><li>Clojure：可看做现代版Lisp的动态类型语言。<a href="http://clojure.org/">官网</a></li><li>Ceylon：RedHat开发的面向对象静态类型编程语言。<a href="http://ceylon-lang.org/">官网</a></li><li>Kotlin：JetBrain针对JVM、安卓和浏览器提供的静态类型编程语言。<a href="http://kotlinlang.org/">官网</a></li><li><a href="http://www.importnew.com/xtend/">Xtend</a>：一种静态编程语言，能够将其代码转换为简洁高效的Java代码，并基于JVM运行。<a href="http://www.eclipse.org/xtend/">官网</a></li></ul><h3 id="logging">日志</h3><p><em>记录应用程序行为日志的开发库。</em></p><ul><li><a href="http://www.importnew.com/log4j2/">Apache Log4j 2</a>：使用强大的插件和配置架构进行完全重写。<a href="http://logging.apache.org/log4j/">官网</a></li><li><a href="http://www.importnew.com/kibana/">kibana</a>：分析及可视化日志文件。<a href="https://www.elastic.co/products/kibana">官网</a></li><li><a href="http://www.importnew.com/logback/">Logback</a>：强健的日期开发库，通过Groovy提供很多有趣的选项。<a href="http://logback.qos.ch/">官网</a></li><li><a href="http://www.importnew.com/logstash/">logstash</a>：日志文件管理工具。<a href="https://www.elastic.co/products/logstash">官网</a></li><li><a href="http://www.importnew.com/metrics/">Metrics</a>：通过JMX或HTTP发布参数，并且支持存储到数据库。<a href="https://github.com/dropwizard/metrics">官网</a></li><li><a href="http://www.importnew.com/slf4j/">SLF4J</a>：日志抽象层，需要与具体的实现配合使用。<a href="http://www.slf4j.org/">官网</a></li></ul><h3 id="machine-learning">机器学习</h3><p><em>提供具体统计算法的工具。其算法可从数据中学习。</em></p><ul><li><a href="http://www.importnew.com/apache-flink/">Apache Flink</a>：快速、可靠的大规模数据处理引擎。<a href="https://flink.apache.org/">官网</a></li><li><a href="http://www.importnew.com/apache-hadoop/">Apache Hadoop</a>：在商用硬件集群上用来进行大规模数据存储的开源软件框架。<a href="http://hadoop.apache.org/">官网</a></li><li><a href="http://www.importnew.com/apache-mahout/">Apache Mahout</a>：专注协同过滤、聚类和分类的可扩展算法。<a href="https://mahout.apache.org/">官网</a></li><li><a href="http://www.importnew.com/apache-spark/">Apache Spark</a>：开源数据分析集群计算框架。<a href="http://spark.apache.org/">官网</a></li><li><a href="http://www.importnew.com/deepdive/">DeepDive</a>：从非结构化数据建立结构化信息并集成到已有数据库的工具。<a href="http://deepdive.stanford.edu/">官网</a></li><li><a href="http://www.importnew.com/deeplearning4j/">Deeplearning4j</a>：分布式多线程深度学习开发库。<a href="http://deeplearning4j.org/">官网</a></li><li><a href="http://www.importnew.com/h2o/">H2O</a>：用作大数据统计的分析引擎。<a href="http://h2o.ai/">官网</a></li><li><a href="http://www.importnew.com/weka/">Weka</a>：用作数据挖掘的算法集合，包括从预处理到可视化的各个层次。<a href="http://www.cs.waikato.ac.nz/ml/weka/">官网</a></li><li><a href="http://www.importnew.com/quickml/">QuickML</a>：高效机器学习库。<a href="http://quickml.org/">官网</a>、<a href="https://github.com/sanity/quickml">GitHub</a></li></ul><h3 id="messaging">消息传递</h3><p><em>在客户端之间进行消息传递，确保协议独立性的工具。</em></p><ul><li><a href="http://www.importnew.com/aeron/">Aeron</a>：高效可扩展的单播、多播消息传递工具。<a href="https://github.com/real-logic/Aeron">官网</a></li><li><a href="http://www.importnew.com/activemq/">Apache ActiveMQ</a>：实现JMS的开源消息代理（broker），可将同步通讯转为异步通讯。<a href="http://activemq.apache.org/">官网</a></li><li><a href="http://www.importnew.com/apache-camel/">Apache Camel</a>：通过企业级整合模式（Enterprise Integration Pattern EIP）将不同的消息传输API整合在一起。<a href="http://camel.apache.org/">官网</a></li><li><a href="http://www.importnew.com/kafka/">Apache Kafka</a>：高吞吐量分布式消息系统。<a href="http://kafka.apache.org/">官网</a></li><li><a href="http://www.importnew.com/hermes/">Hermes</a>：快速、可靠的消息代理（Broker），基于Kafka构建。<a href="http://hermes.allegro.tech/">官网</a></li><li>JBoss HornetQ：清晰、准确、模块化，可以方便嵌入的消息工具。<a href="http://hornetq.jboss.org/">官网</a></li><li><a href="http://www.importnew.com/jeromq/">JeroMQ</a>：ZeroMQ的纯Java实现。<a href="https://github.com/zeromq/jeromq">官网</a></li><li><a href="http://www.importnew.com/smack/">Smack</a>：跨平台XMPP客户端函数库。<a href="https://github.com/igniterealtime/Smack/">官网</a></li><li>Openfire：是开源的、基于XMPP、采用Java编程语言开发的实时协作服务器。 Openfire安装和使用都非常简单，并可利用Web界面进行管理。 <a href="http://www.igniterealtime.org/projects/openfire/index.jsp">官网</a> <a href="https://github.com/igniterealtime/Openfire">GitHub</a></li><li>Spark：是一个开源，跨平台IM客户端。它的特性支持集组聊天，电话集成和强大安全性能。如果企业内部部署IM使用Openfire+Spark是最佳的组合。 <a href="http://www.igniterealtime.org/projects/spark/index.jsp">官网</a> <a href="https://github.com/igniterealtime/Spark">GitHub</a></li><li>Tigase： 是一个轻量级的可伸缩的 Jabber&#x2F;XMPP 服务器。无需其他第三方库支持，可以处理非常高的复杂和大量的用户数，可以根据需要进行水平扩展。 <a href="http://www.tigase.net/">官网</a></li></ul><h3 id="miscellaneous">杂项</h3><p><em>未分类其它资源。</em></p><ul><li>Design Patterns：实现并解释了最常见的设计模式。<a href="https://github.com/iluwatar/java-design-patterns">官网</a></li><li>Jimfs：内存文件系统。<a href="https://github.com/google/jimfs">官网</a></li><li>Lanterna：类似curses的简单console文本GUI函数库。<a href="https://code.google.com/p/lanterna/">官网</a></li><li>LightAdmin：可插入式CRUD UI函数库，可用来快速应用开发。<a href="http://lightadmin.org/">官网</a></li><li>OpenRefine：用来处理混乱数据的工具，包括清理、转换、使用Web Service进行扩展并将其关联到数据库。<a href="http://openrefine.org/">官网</a></li><li>RoboVM：Java编写原生iOS应用。<a href="https://robovm.com/">官网</a></li><li><a href="http://www.importnew.com/quartz/">Quartz</a>：强大的任务调度库.<a href="http://www.quartz-scheduler.org/">官网</a></li></ul><h3 id="monitoring">应用监控工具</h3><p><em>监控生产环境中应用程序的工具。</em></p><ul><li><a href="http://www.importnew.com/appdynamics/">AppDynamics</a>：性能监测商业工具。<a href="http://www.appdynamics.com/">官网</a></li><li><a href="http://www.importnew.com/javamelody/">JavaMelody</a>：性能监测和分析工具。<a href="https://github.com/javamelody/javamelody">官网</a></li><li><a href="http://www.importnew.com/Kamon/">Kamon</a>：Kamon用来监测在JVM上运行的应用程序。<a href="http://www.kamon.io/">官网</a></li><li><a href="http://www.importnew.com/new-relic/">New Relic</a>：性能监测商业工具。<a href="http://newrelic.com/">官网</a></li><li>SPM：支持对JVM应用程序进行分布式事务追踪的性能监测商业工具。<a href="https://sematext.com/spm/">官网</a></li><li><a href="http://www.importnew.com/overops_takipi/">OverOps(Takipi)</a>：产品运行时错误监测及调试商业工具。<a href="https://www.takipi.com/">官网</a></li></ul><h3 id="native">原生开发库</h3><p><em>用来进行特定平台开发的原生开发库。</em></p><ul><li><a href="http://www.importnew.com/jna/">JNA</a>：不使用JNI就可以使用原生开发库。此外，还为常见系统函数提供了接口。<a href="https://github.com/java-native-access/jna">官网</a></li></ul><h3 id="natural-language-processing">自然语言处理</h3><p><em>用来专门处理文本的函数库。</em></p><ul><li><a href="http://www.importnew.com/apache-opennlp/">Apache OpenNLP</a>：处理类似分词等常见任务的工具。<a href="https://opennlp.apache.org/">官网</a></li><li><a href="http://www.importnew.com/stanford_corenlp/">CoreNLP</a>：斯坦佛CoreNLP提供了一组基础工具，可以处理类似标签、实体名识别和情感分析这样的任务。<a href="http://nlp.stanford.edu/software/coenlp.shtml">官网</a></li><li><a href="http://www.importnew.com/lingpipe/">LingPipe</a>：一组可以处理各种任务的工具集，支持POS标签、情感分析等。<a href="http://alias-i.com/lingpipe/">官网</a></li><li><a href="http://www.importnew.com/mallet/">Mallet</a>：统计学自然语言处理、文档分类、聚类、主题建模等。<a href="http://mallet.cs.umass.edu/">官网</a></li></ul><h3 id="networking">网络</h3><p><em>网络编程函数库。</em></p><ul><li><a href="http://www.importnew.com/async-http-client/">Async Http Client</a>：异步HTTP和WebSocket客户端函数库。<a href="https://github.com/AsyncHttpClient/async-http-client">官网</a></li><li><a href="http://www.importnew.com/grizzly/">Grizzly</a>：NIO框架，在Glassfish中作为网络层使用。<a href="https://grizzly.java.net/">官网</a></li><li><a href="http://www.importnew.com/netty/">Netty</a>：构建高性能网络应用程序开发框架。<a href="http://netty.io/">官网</a></li><li><a href="http://www.importnew.com/okhttp/">OkHttp</a>：一个Android和Java应用的HTTP+SPDY客户端。<a href="http://square.github.io/okhttp/">官网</a></li><li>Undertow：基于NIO实现了阻塞和非阻塞API的Web服务器，在WildFly中作为网络层使用。<a href="http://undertow.io/">官网</a></li><li>unirest-java: Unirest 是一个轻量级的 HTTP 请求库，涵盖 Node、Ruby、Java、PHP、Python、Objective-C、.NET 等多种语言。可发起 GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS 请求。<a href="http://unirest.io/java">官网</a></li><li>brpc-java: java版baidu rpc框架，高性能、多协议、易扩展、低耦合。<a href="https://github.com/baidu/brpc-java">官网</a></li></ul><h3 id="orm">ORM</h3><p><em>处理对象持久化的API。</em></p><ul><li><a href="http://www.importnew.com/ebean/">Ebean</a>：支持快速数据访问和编码的ORM框架。<a href="http://ebean-orm.github.io/">官网</a></li><li><a href="http://www.importnew.com/eclipselink/">EclipseLink</a>：支持许多持久化标准，JPA、JAXB、JCA和SDO。<a href="https://www.eclipse.org/eclipselink/">官网</a></li><li><a href="http://www.importnew.com/hibernate/">Hibernate</a>：广泛使用、强健的持久化框架。Hibernate的技术社区非常活跃。<a href="http://hibernate.org/orm/">官网</a></li><li><a href="http://www.importnew.com/mybatis/">MyBatis</a>：带有存储过程或者SQL语句的耦合对象（Couples object）。<a href="http://mybatis.github.io/mybatis-3/">官网</a></li><li><a href="http://www.importnew.com/ormlite/">OrmLite</a>：轻量级开发包，免除了其它ORM产品中的复杂性和开销。<a href="http://ormlite.com/">官网</a></li><li>Nutz：另一个SSH。<a href="http://nutzam.com/">官网</a>，<a href="https://github.com/nutzam/nutz">Github</a>，<a href="https://nutz.cn/">论坛</a></li><li>JFinal：JAVA WEB + ORM框架。<a href="http://www.jfinal.com/">官网</a>，<a href="https://github.com/jfinal/jfinal">Github</a></li><li><a href="http://openjpa.apache.org/">Apache OpenJPA</a>: 实现了 EJB 3.0 中的 JPA 标准,为开发者提供功能强大、使用简单的持久化数据管理框架。 <a href="http://openjpa.apache.org/">官网</a></li></ul><h3 id="pdf">PDF</h3><p><em>用来帮助创建PDF文件的资源。</em></p><ul><li><a href="http://www.importnew.com/apache_fop/">Apache FOP</a>：从XSL-FO创建PDF。<a href="http://xmlgraphics.apache.org/fop/">官网</a></li><li><a href="http://www.importnew.com/apache-pdfbox/">Apache PDFBox</a>：用来创建和操作PDF的工具集。<a href="http://pdfbox.apache.org/">官网</a></li><li><a href="http://www.importnew.com/dynamicreports/">DynamicReports</a>：JasperReports的精简版。<a href="http://dynamicreports.org/">官网</a></li><li><a href="http://www.importnew.com/flyingsaucer/">flyingsaucer</a>：XML&#x2F;XHTML和CSS 2.1渲染器。<a href="https://github.com/flyingsaucerproject/flyingsaucer">官网</a></li><li><a href="http://www.importnew.com/itext/">iText</a>：一个易于使用的PDF函数库，用来编程创建PDF文件。注意，用于商业用途时需要许可证。<a href="http://itextpdf.com/">官网</a></li><li><a href="http://www.importnew.com/jasperreports/">JasperReports</a>：一个复杂的报表引擎。<a href="http://community.jaspersoft.com/project/jasperreports-library">官网</a></li></ul><h3 id="performance-analysis">性能分析</h3><p><em>性能分析、性能剖析及基准测试工具。</em></p><ul><li><a href="http://www.importnew.com/jhiccup/">jHiccup</a>：提供平台中JVM暂停的日志和记录。<a href="https://github.com/giltene/jHiccup">官网</a></li><li><a href="http://www.importnew.com/jmh/">JMH</a>：JVM基准测试工具。<a href="http://openjdk.java.net/projects/code-tools/jmh/">官网</a></li><li><a href="http://www.importnew.com/jprofiler/">JProfiler</a>：商业分析器。<a href="https://www.ej-technologies.com/products/jprofiler/overview.html">官网</a></li><li><a href="http://www.importnew.com/latencyutils/">LatencyUtils</a>：测量和报告延迟的工具。<a href="https://github.com/LatencyUtils/LatencyUtils">官网</a></li><li><a href="http://www.importnew.com/visualvm/">VisualVM</a>：对运行中的应用程序信息提供了可视化界面。<a href="http://visualvm.java.net/">官网</a></li><li><a href="http://www.importnew.com/yourkit-java-profiler/">YourKit Java Profiler</a>：商业分析器。<a href="https://www.yourkit.com/features/">官网</a></li></ul><h3 id="reactive-libraries">响应式开发库</h3><p><em>用来开发响应式应用程序的开发库。</em></p><ul><li><a href="http://www.importnew.com/reactive-streams/">Reactive Streams</a>：异步流处理标准，支持非阻塞式反向压力（backpressure）。<a href="https://github.com/reactive-streams/reactive-streams-jv/">官网</a></li><li><a href="http://www.importnew.com/reactor/">Reactor</a>：构建响应式快速数据（fast-data）应用程序的开发库。<a href="http://projectreactor.io/">官网</a></li><li><a href="http://www.importnew.com/rxjava/">RxJava</a>：通过JVM可观察序列（observable sequence）构建异步和基于事件的程序。<a href="https://github.com/ReactiveX/RxJava">官网</a></li></ul><h3 id="rest-frameworks">REST框架</h3><p><em>用来创建RESTful 服务的框架。</em></p><ul><li><a href="http://www.importnew.com/dropwizard/">Dropwizard</a>：偏向于自己使用的Web框架。用来构建Web应用程序，使用了Jetty、Jackson、Jersey和Metrics。<a href="https://dropwizard.github.io/drpwizard/">官网</a></li><li><a href="http://www.importnew.com/feign/">Feign</a>：受Retrofit、JAXRS-2.0和WebSocket启发的HTTP客户端连接器（binder）。<a href="https://github.com/Netflix/feign">官网</a></li><li>Jersey：JAX-RS参考实现。<a href="https://jersey.java.net/">官网</a></li><li><a href="http://www.importnew.com/resteasy/">RESTEasy</a>：经过JAX-RS规范完全认证的可移植实现。<a href="http://resteasy.jboss.org/">官网</a></li><li><a href="http://www.importnew.com/restexpress/">RestExpress</a>：一个Java类型安全的REST客户端。<a href="https://github.com/RestExpress/RestExpress">官网</a></li><li><a href="http://www.importnew.com/restx/">RestX</a>：基于注解处理和编译时源码生成的框架。<a href="http://restx.io/">官网</a></li><li><a href="http://www.importnew.com/retrofit/">Retrofit</a>：类型安全的REST客户端。<a href="http://square.github.io/retrofit/">官网</a></li><li><a href="http://www.importnew.com/sparkjava/">Spark</a>：受到Sinatra启发的Java REST框架。<a href="http://sparkjava.com/">官网</a></li><li><a href="http://www.importnew.com/swagger/">Swagger</a>：Swagger是一个规范且完整的框架，提供描述、生产、消费和可视化RESTful Web Service。<a href="http://swagger.io/">官网</a></li><li><a href="http://www.importnew.com/bladejava/">Blade</a>：国人开发的一个轻量级的MVC框架. 它拥有简洁的代码，优雅的设计。<a href="https://lets-blade.com/">官网</a></li></ul><h3 id="science">科学计算与分析</h3><p><em>用于科学计算和分析的函数库。</em></p><ul><li><a href="http://www.importnew.com/datamelt/">DataMelt</a>：用于科学计算、数据分析及数据可视化的开发环境。<a href="http://jwork.org/dmelt/">官网</a></li><li><a href="http://www.importnew.com/jgrapht/">JGraphT</a>：支持数学图论对象和算法的图形库。<a href="https://github.com/jgrapht/jgrapht">官网</a></li><li><a href="http://www.importnew.com/jscience/">JScience</a>：用来进行科学测量和单位的一组类。<a href="http://jscience.org/">官网</a></li></ul><h3 id="search">搜索引擎</h3><p><em>文档索引引擎，用于搜索和分析。</em></p><ul><li><a href="http://www.importnew.com/solr/">Apache Solr</a>：一个完全的企业搜索引擎。为高吞吐量通信进行了优化。<a href="http://lucene.apache.org/solr/">官网</a></li><li>Elasticsearch：一个分布式、支持多租户（multitenant）全文本搜索引擎。提供了RESTful Web接口和无schema的JSON文档。<a href="http://www.elsticsearch.org/">官网</a></li><li>Apache Lucene：是一个开放源代码的全文检索引擎工具包，是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎。<a href="http://lucene.apache.org/">官网</a></li></ul><h3 id="security">安全</h3><p><em>用于处理安全、认证、授权或会话管理的函数库。</em></p><ul><li><a href="http://www.importnew.com/shiro/">Apache Shiro</a>：执行认证、授权、加密和会话管理。<a href="http://shiro.apache.org/">官网</a></li><li><a href="http://www.importnew.com/bouncy-castle/">Bouncy Castle</a>，涵盖了从基础的帮助函数到PGP&#x2F;SMIME操作。<a href="https://www.bouncycastle.org/java.html">官网</a>：多途加密开发库。支持JCA提供者（JCA provider)</li><li><a href="http://www.importnew.com/cryptomator/">Cryptomator</a>：在云上进行客户端跨平台透明加密。<a href="https://cryptomator.org/">官网</a></li><li><a href="http://www.importnew.com/keycloak/">Keycloak</a>：为浏览器应用和RESTful Web Service集成SSO和IDM。目前还处于beta版本，但是看起来非常有前途。<a href="http://keycloak.jboss.org/">官网</a></li><li><a href="http://www.importnew.com/picketlink/">PicketLink</a>：PicketLink是一个针对Java应用进行安全和身份认证管理的大型项目（Umbrella Project）。<a href="http://picketlink.org/">官网</a></li></ul><h3 id="serialization">序列化</h3><p><em>用来高效处理序列化的函数库。</em></p><ul><li><a href="http://www.importnew.com/flatbuffers/">FlatBuffers</a>：高效利用内存的序列化函数库，无需解包和解析即可高效访问序列化数据。<a href="https://github.com/google/flatbuffers">官网</a></li><li><a href="http://www.importnew.com/kryo/">Kryo</a>：快速、高效的对象图形序列化框架。<a href="https://github.com/EsotericSoftware/kryo">官网</a></li><li><a href="http://www.importnew.com/fst/">FST</a>：提供兼容JDK的高性能对象图形序列化。<a href="https://github.com/RuedigerMoeller/fast-serialization">官网</a></li><li><a href="http://www.importnew.com/messagepack/">MessagePack</a>：一种高效的二进制序列化格式。<a href="https://github.com/msgpack/msgpack-java">官网</a></li></ul><h3 id="server">应用服务器</h3><p><em>用来部署应用程序的服务器。</em></p><ul><li><a href="http://www.importnew.com/apache-tomcat/">Apache Tomcat</a>：针对Servlet和JSP的应用服务器，健壮性好且适用性强。<a href="http://tomcat.apache.org/">官网</a></li><li><a href="http://www.importnew.com/tomee/">Apache TomEE</a>：Tomcat加Java EE。<a href="http://tomee.apache.org/">官网</a></li><li><a href="http://www.importnew.com/jetty/">Jetty</a>：轻量级、小巧的应用服务器，通常会嵌入到项目中。<a href="http://www.eclipse.org/jetty/">官网</a></li><li><a href="http://www.importnew.com/websphere-liberty/">WebSphere Liberty</a>：轻量级、模块化应用服务器，由IBM开发。<a href="https://developer.ibm.com/wasdev/">官网</a></li><li><a href="http://www.importnew.com/wildfly/">WildFly</a>：之前被称作JBoss，由Red Hat开发。支持很多Java EE功能。<a href="http://www.wildfly.org/">官网</a></li></ul><h3 id="template-engine">模板引擎</h3><p><em>在模板中替换表达式的工具。</em></p><ul><li><a href="http://www.importnew.com/velocity/">Apache Velocity</a>：提供HTML页面模板、email模板和通用开源代码生成器模板。<a href="http://velocity.apache.org/">官网</a></li><li><a href="http://www.importnew.com/freemarker/">FreeMarker</a>：通用模板引擎，不需要任何重量级或自己使用的依赖关系。<a href="http://freemarker.org/">官网</a></li><li><a href="http://www.importnew.com/handlebars-java/">Handlebars.java</a>：使用Java编写的模板引擎，逻辑简单，支持语义扩展（semantic Mustache）。<a href="http://jknack.github.io/handlebars.java/">官网</a></li><li><a href="http://www.importnew.com/thymeleaf/">Thymeleaf</a>：旨在替换JSP，支持XML文件的工具。<a href="http://www.thymeleaf.org/">官网</a></li><li><a href="http://ibeetl.com/">Beetl</a>：新一代的模板引擎，功能强大，性能良好，超过当前流行的模板引擎。而且还易学易用。<a href="http://ibeetl.com/">官网</a></li></ul><h3 id="testing">测试</h3><p><em>测试内容从对象到接口，涵盖性能测试和基准测试工具。</em></p><ul><li><a href="http://www.importnew.com/jmeter/">Apache JMeter</a>：功能性测试和性能评测。<a href="http://jmeter.apache.org/">官网</a></li><li><a href="http://www.importnew.com/arquillian/">Arquillian</a>：集成测试和功能行测试平台，集成Java EE容器。<a href="http://arquillian.org/">官网</a></li><li><a href="http://www.importnew.com/assertj/">AssertJ</a>：支持流式断言提高测试的可读性。<a href="http://joel-costigliola.github.io/assertj/">官网</a></li><li><a href="http://www.importnew.com/awaitility/">Awaitility</a>：用来同步异步操作的DSL。<a href="https://github.com/jayway/awaitility">官网</a></li><li><a href="http://www.importnew.com/cucumber-jvm/">Cucumber</a>：BDD测试框架。<a href="https://github.com/cucumber/cucumber-jvm">官网</a></li><li>Gatling：设计为易于使用、可维护的和高性能负载测试工具。<a href="http://gatling.io/">官网</a></li><li><a href="http://www.importnew.com/hamcrest/">Hamcrest</a>：可用来灵活创建意图（intent）表达式的匹配器。<a href="http://hamcrest.org/JavaHamcrest/">官网</a></li><li>JMockit：用来模拟静态、final方法等。<a href="http://jmockit.org/">官网</a></li><li><a href="http://www.importnew.com/junit/">JUnit</a>：通用测试框架。<a href="http://junit.org/">官网</a></li><li><a href="http://www.importnew.com/mockito/">Mockito</a>：在自动化单元测试中创建测试对象，为TDD或BDD提供支持。<a href="https://github.com/mockito/mockito">官网</a></li><li><a href="http://www.importnew.com/powermock/">PowerMock</a>： 支持模拟静态方法、构造函数、final类和方法、私有方法以及移除静态初始化器的模拟工具。<a href="https://github.com/jayway/powermock">官网</a></li><li><a href="http://www.importnew.com/rest-assured/">REST Assured</a>：为REST&#x2F;HTTP服务提供方便测试的Java DSL。<a href="https://github.com/jayway/rest-assured">官网</a></li><li><a href="http://www.importnew.com/selenide/">Selenide</a>：为Selenium提供精准的周边API，用来编写稳定且可读的UI测试。<a href="http://selenide.org/">官网</a></li><li><a href="http://www.importnew.com/selenium/">Selenium</a>：为Web应用程序提供可移植软件测试框架。<a href="http://docs.seleniumhq.org/">官网</a></li><li><a href="http://www.importnew.com/spock/">Spock</a>：JUnit-compatible framework featuring an expressive Groovy-derived specification language.<a href="http://docs.spockframework.org/">官网</a>兼容JUnit框架，支持衍生的Groovy范的语言。</li><li><a href="http://www.importnew.com/testng/">TestNG</a>：测试框架。<a href="http://testng.org/">官网</a></li><li><a href="http://www.importnew.com/truth/">Truth</a>：Google的断言和命题（proposition）框架。<a href="https://github.com/google/truth">官网</a></li><li><a href="http://www.importnew.com/unitils/">Unitils</a>：模块化测试函数库，支持单元测试和集成测试。<a href="http://www.unitils.org/">官网</a></li><li><a href="http://www.importnew.com/wiremock/">WireMock</a>：Web Service测试桩（Stub）和模拟函数。<a href="http://wiremock.org/">官网</a></li></ul><h3 id="utility">通用工具库</h3><p><em>通用工具类函数库。</em></p><ul><li><a href="http://www.importnew.com/apache-commons/">Apache Commons</a>：提供各种用途的函数，比如配置、验证、集合、文件上传或XML处理等。<a href="http://commons.apache.org/">官网</a></li><li><a href="http://www.importnew.com/args4j/">args4j</a>：命令行参数解析器。<a href="http://args4j.kohsuke.org/">官网</a></li><li><a href="http://www.importnew.com/crash/">CRaSH</a>：为运行进行提供CLI。<a href="http://www.crashub.org/">官网</a></li><li><a href="http://www.importnew.com/gephi/">Gephi</a>：可视化跨平台网络图形化操作程序。<a href="https://github.com/gephi/gephi/">官网</a></li><li><a href="http://www.importnew.com/guava/">Guava</a>：集合、缓存、支持基本类型、并发函数库、通用注解、字符串处理、I&#x2F;O等。<a href="https://github.com/google/guava">官网</a></li><li><a href="http://www.importnew.com/jade/">JADE</a>：构建、调试多租户系统的框架和环境。<a href="http://jade.tilab.com/">官网</a></li><li><a href="http://www.importnew.com/javatuples/">javatuples</a>：正如名字表示的那样，提供tuple支持。尽管目前tuple的概念还有留有争议。<a href="http://www.javatuples.org/">官网</a></li><li><a href="http://www.importnew.com/jcommander/">JCommander</a>：命令行参数解析器。<a href="http://jcommander.org/">官网</a></li><li><a href="http://www.importnew.com/protege/">Protégé</a>：提供存在论（ontology）编辑器以及构建知识系统的框架。<a href="http://protege.stanford.edu/">官网</a></li><li><a href="https://github.com/looly/hutool">Hutool</a>：一个Java工具集，缓存、HTTP、加密解密、DFA、JSON、分组配置文件、数据库操作、图片验证码、Excel读写、定时任务、模板引擎、邮件、Servlet、二维码、Emoji、分词等一系列工具类。<a href="https://hutool.cn/">官网</a></li></ul><h3 id="web-crawling">网络爬虫</h3><p><em>用于分析网站内容的函数库。</em></p><ul><li><a href="http://www.importnew.com/nutch/">Apache Nutch</a>：可用于生产环境的高度可扩展、可伸缩的网络爬虫。<a href="http://nutch.apache.org/">官网</a></li><li><a href="http://www.importnew.com/crawler4j/">Crawler4j</a>：简单的轻量级网络爬虫。<a href="https://github.com/yasserg/crawler4j">官网</a></li><li><a href="http://www.importnew.com/jsoup/">JSoup</a>：刮取、解析、操作和清理HTML。<a href="http://jsoup.org/">官网</a></li><li><a href="https://github.com/code4craft/webmagic/">webmagic</a>：一个可扩展的Java爬虫框架，架构类似Python的Scrapy。</li></ul><h3 id="web-frameworks">Web框架</h3><p><em>用于处理Web应用程序不同层次间通讯的框架。</em></p><ul><li><a href="http://www.importnew.com/apache-tapestry/">Apache Tapestry</a>：基于组件的框架，使用Java创建动态、强健的、高度可扩展的Web应用程序。<a href="http://tapestry.apache.org/">官网</a></li><li><a href="http://www.importnew.com/apache-wicket/">Apache Wicket</a>：基于组件的Web应用框架，与Tapestry类似带有状态显示GUI。<a href="http://wicket.apache.org/">官网</a></li><li><a href="http://www.importnew.com/gwt/">Google Web Toolkit</a>：一组Web开发工具集，包含在客户端将Java代码转为JavaScript的编译器、XML解析器、RCP <a href="http://www.gwtproject.org/">官网</a>API、JUnit集成、国际化支持和GUI控件。</li><li><a href="http://www.importnew.com/grails/">Grails</a>：Groovy框架，旨在提供一个高效开发环境，使用约定而非配置、没有XML并支持混入（mixin）。<a href="https://grails.org/">官网</a></li><li><a href="http://www.importnew.com/ninja/">Ninja</a>：Java全栈Web开发框架。非常稳固、快速和高效。<a href="http://www.ninjaframework.org/">官网</a></li><li><a href="http://www.importnew.com/pippo/">Pippo</a>：小型、高度模块化的类Sinatra框架。<a href="http://www.pippo.ro/">官网</a></li><li><a href="http://www.importnew.com/play-framework/">Play</a>：使用约定而非配置，支持代码热加载并在浏览器中显示错误。<a href="https://www.playframework.com/">官网</a></li><li><a href="http://www.importnew.com/primefaces/">PrimeFaces</a>：JSF框架，提供免费和带支持的商业版本。包括若干前端组件。<a href="http://primefaces.org/">官网</a></li><li><a href="http://www.importnew.com/ratpack/">Ratpack</a>：一组Java开发函数库，用于构建快速、高效、可扩展且测试完备的HTTP应用程序。<a href="https://ratpack.io/">官网</a></li><li><a href="http://www.importnew.com/spring-boot/">Spring Boot</a>：微框架，简化了Spring新程序的开发过程。<a href="http://projects.spring.io/spring-boot/">官网</a></li><li><a href="http://www.importnew.com/spring-framework/">Spring</a>：旨在简化Java EE的开发过程，提供依赖注入相关组件并支持面向切面编程。<a href="http://projects.spring.io/spring-framework/">官网</a></li><li><a href="http://www.importnew.com/vaadin/">Vaadin</a>：基于GWT构建的事件驱动框架。使用服务端架构，客户端使用Ajax。<a href="https://vaadin.com/">官网</a></li><li><a href="http://www.importnew.com/bladejava/">Blade</a>：国人开发的一个轻量级的MVC框架. 它拥有简洁的代码，优雅的设计。<a href="https://lets-blade.com/">官网</a></li></ul><h3 id="Business-Process-Management">业务流程管理套件</h3><p><em>流程驱动的软件系统构建。</em></p><ul><li><a href="http://www.importnew.com/jbpm/">jBPM</a>：非常灵活的业务流程管理框架，致力于构建开发与业务分析人员之间的桥梁。<a href="http://www.jbpm.org/">官网</a></li><li>Activity：轻量级工作流和业务流程管理框架。<a href="http://www.activiti.org/">官网</a> <a href="https://github.com/Activiti/Activiti">github</a></li></ul><h2 id="resources">资源</h2><h3 id="communities">社区</h3><ul><li>r&#x2F;java：Reddit的Java子社区。<a href="https://www.reddit.com/r/java">官网</a></li><li>stackoverflow：问答平台。<a href="http://stackoverflow.com/questions/tagged/java">官网</a></li><li>vJUG：虚拟Java用户组。<a href="http://virtualjug.com/">官网</a></li><li>java8 新特性教程例子。<a href="https://github.com/winterbe/java8-tutorial">github</a></li></ul><h3 id="influential-books">有影响力的书</h3><p><em>具有广泛影响且值得阅读的Java经典书籍。</em></p><ul><li><a href="http://www.importnew.com/effective-java/">Effective Java (2nd Edition)</a></li><li><a href="http://www.importnew.com/java-8-in-action/">Java 8 in Action</a></li><li><a href="http://www.importnew.com/java-concurrency-in-practice/">Java Concurrency in Practice | Java并发编程实战</a></li><li><a href="http://www.importnew.com/thinking-in-java/">Thinking in Java | Java编程思想</a></li><li><a href="http://www.importnew.com/java-puzzlers/">Java Puzzlers | Java解惑</a></li></ul><h3 id="podcasts">播客</h3><p><em>可以一边编程一边听的东西。</em></p><ul><li>Java Council：<a href="http://virtualjug.com/#podcast/">官网</a></li><li>Java Posse：Discontinued as of 02&#x2F;2015.<a href="http://www.javaposse.com/">官网</a></li></ul><h3 id="weibo-weixin">微博、微信公众号</h3><ul><li>ImportNew：是最受欢迎的、专注Java技术分享的微信公众号。专注Java技术分享，包括Java基础技术、进阶技能、架构设计和Java技术领域动态等。<br><br><img src="http://ww2.sinaimg.cn/small/63918611gw1epb2c7rv2uj20460463ym.jpg"></li><li>ImportNew 微博：<a href="http://weibo.com/importnew">@ImportNew</a></li></ul><h3 id="twitter">Twitter</h3><ul><li><a href="https://twitter.com/AdamBien/">Adam Bien</a>：自由职业者、作家、JavaONE明星演讲者、顾问、Java Champion。</li><li><a href="https://twitter.com/agoncal/">Antonio Goncalves</a>：Java Champion、JUG Leader、Devoxx France、Java EE 6&#x2F;7、JCP、作家。</li><li><a href="https://twitter.com/arungupta/">Arun Gupta</a>：Java Champion、JavaONE明星演讲者、JUG Leader、Devoxx4Kids成员、Red Hatter。</li><li><a href="https://twitter.com/brunoborges">Bruno Borges</a>：Oracle产品经理、Java Jock。</li><li><a href="https://twitter.com/edburns">Ed Burns</a>：Oracle技术团队顾问。</li><li><a href="https://twitter.com/baeldung">Eugen Paraschiv</a>：Spring安全课程作者。</li><li><a href="https://twitter.com/JavaFXpert">James Weaver</a>：Java、JavaFX、IoT开发者、作者和演讲者。</li><li><a href="https://twitter.com/Java_EE/">Java EE</a>：Java EE Twitter官方账号。</li><li><a href="https://twitter.com/Oraclejavamag">Java Magazine</a>：Java杂志官方账号。</li><li><a href="https://twitter.com/javanetbuzz/">Java.net</a>：Java.net官方账号。</li><li><a href="https://twitter.com/java/">Java</a>：Java Twitter官方账号。</li><li><a href="https://twitter.com/javinpaul">Javin Paul</a>：知名Java博客作者。</li><li><a href="https://twitter.com/lukaseder">Lukas Eder</a>：Data Geekery（jOOQ）创始人兼CEO。</li><li><a href="https://twitter.com/mariofusco">Mario Fusco</a>：RedHatter、JUG协调、活跃讲师和作者。</li><li><a href="https://twitter.com/mreinhold">Mark Reinhold</a>：Oracle首席架构师、Java平台开发组。</li><li><a href="https://twitter.com/karianna">Martijn Verburg</a>：London JUG co-leader、演讲者、作家、Java Champion等。</li><li><a href="https://twitter.com/OpenJDK">OpenJDK</a>：OpenJDK官方账号。</li><li><a href="https://twitter.com/reza_rahman">Reza Rahman</a>：Java EE、GlassFish、WebLogic传道者、作家、演讲者、开源黑客。</li><li><a href="https://twitter.com/sjmaple">Simon Maple</a>：Java Champion、virtualJUG创始人、LJC leader、RebelLabs作者。</li><li><a href="https://twitter.com/jodastephen">Stephen Colebourne</a>： Java Champion、演讲者。</li><li><a href="https://twitter.com/kablosna">Tim Boudreau</a>：作家、NetBeans大牛。</li><li><a href="https://twitter.com/trisha_gee">Trisha Gee</a>：Java Champion、演讲者。</li></ul><h3 id="weibo-weixin">微博、微信公众号</h3><ul><li>ImportNew 微博：<a href="http://weibo.com/importnew">@ImportNew</a></li><li>ImportNew：最受欢迎的、专注Java技术分享的微信公众号。专注Java技术分享，包括Java基础技术、进阶技能、架构设计和Java技术领域动态等。<br><br><img src="http://ww2.sinaimg.cn/small/63918611gw1epb2c7rv2uj20460463ym.jpg" width=150 height=150></li></ul><h3 id="websites">知名网站</h3><p><em>值得关注的Java技术站点。</em></p><h4>中文站点</h4><ul><li><a href="http://www.importnew.com/">ImportNew</a>（ImportNew 专注 Java 技术）</li></ul><h4>英文站点</h4><ul><li><a href="https://android-arsenal.com/">Android Arsenal</a></li><li><a href="http://www.importnew.com/google-java-style/">Google Java Style</a>：<a href="https://google.github.io/styleguide/javaguide.html">官网</a></li><li><a href="http://www.importnew.com/infoq/">InfoQ</a>：<a href="http://www.infoq.com/">官网</a></li><li><a href="http://www.javacodegeeks.com/">Java Code Geeks</a></li><li><a href="http://blog.jooq.org/">Java, SQL, and jOOQ</a></li><li><a href="http://java.net/">Java.net</a></li><li><a href="http://java.dzone.com/">Javalobby</a></li><li><a href="http://www.importnew.com/javaworld/">JavaWorld</a>：<a href="http://www.javaworld.com/">官网</a></li><li><a href="http://www.importnew.com/jaxenter/">JAXenter</a>：<a href="https://jaxenter.com/">官网</a></li><li><a href="http://zeroturnaround.com/rebellabs/">RebelLabs</a></li><li><a href="http://www.importnew.com/javaspecialists/">The Java Specialist’ Newsletter</a>：<a href="http://www.javaspecialists.eu/archive/archive.jsp">官网</a></li><li><a href="http://blog.takipi.com/">The Takipi Blog</a></li><li><a href="http://www.importnew.com/theserverside/">TheServerSide.com</a>：服务器编程交流平台是一个老牌的IT信息网站，关注服务器端编程的，以Java和.Net周边信息为主。<a href="http://www.theserverside.com/">官网</a></li><li><a href="http://www.thoughts-on-java.org/">Thoughts On Java</a></li><li><a href="http://vanillajava.blogspot.ch/">Vanilla Java</a></li><li><a href="http://vladmihalcea.com/">Vlad Mihalcea on Hibernate</a></li><li><a href="https://www.voxxed.com/">Voxxed</a></li><li><a href="http://www.importnew.com/onjava/">OnJava</a>：O’Reilly Java包含最新的Java技术资讯，优质代码，完全的实例和详解。<a href="http://www.onjava.com/">官网</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深入分析 Java、Kotlin、Go 的线程和协程</title>
    <link href="/2020/12/10/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%20Java%E3%80%81Kotlin%E3%80%81Go%20%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/"/>
    <url>/2020/12/10/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%20Java%E3%80%81Kotlin%E3%80%81Go%20%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-12-10-070550.jpg"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Go 语言比 Java 语言性能优越的一个原因，就是轻量级线程<code>Goroutines</code>（协程Coroutine）。本篇文章深入分析下 Java 的线程和 Go 的协程。</p><h2 id="协程是什么"><a href="#协程是什么" class="headerlink" title="协程是什么"></a>协程是什么</h2><p>协程并不是 Go 提出来的新概念，其他的一些编程语言，例如：Go、Python 等都可以在语言层面上实现协程，甚至是 Java，也可以通过使用扩展库来间接地支持协程。</p><p>当在网上搜索协程时，我们会看到：</p><ul><li>Kotlin 官方文档说「本质上，协程是轻量级的线程」。</li><li>很多博客提到「不需要从用户态切换到内核态」、「是协作式的」等等。</li></ul><p>「协程 Coroutines」源自 Simula 和 Modula-2 语言，这个术语早在 1958 年就被 Melvin Edward Conway 发明并用于构建汇编程序，说明协程是一种编程思想，并不局限于特定的语言。</p><h2 id="协程的好处"><a href="#协程的好处" class="headerlink" title="协程的好处"></a>协程的好处</h2><p>性能比 Java 好很多，甚至代码实现都比 Java 要简洁很多。</p><p>那这究竟又是为什么呢？下面一一分析。</p><p>说明：下面关于进程和线程的部分，几乎完全参考自：<a href="https://www.cnblogs.com/Survivalist/p/11527949.html%EF%BC%8C%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%86%99%E5%BE%97%E5%A4%AA%E5%A5%BD%E4%BA%86">https://www.cnblogs.com/Survivalist/p/11527949.html，这篇文章写得太好了</a>~~~</p><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="进程是什么"><a href="#进程是什么" class="headerlink" title="进程是什么"></a>进程是什么</h2><p>计算机的核心是 CPU，执行所有的计算任务；操作系统负责任务的调度、资源的分配和管理；应用程序是具有某种功能的程序，程序是运行在操作系统上的。</p><p>进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。</p><h2 id="进程组成"><a href="#进程组成" class="headerlink" title="进程组成"></a>进程组成</h2><p>进程由三部分组成：</p><ul><li><code>程序</code>：描述进程要完成的功能，是控制进程执行的指令集。</li><li><code>数据集合</code>：程序在执行时所需要的数据和工作区。</li><li><code>进程控制块</code>：(Program Control Block，简称PCB)，包含进程的描述信息和控制信息，是进程存在的唯一标志。</li></ul><h2 id="进程特征"><a href="#进程特征" class="headerlink" title="进程特征"></a>进程特征</h2><ul><li>动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的。</li><li>并发性：任何进程都可以同其他进程一起并发执行。</li><li>独立性：进程是系统进行资源分配和调度的一个独立单位。</li><li>结构性：进程由程序、数据和进程控制块三部分组成。</li></ul><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="线程是什么"><a href="#线程是什么" class="headerlink" title="线程是什么"></a>线程是什么</h2><p>线程是程序执行中一个单一的<code>顺序控制流程</code>，是<code>程序执行流的最小单元</code>，是<code>处理器调度和分派的基本单位</code>。一个进程可以有一个或多个线程，各个线程之间<code>共享程序的内存空间</code>(也就是所在进程的内存空间)。</p><h2 id="线程组成"><a href="#线程组成" class="headerlink" title="线程组成"></a>线程组成</h2><ul><li>线程ID、当前指令指针(PC)</li><li>寄存器</li><li>堆栈</li></ul><h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><p>大部分操作系统(如Windows、Linux)的任务调度是采用<code>时间片轮转的抢占式调度方式</code>。</p><p>在一个进程中，当一个线程任务执行几毫秒后，会由操作系统的内核（负责管理各个任务）进行调度，通过硬件的计数器中断处理器，让该线程强制暂停并将该线程的寄存器放入内存中，通过查看线程列表决定接下来执行哪一个线程，并从内存中恢复该线程的寄存器，最后恢复该线程的执行，从而去执行下一个任务。</p><h2 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h2><ul><li>线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；</li><li>一个进程由一个或多个线程组成，<code>线程是一个进程中代码的不同执行路线</code>；</li><li>进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见；</li><li>调度和切换：<code>线程上下文切换</code>比<code>进程上下文切换</code>要<code>快</code>得多。</li></ul><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-12-10-120038.jpg"></p><h2 id="线程的实现模型"><a href="#线程的实现模型" class="headerlink" title="线程的实现模型"></a>线程的实现模型</h2><p>程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——<code>轻量级进程（Lightweight Process，LWP）</code>，轻量级进程就是我们通常意义上所讲的线程，也被叫做用户线程。</p><h3 id="一对一模型"><a href="#一对一模型" class="headerlink" title="一对一模型"></a>一对一模型</h3><p>一个用户线程对应一个内核线程，如果是多核的 CPU，那么线程之间是真正的并发。</p><p>缺点：</p><ul><li>内核线程的数量有限，一对一模型使用的用户线程数量有限制。</li><li>内核线程的调度，上下文切换的开销较大（虽然没有进程上下文切换的开销大），导致用户线程的执行效率下降。</li></ul><h3 id="多对一模型"><a href="#多对一模型" class="headerlink" title="多对一模型"></a>多对一模型</h3><p><code>多个用户线程</code>映射到<code>一个内核线程</code>上，线程间的切换由<code>用户态</code>的代码来进行。用户线程的建立、同步、销毁都是在用户态中完成，不需要内核的介入。因此多对一的上下文切换速度快很多，且用户线程的数量几乎没有限制。</p><p>缺点：</p><ul><li>若一个用户线程阻塞，其他所有线程都无法执行，此时内核线程处于阻塞状态。</li><li>处理器数量的增加，不会对多对一模型的线程性能造成影响，因为所有的用户线程都映射到了一个处理器上。</li></ul><h3 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h3><p>结合了<code>一对一模型</code>和<code>多对一</code>模型的优点，多个用户线程映射到多个内核线程上，由<code>线程库</code>负责在可用的可调度实体上调度用户线程。这样线程间的上下文切换很快，因为它避免了系统调用。但是增加了系统的复杂性。</p><p>优点：</p><ul><li>一个用户线程的阻塞不会导致所有线程的阻塞，因为此时还有别的内核线程被调度来执行；</li><li>多对多模型对用户线程的数量没有限制；</li><li>在多处理器的操作系统中，多对多模型的线程也能得到一定的性能提升，但提升的幅度不如一对一模型的高。</li></ul><h2 id="线程的“并发”"><a href="#线程的“并发”" class="headerlink" title="线程的“并发”"></a>线程的“并发”</h2><p>只有在线程的数量 &lt; 处理器的数量时，线程的并发才是真正的并发，这时不同的线程运行在不同的处理器上。但是当线程的数量 &gt; 处理器的数量时，会出现一个处理器运行多个线程的情况。</p><p>在单个处理器运行多个线程时，并发是一种模拟出来的状态。操作系统采用时间片轮转的方式轮流执行每一个线程。现在，几乎所有的现代操作系统采用的都是时间片轮转的抢占式调度方式。</p><h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>当在网上搜索协程时，我们会看到：</p><ul><li>本质上，协程是轻量级的线程。</li><li>很多博客提到「不需要从用户态切换到内核态」、「是协作式的」。</li></ul><p>协程也并不是 Go 提出来的，协程是一种编程思想，并不局限于特定的语言。Go、Python、Kotlin 都可以在语言层面上实现协程，Java 也可以通过扩展库的方式间接支持协程。</p><p>协程比线程更加轻量级，可以由程序员自己管理的轻量级线程，对内核不可见。</p><h2 id="协程的目的"><a href="#协程的目的" class="headerlink" title="协程的目的"></a>协程的目的</h2><p>在传统的 J2EE 系统中都是基于每个请求占用一个线程去完成完整的业务逻辑（包括事务）。所以系统的吞吐能力取决于每个线程的操作耗时。如果遇到很耗时的 I&#x2F;O 行为，则整个系统的吞吐立刻下降，因为这个时候线程一直处于阻塞状态，如果线程很多的时候，会存在很多线程处于空闲状态（等待该线程执行完才能执行），造成了资源应用不彻底。</p><p>最常见的例子就是 JDBC（它是同步阻塞的），这也是为什么很多人都说数据库是瓶颈的原因。这里的耗时其实是让 CPU 一直在等待 I&#x2F;O 返回，说白了线程根本没有利用 CPU 去做运算，而是处于空转状态。而另外过多的线程，也会带来更多的 ContextSwitch 开销。</p><p>对于上述问题，现阶段行业里的比较流行的解决方案之一就是单线程加上异步回调。其代表派是 node.js 以及 Java 里的新秀 Vert.x。</p><p>而协程的目的就是当出现长时间的 I&#x2F;O 操作时，通过让出目前的协程调度，执行下一个任务的方式，来消除 ContextSwitch 上的开销。</p><h2 id="协程的特点"><a href="#协程的特点" class="headerlink" title="协程的特点"></a>协程的特点</h2><ul><li>线程的切换由操作系统负责调度，协程由用户自己进行调度，减少了上下文切换，提高了效率</li><li>线程的默认 Stack 是1M，协程更加轻量，是 1K，在相同内存中可以开启更多的协程。</li><li>由于在同一个线程上，因此可以<code>避免竞争关系</code>而使用锁。</li><li>适用于<code>被阻塞的</code>，且需要大量并发的场景。但不适用于大量计算的多线程，遇到此种情况，更好用线程去解决。</li></ul><h2 id="协程的原理"><a href="#协程的原理" class="headerlink" title="协程的原理"></a>协程的原理</h2><p>当出现IO阻塞的时候，由协程的调度器进行调度，通过将数据流立刻yield掉（主动让出），并且记录当前栈上的数据，阻塞完后立刻再通过线程恢复栈，并把阻塞的结果放到这个线程上去跑，这样看上去好像跟写同步代码没有任何差别，这整个流程可以称为<code>coroutine</code>，而跑在由coroutine负责调度的线程称为<code>Fiber</code>。比如Golang里的 go关键字其实就是负责开启一个<code>Fiber</code>，让func逻辑跑在上面。</p><p>由于协程的暂停完全由程序控制，发生在用户态上；而线程的阻塞状态是由操作系统内核来进行切换，发生在内核态上。<br>因此，协程的开销远远小于线程的开销，也就没有了 ContextSwitch 上的开销。</p><p>假设程序中默认创建两个线程为协程使用，在主线程中创建协程ABCD…，分别存储在就绪队列中，调度器首先会分配一个工作线程A执行协程A，另外一个工作线程B执行协程B，其它创建的协程将会放在队列中进行排队等待。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-12-10-144133.jpg"></p><p>当协程A调用暂停方法或被阻塞时，协程A会进入到挂起队列，调度器会调用等待队列中的其它协程抢占线程A执行。当协程A被唤醒时，它需要重新进入到就绪队列中，通过调度器抢占线程，如果抢占成功，就继续执行协程A，失败则继续等待抢占线程。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-12-10-144157.jpg"></p><h1 id="Java、Kotlin、Go-的线程与协程"><a href="#Java、Kotlin、Go-的线程与协程" class="headerlink" title="Java、Kotlin、Go 的线程与协程"></a>Java、Kotlin、Go 的线程与协程</h1><p>Java 在 Linux 操作系统下使用的是用户线程+轻量级线程，<code>一个用户线程映射到一个内核线程</code>，线程之间的切换就涉及到了上下文切换。所以在 Java 中并不适合创建大量的线程，否则效率会很低。可以先看下 Kotlin 和 Go 的协程：</p><h2 id="Kotlin-的协程"><a href="#Kotlin-的协程" class="headerlink" title="Kotlin 的协程"></a>Kotlin 的协程</h2><p>Kotlin 在诞生之初，目标就是完全兼容 Java，却是一门非常务实的语言，其中一个特性，就是支持协程。</p><p>但是 Kotlin 最终还是运行在 JVM 中的，目前的 JVM 并不支持协程，Kotlin 作为一门编程语言，也只是能在语言层面支持协程。Kotlin 的协程是用于异步编程等场景的，在语言级提供协程支持，而将大部分功能委托给库。</p><h3 id="使用「线程」的代码"><a href="#使用「线程」的代码" class="headerlink" title="使用「线程」的代码"></a>使用「线程」的代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>fun <span class="hljs-title function_">testThread</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 执行时间 1min+</span><br>    <span class="hljs-type">val</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> AtomicLong()<br>    <span class="hljs-keyword">for</span> (i in <span class="hljs-number">1.</span>.<span class="hljs-number">1_000_000L</span>)<br>        thread(start = <span class="hljs-literal">true</span>) &#123;<br>            c.addAndGet(i)<br>        &#125;<br>    println(c.get())<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码创建了 <code>100 万个线程</code>，在每个线程里仅仅调用了 add 操作，但是由于创建线程太多，这个测试用例在我的机器上要跑 1 分钟左右。</p><h3 id="使用「协程」的代码"><a href="#使用「协程」的代码" class="headerlink" title="使用「协程」的代码"></a>使用「协程」的代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>fun <span class="hljs-title function_">testLaunch</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">val</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> AtomicLong()<br>    runBlocking &#123;<br>        <span class="hljs-keyword">for</span> (i in <span class="hljs-number">1.</span>.<span class="hljs-number">1_000_000L</span>)<br>            launch &#123;<br>                c.addAndGet(workload(i))<br>            &#125;<br>    &#125;<br>    print(c.get())<br>&#125;<br><br>suspend fun <span class="hljs-title function_">workload</span><span class="hljs-params">(n: Long)</span>: Long &#123;<br>    delay(<span class="hljs-number">1000</span>)<br>    <span class="hljs-keyword">return</span> n<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码是创建了 <code>100 万个协程</code>，测试用例在我的机器上执行时间大概是 10 秒钟。而且这段代码的每个协程都 delay 了 1 秒钟，执行效率仍然远远高于线程。</p><p>详细的语法可以查看 Kotlin 的官方网站：<a href="https://www.kotlincn.net/docs/reference/coroutines/basics.html">https://www.kotlincn.net/docs/reference/coroutines/basics.html</a></p><p>其中关键字 <code>launch</code> 是开启了一个协程，关键字 <code>suspend</code> 是挂起一个协程，而不会阻塞。现在在看这个流程，应该就懂了~</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-12-11-082219.jpg"></p><h2 id="Go-的协程"><a href="#Go-的协程" class="headerlink" title="Go 的协程"></a>Go 的协程</h2><p>官方例程：<a href="https://gobyexample-cn.github.io/goroutines">https://gobyexample-cn.github.io/goroutines</a></p><p>go语言层面并<code>不支持多进程或多线程</code>，但是协程更好用，协程被称为用户态线程，不存在CPU上下文切换问题，效率非常高。下面是一个简单的协程演示代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">go</span> say(<span class="hljs-string">&quot;Hello World&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">say</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-built_in">println</span>(s)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Java-的-Kilim-协程框架"><a href="#Java-的-Kilim-协程框架" class="headerlink" title="Java 的 Kilim 协程框架"></a>Java 的 Kilim 协程框架</h2><p>目前 Java 原生语言暂时不支持协程，可以使用 <a href="https://github.com/kilim/kilim">kilim</a>，具体原理可以看官方文档，暂时还没有研究~</p><h2 id="Java-的-Project-Loom"><a href="#Java-的-Project-Loom" class="headerlink" title="Java 的 Project Loom"></a>Java 的 Project Loom</h2><p>Java 也在逐步支持协程，其项目就是 <code>Project Loom</code>(<a href="https://openjdk.java.net/projects/loom/)%E3%80%82%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE%E5%9C%A818%E5%B9%B4%E5%BA%95%E7%9A%84%E6%97%B6%E5%80%99%E5%B7%B2%E7%BB%8F%E8%BE%BE%E5%88%B0%E5%8F%AF%E5%88%9D%E6%AD%A5%E6%BC%94%E7%A4%BA%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%98%B6%E6%AE%B5%E3%80%82%E4%B8%8D%E5%90%8C%E4%BA%8E%E4%B9%8B%E5%89%8D%E7%9A%84%E6%96%B9%E6%A1%88%EF%BC%8CProject">https://openjdk.java.net/projects/loom/)。这个项目在18年底的时候已经达到可初步演示的原型阶段。不同于之前的方案，Project</a> Loom 是从 JVM 层面对多线程技术进行彻底的改变。</p><p>官方介绍：<br><a href="http://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html">http://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html</a></p><p>其中一段介绍了为什么引入这个项目：</p><pre><code class="hljs">One of Java&#39;s most important contributions when it was first released, over twenty years ago, was the easy access to threads and synchronization primitives. Java threads (either used directly, or indirectly through, for example, Java servlets processing HTTP requests) provided a relatively simple abstraction for writing concurrent applications. These days, however, one of the main difficulties in writing concurrent programs that meet today&#39;s requirements is that the software unit of concurrency offered by the runtime — the thread — cannot match the scale of the domain&#39;s unit of concurrency, be it a user, a transaction or even a single operation. Even if the unit of application concurrency is coarse — say, a session, represented by single socket connection — a server can handle upward of a million concurrent open sockets, yet the Java runtime, which uses the operating system&#39;s threads for its implementation of Java threads, cannot efficiently handle more than a few thousand. A mismatch in several orders of magnitude has a big impact.</code></pre><p>文章大意就是本文上面所说的，Java 的用户线程与内核线程是一对一的关系，一个 Java 进程很难创建上千个线程，如果是对于 I&#x2F;O 阻塞的程序（例如数据库读取&#x2F;Web服务），性能会很低下，所以要采用类似于协程的机制。</p><h3 id="使用-Fiber"><a href="#使用-Fiber" class="headerlink" title="使用 Fiber"></a>使用 Fiber</h3><p>在引入 Project Loom 之后，JDK 将引入一个新类：java.lang.Fiber。此类与 java.lang.Thread 一起，都成为了 java.lang.Strand 的子类。即线程变成了一个虚拟的概念，有两种实现方法：Fiber 所表示的轻量线程和 Thread 所表示的传统的重量级线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Fiber</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> Fiber.schedule(() -&gt; &#123;<br>  println(<span class="hljs-string">&quot;Hello 1&quot;</span>);<br>  lock.lock(); <span class="hljs-comment">// 等待锁不会挂起线程</span><br>  <span class="hljs-keyword">try</span> &#123;<br>      println(<span class="hljs-string">&quot;Hello 2&quot;</span>);<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>      lock.unlock();<br>  &#125;<br>  println(<span class="hljs-string">&quot;Hello 3&quot;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><p>只需执行 <code>Fiber.schedule(Runnable task)</code> 就能在 <code>Fiber</code> 中执行任务。最重要的是，上面例子中的 lock.lock() 操作将不再挂起底层线程。除了 <code>Lock 不再挂起线程</code>以外，像 <code>Socket BIO 操作也不再挂起线程</code>。 但 synchronized，以及 Native 方法中线程挂起操作无法避免。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>协程大法好，比线程更轻量级，但是仅针对 I&#x2F;O 阻塞才有效；对于 CPU 密集型的应用，因为 CPU 一直都在计算并没有什么空闲，所以没有什么作用。</p><p>Kotlin 兼容 Java，在编译器、语言层面实现了协程，JVM 底层并不支持协程；Go 天生就是支持协程的，不支持多进程和多线程。Java 的 <code>Project Loom</code> 项目支持协程，</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>极客时间-Java性能调优实战&#x2F;19.如何用协程来优化多线程业务？</li><li><a href="https://www.cnblogs.com/Survivalist/p/11527949.html">https://www.cnblogs.com/Survivalist/p/11527949.html</a></li><li><a href="https://www.jianshu.com/p/5db701a764cb">https://www.jianshu.com/p/5db701a764cb</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深入分析 Java 乐观锁</title>
    <link href="/2020/12/08/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%20Java%20%E4%B9%90%E8%A7%82%E9%94%81/"/>
    <url>/2020/12/08/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%20Java%20%E4%B9%90%E8%A7%82%E9%94%81/</url>
    
    <content type="html"><![CDATA[<p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-12-08-095930.jpg"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>激烈的锁竞争，会造成<code>线程阻塞挂起</code>，导致<code>系统的上下文切换</code>，增加系统的性能开销。那有没有不阻塞线程，且保证线程安全的机制呢？——<code>乐观锁</code>。</p><h1 id="乐观锁是什么？"><a href="#乐观锁是什么？" class="headerlink" title="乐观锁是什么？"></a>乐观锁是什么？</h1><p>操作共享资源时，总是很乐观，认为自己可以成功。在操作失败时（资源被其他线程占用），并不会挂起阻塞，而仅仅是返回，并且失败的线程可以重试。</p><p>优点：</p><ul><li>不会死锁</li><li>不会饥饿</li><li>不会因竞争造成系统开销</li></ul><h1 id="乐观锁的实现"><a href="#乐观锁的实现" class="headerlink" title="乐观锁的实现"></a>乐观锁的实现</h1><h2 id="CAS-原子操作"><a href="#CAS-原子操作" class="headerlink" title="CAS 原子操作"></a>CAS 原子操作</h2><p>CAS。在 <code>java.util.concurrent.atomic</code> 中的类都是基于 CAS 实现的。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-12-08-100536.png"></p><p>以 AtomicLong 为例，一段测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCAS</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">atomicLong</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>();<br>    atomicLong.incrementAndGet();<br>&#125;<br></code></pre></td></tr></table></figure><p>java.util.concurrent.atomic.AtomicLong#incrementAndGet 的实现方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">incrementAndGet</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> U.getAndAddLong(<span class="hljs-built_in">this</span>, VALUE, <span class="hljs-number">1L</span>) + <span class="hljs-number">1L</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 U 是一个 Unsafe 实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> jdk.internal.misc.<span class="hljs-type">Unsafe</span> <span class="hljs-variable">U</span> <span class="hljs-operator">=</span> jdk.internal.misc.Unsafe.getUnsafe();<br></code></pre></td></tr></table></figure><p>本文使用的源码是 JDK 11，其 getAndAddLong 源码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@HotSpotIntrinsicCandidate</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getAndAddLong</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, <span class="hljs-type">long</span> delta)</span> &#123;<br>    <span class="hljs-type">long</span> v;<br>    <span class="hljs-keyword">do</span> &#123;<br>        v = getLongVolatile(o, offset);<br>    &#125; <span class="hljs-keyword">while</span> (!weakCompareAndSetLong(o, offset, v, v + delta));<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到里面是一个 while 循环，如果不成功就一直循环，是一个乐观锁，坚信自己能成功，一直 CAS 直到成功。最终调用了 native 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@HotSpotIntrinsicCandidate</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSetLong</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset,</span><br><span class="hljs-params">                                                <span class="hljs-type">long</span> expected,</span><br><span class="hljs-params">                                                <span class="hljs-type">long</span> x)</span>;<br></code></pre></td></tr></table></figure><h2 id="处理器实现原子操作"><a href="#处理器实现原子操作" class="headerlink" title="处理器实现原子操作"></a>处理器实现原子操作</h2><p>从上面可以看到，CAS 是调用处理器底层的指令来实现原子操作，那么处理器底层是如何实现原子操作的呢？</p><p>处理器的处理速度&gt;&gt;处理器与物理内存的通信速度，所以在处理器内部有 L1、L2 和 L3 的高速缓存，可以加快读取的速度。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-12-09-054558.jpg"></p><p><code>单核处理器</code>能够保存内存操作是原子性的，当一个线程读取一个字节，所以进程和线程看到的都是同一个缓存里的字节。但是<code>多核处理器</code>里，每个处理器都维护了一块字节的内存，每个内核都维护了一个字节的缓存，多线程并发会存在<code>缓存不一致</code>的问题。</p><p>那处理器如何保证内存操作的原子性呢？</p><ul><li>总线锁定：当处理器要操作共享变量时，会在总线上发出 Lock 信号，其他处理器就不能操作这个共享变量了。</li><li>缓存锁定：某个处理器对缓存中的共享变量操作后，就通知其他处理器重新读取该共享资源。</li></ul><h1 id="LongAdder-vs-AtomicLong"><a href="#LongAdder-vs-AtomicLong" class="headerlink" title="LongAdder vs AtomicLong"></a>LongAdder vs AtomicLong</h1><p>本文分析的 AtomicLong 源码，其实是在循环不断尝试 CAS 操作，如果长时间不成功，就会给 CPU 带来很大开销。JDK 1.8 中新增了原子类 <code>LongAdder</code>，能够更好应用于高并发场景。</p><p>LongAdder 的原理就是降低操作共享变量的并发数，也就是将对单一共享变量的操作压力分散到多个变量值上，将竞争的每个写线程的 value 值分散到一个数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的 value 值进行 CAS 操作，最后在读取值的时候会将原子操作的共享变量与各个分散在数组的 value 值相加，返回一个近似准确的数值。</p><p>LongAdder 内部由一个base变量和一个 cell[] 数组组成。当只有一个写线程，没有竞争的情况下，LongAdder 会直接使用 base 变量作为原子操作变量，通过 CAS 操作修改变量；当有多个写线程竞争的情况下，除了占用 base 变量的一个写线程之外，其它各个线程会将修改的变量写入到自己的槽 cell[] 数组中。</p><p>一个测试用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testLongAdder</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">LongAdder</span> <span class="hljs-variable">longAdder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAdder</span>();<br>    longAdder.add(<span class="hljs-number">1</span>);<br>    System.out.println(longAdder.longValue());<br>&#125;<br></code></pre></td></tr></table></figure><p>先看里面的 <code>longAdder.longValue()</code> 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">longValue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> sum();<br>&#125;<br></code></pre></td></tr></table></figure><p>最终是调用了 sum() 方法，是对里面的 cells 数组每项加起来求和。这个值在读取的时候并不准，因为这期间可能有其他线程在并发修改 cells 中某个项的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">sum</span><span class="hljs-params">()</span> &#123;<br>    Cell[] cs = cells;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> base;<br>    <span class="hljs-keyword">if</span> (cs != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (Cell c : cs)<br>            <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span>)<br>                sum += c.value;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>add() 方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">long</span> x)</span> &#123;<br>    Cell[] cs; <span class="hljs-type">long</span> b, v; <span class="hljs-type">int</span> m; Cell c;<br>    <span class="hljs-keyword">if</span> ((cs = cells) != <span class="hljs-literal">null</span> || !casBase(b = base, b + x)) &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">uncontended</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (cs == <span class="hljs-literal">null</span> || (m = cs.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||<br>            (c = cs[getProbe() &amp; m]) == <span class="hljs-literal">null</span> ||<br>            !(uncontended = c.cas(v = c.value, v + x)))<br>            longAccumulate(x, <span class="hljs-literal">null</span>, uncontended);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>add 具体的代码本篇文章就不详细叙述了~</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深入分析 Java Lock 同步锁</title>
    <link href="/2020/12/07/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%20Java%20Lock%20%E5%90%8C%E6%AD%A5%E9%94%81/"/>
    <url>/2020/12/07/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%20Java%20Lock%20%E5%90%8C%E6%AD%A5%E9%94%81/</url>
    
    <content type="html"><![CDATA[<p><img src="https://620image.oss-rg-china-mainland.aliyuncs.com/2020-12-05-062310.jpg"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 的锁实现，有 Synchronized 和 Lock。上一篇文章深入分析了 Synchronized 的实现原理：<a href="https://github.com/LjyYano/Thinking_in_Java_MindMapping/blob/master/2020-12-05%20%E7%94%B1Java%2015%E5%BA%9F%E5%BC%83%E5%81%8F%E5%90%91%E9%94%81%EF%BC%8C%E8%B0%88%E8%B0%88Java%20Synchronized%20%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6.md">由Java 15废弃偏向锁，谈谈Java Synchronized 的锁机制</a>。</p><p>本篇文章深入分析 Lock 的实现，以及对比其与 Synchronized 的不同。</p><h1 id="Synchronized-与-Lock-的对比"><a href="#Synchronized-与-Lock-的对比" class="headerlink" title="Synchronized 与 Lock 的对比"></a>Synchronized 与 Lock 的对比</h1><ul><li>实现方式：Synchronized 由 JVM 实现；Lock 由 Java 底层代码实现</li><li>锁获取：Synchronized 是 JVM 隐式获取，不用 Java 代码；Lock 由 Java 代码实现，有多种获取方式</li><li>锁的释放：Synchronized 是 JVM 隐式释放，不用 Java 代码；Lock 可通过 <code>Lock.unlock()</code>，在 finally 中释放</li><li>锁的类型：<code>Synchronized 是非公平、可重入的</code>，<code>Lock 是非公平性、公平性、可重入的</code></li><li>锁的中断：Synchronized 不支持中断，Lock 支持中断</li></ul><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>Lock 是一个接口类，其接口方法定义：</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-12-07-114730.png"></p><ul><li><code>lock()</code>：获取锁</li><li><code>lockInterruptibly()</code>：如果当前线程未被中断，则获取锁，可以响应中断</li><li><code>tryLock()</code>：仅在调用时锁为空闲状态才获取该锁，可以响应中断</li><li><code>tryLock(long time, TimeUnit unit)</code>：如果锁在给定的等待时间内空闲，并且当前线程未被中断，则获取锁</li><li><code>unlock()</code>：释放锁</li><li><code>newCondition()</code>：返回绑定到此 Lock 实例的新 Condition 实例</li></ul><p>基础原理就不赘述了，Lock 接口的常用类：</p><ul><li>ReentrantLock（重入锁）</li><li>ReentrantReadWriteLock（可重入的读写锁）</li></ul><p>其都是依赖 <code>AQS</code> 实现的。AQS 类结构中包含一个<code>基于链表实现的等待队列</code>（CLH 队列），用于存储所有阻塞的线程，AQS 中还有一个 state 变量，表示加锁状态。</p><h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/2020-12-07-115340.png"></p><h1 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h1><p>ReentrantLock 是独占锁，对于同一份数据，如果一个线程读数据，另一个线程在写数据，那么读到的数据与最终的数据可能不一致。</p><p>在实际的业务场景中，读操作远远大于写操作。在多线程编程中，读操作不会修改共享资源的数据。针对读多写少的场景，我们可以使用 ReentrantReadWriteLock 来优化，ReentrantReadWriteLock 内部维护了 2 个锁：读锁 <code>ReadLock</code>，写锁 <code>WriteLock</code>。</p><p>规则简单概括为：</p><ul><li>如果写锁没有被占用，就可以获取读锁</li><li>如果读锁没有被占用，才可以获取写锁</li></ul><p>下面的测试代码，因为读锁和写锁是同时 lock 的，所以会死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testReadWriteLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br>    lock.readLock().lock();<br>    lock.writeLock().lock();<br>    System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    lock.readLock().unlock();<br>    lock.writeLock().unlock();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h1><p>上述 ReentrantReadWriteLock 会有一个问题：在读很多，写很少的情况下，线程会因一直无法获取到锁而处于等待状态。</p><p>在 JDK 1.8 中，Java 提供了 <code>StampedLock</code>，有三种模式: </p><ul><li>写</li><li>悲观读</li><li>乐观读</li></ul><p>一个写线程获取写锁，通过 WriteLock 获取票据 stamp，WriteLock 是一个独占锁，unlockWrite 需要传递参数 stamp。</p><p>不一样的地方在于读过程。线程会先通过乐观锁 <code>tryOptimisticRead</code> 获取票据 stamp，如果当前没有线程持有写锁，则会返回一非 0 的 stamp 信息。线程获取该 stamp 后，会拷贝一份共享资源到房发展。</p><p>之后方法还需要调用 validate，验证之前调用 tryOptimisticRead 返回的 stamp 在当前是否有其它线程持有了写锁，如果是，那么 validate 会返回 0，升级为悲观锁；否则就可以使用该 stamp 版本的锁对数据进行操作。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>相比于 Synchronized 同步锁，Lock 实现的锁更加灵活：</p><ul><li>可以分为读写锁，优化读大于写的场景</li><li>可以中断</li><li>可以超时</li><li>可以区分公平性</li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
